

<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>How to Beat a Technical Coding Interview</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=365ca57ee442770a23c6" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=365ca57ee442770a23c6" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=365ca57ee442770a23c6" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=365ca57ee442770a23c6" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" href="_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=365ca57ee442770a23c6" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=365ca57ee442770a23c6" />
  <script src="_static/vendor/fontawesome/6.1.2/js/all.min.js?digest=365ca57ee442770a23c6"></script>

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'README';</script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <div id="pst-scroll-pixel-helper"></div>

  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>
    Back to top
  </button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="#">
  
  
  
  
  
  
    <p class="title logo__title">None</p>
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1 current active">
                <a class="reference internal" href="#">
                    Blind 75 LeetCode Solutions
                </a>
            </li>
        </ul>
        <ul class="nav bd-sidenav">


















</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/mohsentabibian/LeetCode-Solutions" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/mohsentabibian/LeetCode-Solutions/issues/new?title=Issue%20on%20page%20%2FREADME.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Blind 75 LeetCode Solutions</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toctree-l1 toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-01. Array Hashing/README">Array &amp; Hashing Solutions - Blind 75 LeetCode Problems</a><ul class="visible nav section-nav flex-column">
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-01. Array Hashing/1. Two Sum">100: Same Tree</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-01. Array Hashing/128. Longest Consecutive Sequence">128. Longest Consecutive Sequence</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-01. Array Hashing/217. Contains Duplicate">217. Contains Duplicate</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-01. Array Hashing/238. Product of Array Except Self">238. Product of Array Except Self</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-01. Array Hashing/242. Valid Anagram">242. Valid Anagram</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-01. Array Hashing/347. Top K Frequent Elements">347. Top K Frequent Elements</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-01. Array Hashing/49. Group Anagrams">49. Group Anagrams</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-01. Array Hashing/659. Encode and Decode Strings">659· Encode and Decode Strings</a></li>
</ul>
</li>
<li class="toctree-l1 toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-02. Two Pointers/README">Two Pointers Problems - Blind 75 LeetCode</a><ul class="visible nav section-nav flex-column">
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-02. Two Pointers/11. Container With Most Water">11. Container With Most Water</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-02. Two Pointers/125. Valid Palindrome">125. Valid Palindrome</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-02. Two Pointers/15. 3Sum">15. 3Sum</a></li>
</ul>
</li>
<li class="toctree-l1 toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-03. Sliding Window/README">Sliding Window Problems - Blind 75 LeetCode</a><ul class="visible nav section-nav flex-column">
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-03. Sliding Window/121. Best Time to Buy and Sell Stock">121. Best Time to Buy and Sell Stock</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-03. Sliding Window/3. Longest Substring Without Repeating Characters">3. Longest Substring Without Repeating Characters</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-03. Sliding Window/424. Longest Repeating Character Replacement">424. Longest Repeating Character Replacement</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-03. Sliding Window/76. Minimum Window Substring">76. Minimum Window Substring</a></li>
</ul>
</li>
<li class="toctree-l1 toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-04. Stack/README">Stack Problems - Blind 75 LeetCode</a><ul class="visible nav section-nav flex-column">
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-04. Stack/20. Valid Parentheses">20. Valid Parentheses</a></li>
</ul>
</li>
<li class="toctree-l1 toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-05. Binary Search/README">Binary search Problems - Blind 75 LeetCode</a><ul class="visible nav section-nav flex-column">
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-05. Binary Search/153. Find Minimum in Rotated Sorted Array">153. Find Minimum in Rotated Sorted Array</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-05. Binary Search/33. Search in Rotated Sorted Array">33. Search in Rotated Sorted Array</a></li>
</ul>
</li>
<li class="toctree-l1 toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-06. Linked List/README">Linked List Problems - Blind 75 LeetCode</a><ul class="visible nav section-nav flex-column">
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-06. Linked List/141. Linked List Cycle">141. Linked List Cycle</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-06. Linked List/143. Reorder List">143. Reorder List</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-06. Linked List/19. Remove Nth Node From End of List">19. Remove Nth Node From End of List</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-06. Linked List/206. Reverse Linked List">206. Reverse Linked List</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-06. Linked List/21. Merge Two Sorted Lists">21. Merge Two Sorted Lists</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-06. Linked List/23. Merge k Sorted Lists">23. Merge k Sorted Lists</a></li>
</ul>
</li>
<li class="toctree-l1 toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-07. Trees/README">Trees Problems - Blind 75 LeetCode</a><ul class="visible nav section-nav flex-column">
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-07. Trees/100. Same Tree">100: Same Tree</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-07. Trees/102. Binary Tree Level Order Traversal">102. Binary Tree Level Order Traversal</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-07. Trees/104. Maximum Depth of Binary Tree">104. Maximum Depth of Binary Tree</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-07. Trees/105. Construct Binary Tree from Preorder and Inorder Traversal">105. Construct Binary Tree from Preorder and Inorder Traversal</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-07. Trees/124. Binary Tree Maximum Path Sum">124. Binary Tree Maximum Path Sum</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-07. Trees/199. Binary Tree Right Side View">199. Binary Tree Right Side View</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-07. Trees/226. Invert Binary Tree">226: Invert Binary Tree</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-07. Trees/230. Kth Smallest Element in a BST">230. Kth Smallest Element in a BST</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-07. Trees/235. Lowest Common Ancestor of a Binary Search Tree">235. Lowest Common Ancestor of a Binary Search Tree</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-07. Trees/297. Serialize and Deserialize Binary Tree">297. Serialize and Deserialize Binary Tree</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-07. Trees/572. Subtree of Another Tree">572: Subtree of Another Tree</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-07. Trees/98. Validate Binary Search Tree">98. Validate Binary Search Tree</a></li>
</ul>
</li>
<li class="toctree-l1 toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-08. Tries/README">Trie Problems - Blind 75 LeetCode</a><ul class="visible nav section-nav flex-column">
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-08. Tries/208. Implement Trie (Prefix Tree)">208. Implement Trie (Prefix Tree)</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-08. Tries/211. Design Add and Search Words Data Structure">211. Design Add and Search Words Data Structure</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-08. Tries/212. Word Search II">212. Word Search II</a></li>
</ul>
</li>
<li class="toctree-l1 toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-09. Heap - Priority Queue/README">Heap / Priority Queue Problems - Blind 75 LeetCode</a><ul class="visible nav section-nav flex-column">
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-09. Heap - Priority Queue/1046. Last Stone Weight">1046. Last Stone Weight</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-09. Heap - Priority Queue/295. Find Median from Data Stream">295. Find Median from Data Stream</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-09. Heap - Priority Queue/703. Kth Largest Element in a Stream">703. Kth Largest Element in a Stream</a></li>
</ul>
</li>
<li class="toctree-l1 toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-10. Backtracking/README">Backtracking Problems - Blind 75 LeetCode</a><ul class="visible nav section-nav flex-column">
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-10. Backtracking/39. Combination Sum">39. Combination Sum</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-10. Backtracking/79. Word Search">79. Word Search</a></li>
</ul>
</li>
<li class="toctree-l1 toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-11. Graphs/README">Graphs Problems - Blind 75 LeetCode</a><ul class="visible nav section-nav flex-column">
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-11. Graphs/133. Clone Graph">133. Clone Graph</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-11. Graphs/178. Graph Valid Tree">178. Graph Valid Tree</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-11. Graphs/200. Number of Islands">200. Number of Islands</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-11. Graphs/207. Course Schedule">207. Course Schedule</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-11. Graphs/3651. Number of Connected Components in an Undirected Graph">3651. Number of Connected Components in an Undirected Graph</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-11. Graphs/417. Pacific Atlantic Water Flow">417. Pacific Atlantic Water Flow</a></li>
</ul>
</li>
<li class="toctree-l1 toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-12. Advanced Graphs/README">Advanced Graphs Problems - Blind 75 LeetCode</a><ul class="visible nav section-nav flex-column">
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-12. Advanced Graphs/892. Alien Dictionary">892. Alien Dictionary</a></li>
</ul>
</li>
<li class="toctree-l1 toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-13. One-D Dynamic Programming/README">1-D Dynamic Programming Problems - Blind 75 LeetCode</a><ul class="visible nav section-nav flex-column">
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-13. One-D Dynamic Programming/70. Climbing Stairs">70. Climbing Stairs</a></li>
</ul>
</li>
<li class="toctree-l1 toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-14. Two-D Dynamic Programming/README">Blind 75 LeetCode Problems</a></li>
<li class="toctree-l1 toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-15. Greedy/README">Blind 75 LeetCode Problems</a></li>
<li class="toctree-l1 toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-16. Intervals/README">Blind 75 LeetCode Problems</a></li>
<li class="toctree-l1 toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-17. Math Geometry/README">Blind 75 LeetCode Problems</a></li>
<li class="toctree-l1 toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-18. Bit Manipulation/README">Blind 75 LeetCode Problems</a></li>
</ul>

            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="blind-75-leetcode-solutions">
<h1>Blind 75 LeetCode Solutions<a class="headerlink" href="#blind-75-leetcode-solutions" title="Permalink to this heading">#</a></h1>
<p><img alt="Blind 75 LeetCode" src="https://img.shields.io/badge/Blind_75_LeetCode-Solutions-blue?labelColor=red" /></p>
<p>This repository contains a curated list of 75 LeetCode problems that are commonly known as the “Blind 75.” These problems cover a wide range of data structures and algorithms and are frequently asked in technical interviews. Solving these problems can help you build a strong foundation in algorithmic problem-solving.</p>
<section id="problem-list">
<h2>Problem List<a class="headerlink" href="#problem-list" title="Permalink to this heading">#</a></h2>
<section id="array-hashing">
<h3>Array &amp; Hashing<a class="headerlink" href="#array-hashing" title="Permalink to this heading">#</a></h3>
<p><img alt="Array &amp; Hashing" src="https://img.shields.io/badge/Array_&amp;_Hashing-Solutions-blue?labelColor=red" /></p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Problem Name</p></th>
<th class="head"><p>Difficulty</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/contains-duplicate/">217. Contains Duplicate</a></p></td>
<td><p>Easy</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/valid-anagram/">242. Valid Anagram</a></p></td>
<td><p>Easy</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/two-sum/">1. Two Sum</a></p></td>
<td><p>Easy</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/group-anagrams/">49. Group Anagrams</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/top-k-frequent-elements/">347. Top K Frequent Elements</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/product-of-array-except-self/">238. Product of Array Except Self</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/encode-and-decode-strings/">659. Encode and Decode Strings</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/longest-consecutive-sequence/">128. Longest Consecutive Sequence</a></p></td>
<td><p>Hard</p></td>
</tr>
</tbody>
</table>
</section>
<section id="two-pointers">
<h3>Two Pointers<a class="headerlink" href="#two-pointers" title="Permalink to this heading">#</a></h3>
<p><img alt="Array &amp; Hashing" src="https://img.shields.io/badge/Two_Pointers-Solutions-blue?labelColor=red" /></p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Problem Name</p></th>
<th class="head"><p>Difficulty</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/valid-palindrome/">125. Valid Palindrome</a></p></td>
<td><p>Easy</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/3sum/">15. 3Sum</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/container-with-most-water/">11. Container With Most Water</a></p></td>
<td><p>Medium</p></td>
</tr>
</tbody>
</table>
</section>
<section id="sliding-window">
<h3>Sliding Window<a class="headerlink" href="#sliding-window" title="Permalink to this heading">#</a></h3>
<p><img alt="Array &amp; Hashing" src="https://img.shields.io/badge/Sliding_Window-Solutions-blue?labelColor=red" /></p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Problem Name</p></th>
<th class="head"><p>Difficulty</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/">121. Best Time to Buy And Sell Stock</a></p></td>
<td><p>Easy</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">3. Longest Substring Without Repeating Characters</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/longest-repeating-character-replacement/">424. Longest Repeating Character Replacement</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/minimum-window-substring/">76. Minimum Window Substring</a></p></td>
<td><p>Hard</p></td>
</tr>
</tbody>
</table>
</section>
<section id="stack">
<h3>Stack<a class="headerlink" href="#stack" title="Permalink to this heading">#</a></h3>
<p><img alt="Array &amp; Hashing" src="https://img.shields.io/badge/Stack-Solutions-blue?labelColor=red" /></p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Problem Name</p></th>
<th class="head"><p>Difficulty</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/valid-parentheses/">20. Valid Parentheses</a></p></td>
<td><p>Easy</p></td>
</tr>
</tbody>
</table>
</section>
<section id="binary-search">
<h3>Binary Search<a class="headerlink" href="#binary-search" title="Permalink to this heading">#</a></h3>
<p><img alt="Array &amp; Hashing" src="https://img.shields.io/badge/Binary_Search-Solutions-blue?labelColor=red" /></p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Problem Name</p></th>
<th class="head"><p>Difficulty</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/">153. Find Minimum In Rotated Sorted Array</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/search-in-rotated-sorted-array/">33. Search In Rotated Sorted Array</a></p></td>
<td><p>Medium</p></td>
</tr>
</tbody>
</table>
</section>
<section id="linked-list">
<h3>Linked List<a class="headerlink" href="#linked-list" title="Permalink to this heading">#</a></h3>
<p><img alt="Array &amp; Hashing" src="https://img.shields.io/badge/Linked_List-Solutions-blue?labelColor=red" /></p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Problem Name</p></th>
<th class="head"><p>Difficulty</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/reverse-linked-list/">206. Reverse Linked List</a></p></td>
<td><p>Easy</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/merge-two-sorted-lists/">21. Merge Two Sorted Lists</a></p></td>
<td><p>Easy</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/reorder-list/">143. Reorder List</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/">19. Remove Nth Node From End of List</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/linked-list-cycle/">141. Linked List Cycle</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/merge-k-sorted-lists/">23. Merge K Sorted Lists</a></p></td>
<td><p>Hard</p></td>
</tr>
</tbody>
</table>
</section>
<section id="trees">
<h3>Trees<a class="headerlink" href="#trees" title="Permalink to this heading">#</a></h3>
<p><img alt="Array &amp; Hashing" src="https://img.shields.io/badge/Trees-Solutions-blue?labelColor=red" /></p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Problem Name</p></th>
<th class="head"><p>Difficulty</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/invert-binary-tree/">226. Invert Binary Tree</a></p></td>
<td><p>Easy</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/maximum-depth-of-binary-tree/">104. Maximum Depth of Binary Tree</a></p></td>
<td><p>Easy</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/same-tree/">100. Same Tree</a></p></td>
<td><p>Easy</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/subtree-of-another-tree/">572. Subtree of Another Tree</a></p></td>
<td><p>Easy</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. Lowest Common Ancestor of a Binary Search Tree</a></p></td>
<td><p>Easy</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/binary-tree-level-order-traversal/">102. Binary Tree Level Order Traversal</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/validate-binary-search-tree/">98. Validate Binary Search Tree</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/">230. Kth Smallest Element In a BST</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. Construct Binary Tree From Preorder And Inorder Traversal</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/binary-tree-maximum-path-sum/">124. Binary Tree Maximum Path Sum</a></p></td>
<td><p>Hard</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/">297. Serialize And Deserialize Binary Tree</a></p></td>
<td><p>Hard</p></td>
</tr>
</tbody>
</table>
</section>
<section id="tries">
<h3>Tries<a class="headerlink" href="#tries" title="Permalink to this heading">#</a></h3>
<p><img alt="Array &amp; Hashing" src="https://img.shields.io/badge/Tries-Solutions-blue?labelColor=red" /></p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Problem Name</p></th>
<th class="head"><p>Difficulty</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/implement-trie-prefix-tree/">208. Implement Trie Prefix Tree</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/design-add-and-search-words-data-structure/">211. Design Add And Search Words Data Structure</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/word-search-ii/">212. Word Search II</a></p></td>
<td><p>Hard</p></td>
</tr>
</tbody>
</table>
</section>
<section id="heap-priority-queue">
<h3>Heap / Priority Queue<a class="headerlink" href="#heap-priority-queue" title="Permalink to this heading">#</a></h3>
<p><img alt="Array &amp; Hashing" src="https://img.shields.io/badge/Heap_/_Priority_Queue-Solutions-blue?labelColor=red" /></p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Problem Name</p></th>
<th class="head"><p>Difficulty</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/find-median-from-data-stream/">295. Find Median From Data Stream</a></p></td>
<td><p>Hard</p></td>
</tr>
</tbody>
</table>
</section>
<section id="backtracking">
<h3>Backtracking<a class="headerlink" href="#backtracking" title="Permalink to this heading">#</a></h3>
<p><img alt="Array &amp; Hashing" src="https://img.shields.io/badge/Backtracking-Solutions-blue?labelColor=red" /></p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Problem Name</p></th>
<th class="head"><p>Difficulty</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/combination-sum/">39. Combination Sum</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/word-search/">79. Word Search</a></p></td>
<td><p>Medium</p></td>
</tr>
</tbody>
</table>
</section>
<section id="graphs">
<h3>Graphs<a class="headerlink" href="#graphs" title="Permalink to this heading">#</a></h3>
<p><img alt="Array &amp; Hashing" src="https://img.shields.io/badge/Graphs-Solutions-blue?labelColor=red" /></p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Problem Name</p></th>
<th class="head"><p>Difficulty</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/number-of-islands/">200. Number of Islands</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/clone-graph/">133. Clone Graph</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/pacific-atlantic-water-flow/">417. Pacific Atlantic Water Flow</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/course-schedule/">207. Course Schedule</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/">323. Number of Connected Components In An Undirected Graph</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/graph-valid-tree/">261. Graph Valid Tree</a></p></td>
<td><p>Medium</p></td>
</tr>
</tbody>
</table>
</section>
<section id="advanced-graphs">
<h3>Advanced Graphs<a class="headerlink" href="#advanced-graphs" title="Permalink to this heading">#</a></h3>
<p><img alt="Array &amp; Hashing" src="https://img.shields.io/badge/Advanced_Graphs-Solutions-blue?labelColor=red" /></p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Problem Name</p></th>
<th class="head"><p>Difficulty</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/alien-dictionary/">269. Alien Dictionary</a></p></td>
<td><p>Hard</p></td>
</tr>
</tbody>
</table>
</section>
<section id="d-dynamic-programming">
<h3>1-D Dynamic Programming<a class="headerlink" href="#d-dynamic-programming" title="Permalink to this heading">#</a></h3>
<p><img alt="Array &amp; Hashing" src="https://img.shields.io/badge/1_D_Dynamic_Programming-Solutions-blue?labelColor=red" /></p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Problem Name</p></th>
<th class="head"><p>Difficulty</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/climbing-stairs/">70. Climbing Stairs</a></p></td>
<td><p>Easy</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/house-robber/">198. House Robber</a></p></td>
<td><p>Easy</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/house-robber-ii/">213. House Robber II</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/longest-palindromic-substring/">5. Longest Palindromic Substring</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/palindromic-substrings/">647. Palindromic Substrings</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/decode-ways/">91. Decode Ways</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/coin-change/">322. Coin Change</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/maximum-product-subarray/">152. Maximum Product Subarray</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/word-break/">139. Word Break</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/longest-increasing-subsequence/">300. Longest Increasing Subsequence</a></p></td>
<td><p>Medium</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id1">
<h3>2-D Dynamic Programming<a class="headerlink" href="#id1" title="Permalink to this heading">#</a></h3>
<p><img alt="Array &amp; Hashing" src="https://img.shields.io/badge/2_D_Dynamic_Programming-Solutions-blue?labelColor=red" /></p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Problem Name</p></th>
<th class="head"><p>Difficulty</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/unique-paths/">62. Unique Paths</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/longest-common-subsequence/">1143. Longest Common Subsequence</a></p></td>
<td><p>Medium</p></td>
</tr>
</tbody>
</table>
</section>
<section id="greedy">
<h3>Greedy<a class="headerlink" href="#greedy" title="Permalink to this heading">#</a></h3>
<p><img alt="Array &amp; Hashing" src="https://img.shields.io/badge/Greedy-Solutions-blue?labelColor=red" /></p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Problem Name</p></th>
<th class="head"><p>Difficulty</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/maximum-subarray/">53. Maximum Subarray</a></p></td>
<td><p>Easy</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/jump-game/">55. Jump Game</a></p></td>
<td><p>Medium</p></td>
</tr>
</tbody>
</table>
</section>
<section id="intervals">
<h3>Intervals<a class="headerlink" href="#intervals" title="Permalink to this heading">#</a></h3>
<p><img alt="Array &amp; Hashing" src="https://img.shields.io/badge/Intervals-Solutions-blue?labelColor=red" /></p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Problem Name</p></th>
<th class="head"><p>Difficulty</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/insert-interval/">57. Insert Interval</a></p></td>
<td><p>Hard</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/merge-intervals/">56. Merge Intervals</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/non-overlapping-intervals/">435. Non Overlapping Intervals</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/meeting-rooms/">252. Meeting Rooms</a></p></td>
<td><p>Easy</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/meeting-rooms-ii/">253. Meeting Rooms II</a></p></td>
<td><p>Medium</p></td>
</tr>
</tbody>
</table>
</section>
<section id="math-geometry">
<h3>Math &amp; Geometry<a class="headerlink" href="#math-geometry" title="Permalink to this heading">#</a></h3>
<p><img alt="Array &amp; Hashing" src="https://img.shields.io/badge/Math_&amp;_Geometry-Solutions-blue?labelColor=red" /></p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Problem Name</p></th>
<th class="head"><p>Difficulty</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/rotate-image/">48. Rotate Image</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/spiral-matrix/">54. Spiral Matrix</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/set-matrix-zeroes/">73. Set Matrix Zeroes</a></p></td>
<td><p>Medium</p></td>
</tr>
</tbody>
</table>
</section>
<section id="bit-manipulation">
<h3>Bit Manipulation<a class="headerlink" href="#bit-manipulation" title="Permalink to this heading">#</a></h3>
<p><img alt="Array &amp; Hashing" src="https://img.shields.io/badge/Bit_Manipulation-Solutions-blue?labelColor=red" /></p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Problem Name</p></th>
<th class="head"><p>Difficulty</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/number-of-1-bits/">191. Number of 1 Bits</a></p></td>
<td><p>Easy</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/counting-bits/">338. Counting Bits</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/reverse-bits/">190. Reverse Bits</a></p></td>
<td><p>Easy</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/missing-number/">268. Missing Number</a></p></td>
<td><p>Easy</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/sum-of-two-integers/">371. Sum of Two Integers</a></p></td>
<td><p>Medium</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="how-to-use">
<h2>How to Use<a class="headerlink" href="#how-to-use" title="Permalink to this heading">#</a></h2>
<ol class="arabic simple">
<li><p>Clone or download this repository to your local machine.</p></li>
</ol>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>git<span class="w"> </span>clone<span class="w"> </span>https://github.com/mohsentabibian/LeetCode-Solutions/Blind-75-LeetCode.git
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li><p>Navigate to the directory of the specific problem you want to solve.</p></li>
</ol>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span><span class="w"> </span>Blind-75-LeetCode/Problem-Directory
</pre></div>
</div>
<ol class="arabic simple" start="3">
<li><p>Open the problem’s directory to find its description, code template, and solution(s).</p></li>
<li><p>Solve the problem using your preferred programming language.</p></li>
<li><p>Check the solution(s) provided in the directory for reference and to compare your solution.</p></li>
</ol>
</section>
<section id="contribute">
<h2>Contribute<a class="headerlink" href="#contribute" title="Permalink to this heading">#</a></h2>
<p>If you have a better solution or want to add more problems to the collection, feel free to contribute. You can create a pull request or open an issue to discuss additions or improvements.</p>
</section>
<section id="resources">
<h2>Resources<a class="headerlink" href="#resources" title="Permalink to this heading">#</a></h2>
<ul class="simple">
<li><p><a class="reference external" href="https://leetcode.com/">LeetCode</a>: The official LeetCode website.</p></li>
<li><p><a class="reference external" href="https://leetcode.com/discuss/">LeetCode Discuss</a>: LeetCode’s discussion forum for each problem. You can find helpful hints and discussions here.</p></li>
</ul>
</section>
<section id="disclaimer">
<h2>Disclaimer<a class="headerlink" href="#disclaimer" title="Permalink to this heading">#</a></h2>
<p>This repository is meant for educational purposes and to help individuals prepare for technical interviews. Please respect LeetCode’s terms of use and guidelines when using this repository.</p>
</section>
<section id="code-of-conduct">
<h2>Code of Conduct<a class="headerlink" href="#code-of-conduct" title="Permalink to this heading">#</a></h2>
<p>We have a <a class="reference internal" href="README.html#document-CODE_OF_CONDUCT"><span class="doc std std-doc">Code of Conduct</span></a> that we expect all contributors to adhere to. By participating in this project, you agree to follow this code.</p>
</section>
<section id="security-policy">
<h2>Security Policy<a class="headerlink" href="#security-policy" title="Permalink to this heading">#</a></h2>
<p>We take security seriously. Please review our <a class="reference internal" href="README.html#document-SECURITY"><span class="doc std std-doc">Security Policy</span></a> for information on reporting security vulnerabilities.</p>
<p>Happy coding!</p>
</section>
<div class="toctree-wrapper compound">
<span id="document-01. Array Hashing/README"></span><section class="tex2jax_ignore mathjax_ignore" id="array-hashing-solutions-blind-75-leetcode-problems">
<h2>Array &amp; Hashing Solutions - Blind 75 LeetCode Problems<a class="headerlink" href="#array-hashing-solutions-blind-75-leetcode-problems" title="Permalink to this heading">#</a></h2>
<p><img alt="Array &amp; Hashing Solutions" src="https://img.shields.io/badge/Array_&amp;_Hashing_Solutions-blue" /><img alt="Blind 75 LeetCode" src="https://img.shields.io/badge/Blind_75_LeetCode-Problems-blue?labelColor=red" /></p>
<p>This repository contains my solutions to Array &amp; Hashing Problems from Blind 75 LeetCode problems. I’ve organized the solutions by categories for easier navigation and reference. Each problem solution is presented in Jupyter Notebook format (<code class="docutils literal notranslate"><span class="pre">.ipynb</span></code>).</p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Problem Name</p></th>
<th class="head"><p>Difficulty</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="https://github.com/mohsentabibian/LeetCode-Solutions/blob/main/01.%20Array%20Hashing/217.%20Contains%20Duplicate.ipynb">217. Contains Duplicate</a></p></td>
<td><p>Easy</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://github.com/mohsentabibian/LeetCode-Solutions/blob/main/01.%20Array%20Hashing/242.%20Valid%20Anagram.ipynb">242. Valid Anagram</a></p></td>
<td><p>Easy</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://github.com/mohsentabibian/LeetCode-Solutions/blob/main/01.%20Array%20Hashing/1.%20Two%20Sum.ipynb">1. Two Sum</a></p></td>
<td><p>Easy</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://github.com/mohsentabibian/LeetCode-Solutions/blob/main/01.%20Array%20Hashing/49.%20Group%20Anagrams.ipynb">49. Group Anagrams</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://github.com/mohsentabibian/LeetCode-Solutions/blob/main/01.%20Array%20Hashing/347.%20Top%20K%20Frequent%20Elements.ipynb">347. Top K Frequent Elements</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://github.com/mohsentabibian/LeetCode-Solutions/blob/main/01.%20Array%20Hashing/238.%20Product%20of%20Array%20Except%20Self.ipynb">238. Product of Array Except Self</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://github.com/mohsentabibian/LeetCode-Solutions/blob/main/01.%20Array%20Hashing/659.%20Encode%20and%20Decode%20Strings.ipynb">659. Encode and Decode Strings</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://github.com/mohsentabibian/LeetCode-Solutions/blob/main/01.%20Array%20Hashing/128.%20Longest%20Consecutive%20Sequence.ipynb">128. Longest Consecutive Sequence</a></p></td>
<td><p>Hard</p></td>
</tr>
</tbody>
</table>
<section id="contribute">
<h3>Contribute<a class="headerlink" href="#contribute" title="Permalink to this heading">#</a></h3>
<p>If you have a better solution or want to add more problems to the collection, feel free to contribute. You can create a pull request or open an issue to discuss additions or improvements.</p>
</section>
<section id="resources">
<h3>Resources<a class="headerlink" href="#resources" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p><a class="reference external" href="https://leetcode.com/">LeetCode</a>: The official LeetCode website.</p></li>
<li><p><a class="reference external" href="https://leetcode.com/discuss/">LeetCode Discuss</a>: LeetCode’s discussion forum for each problem. You can find helpful hints and discussions here.</p></li>
</ul>
<p>Happy coding!</p>
</section>
<div class="toctree-wrapper compound">
<span id="document-01. Array Hashing/1. Two Sum"></span><section class="tex2jax_ignore mathjax_ignore" id="same-tree">
<h3>100: Same Tree<a class="headerlink" href="#same-tree" title="Permalink to this heading">#</a></h3>
<p><strong>Difficulty:</strong> Easy</p>
<p><strong>Link to Problem:</strong> <a class="reference external" href="https://leetcode.com/problems/same-tree/">To see the Same Tree problem on LeetCode, click here!</a></p>
<hr class="docutils" />
<p>Given the roots of two binary trees <code class="docutils literal notranslate"><span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">q</span></code>, write a function to check if they are the same or not.</p>
<p>Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.</p>
<p><strong>Constraints</strong></p>
<ol class="arabic simple">
<li><p>The number of nodes in both trees is in the range <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">100]</span></code>.</p></li>
<li><p><span class="math notranslate nohighlight">\(-10^4\)</span> &lt;= <code class="docutils literal notranslate"><span class="pre">Node.val</span></code> &lt;= <span class="math notranslate nohighlight">\(10^4\)</span></p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Definition for a binary tree node.</span>
<span class="k">class</span> <span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Initialize a TreeNode with a value (val), left child, and right child.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

<span class="k">def</span> <span class="nf">isSameTree</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
    <span class="c1"># Base case: If both p and q are None, the trees are the same.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">p</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">q</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    
    <span class="c1"># Base case: If either p or q is None (but not both), the trees are different.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">p</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">q</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    
    <span class="c1"># Check if the values of the current nodes (p.val and q.val) are equal.</span>
    <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">val</span> <span class="o">!=</span> <span class="n">q</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    
    <span class="c1"># Recursively check the left and right subtrees of p and q.</span>
    <span class="c1"># If both subtrees are the same, the entire trees are the same.</span>
    <span class="k">return</span> <span class="n">isSameTree</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">left</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isSameTree</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>In this code, we define a <code class="docutils literal notranslate"><span class="pre">TreeNode</span></code> class to represent binary tree nodes and a <code class="docutils literal notranslate"><span class="pre">isSameTree</span></code> function to check if two binary trees are the same. The function uses recursive traversal to compare the trees’ structures and values.</p>
<ol class="arabic simple">
<li><p>We start by defining a <code class="docutils literal notranslate"><span class="pre">TreeNode</span></code> class, which represents a node in a binary tree. Each node has a <code class="docutils literal notranslate"><span class="pre">val</span></code> (the node’s value), a <code class="docutils literal notranslate"><span class="pre">left</span></code> child, and a right child. This class will help us create and work with binary trees.</p></li>
<li><p>Next, we define the <code class="docutils literal notranslate"><span class="pre">isSameTree</span></code> function, which checks if two binary trees (<code class="docutils literal notranslate"><span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">q</span></code>) are the same.</p>
<ul class="simple">
<li><p>The base case for the recursion is when both <code class="docutils literal notranslate"><span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">q</span></code> are <code class="docutils literal notranslate"><span class="pre">None</span></code>. In this case, they are considered the same, so we return <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p></li>
<li><p>If either <code class="docutils literal notranslate"><span class="pre">p</span></code> or <code class="docutils literal notranslate"><span class="pre">q</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code> (but not both), they cannot be the same, so we return <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
<li><p>If the values of the current nodes <code class="docutils literal notranslate"><span class="pre">p.val</span></code> and <code class="docutils literal notranslate"><span class="pre">q.val</span></code> are not equal, we return <code class="docutils literal notranslate"><span class="pre">False</span></code> because the trees cannot be the same.</p></li>
<li><p>Finally, we recursively check the left and right subtrees of <code class="docutils literal notranslate"><span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">q</span></code> to see if they are the same.</p></li>
</ul>
</li>
</ol>
<section id="test-cases">
<h4>Test cases<a class="headerlink" href="#test-cases" title="Permalink to this heading">#</a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">### Example 1</span>

<span class="c1">#Input: `p = [1,2,3]`, `q = [1,2,3]`</span>

<span class="n">p1</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="n">q1</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">isSameTree</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">q1</span><span class="p">))</span> 
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">### Example 2</span>

<span class="c1">#Input: `p = [1,2]`, `q = [1,null,2]`</span>

<span class="n">p2</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
<span class="n">q2</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">isSameTree</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span> <span class="n">q2</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>False
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">### Example 3</span>

<span class="c1">#Input: p = [1,2,1], q = [1,1,2]</span>

<span class="n">p3</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="n">q3</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">isSameTree</span><span class="p">(</span><span class="n">p3</span><span class="p">,</span> <span class="n">q3</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>False
</pre></div>
</div>
</div>
</div>
</section>
<section id="time-and-space-complexity-analysis">
<h4>Time and Space Complexity Analysis<a class="headerlink" href="#time-and-space-complexity-analysis" title="Permalink to this heading">#</a></h4>
<p><strong>Time Complexity</strong></p>
<p>The time complexity of the <code class="docutils literal notranslate"><span class="pre">isSameTree</span></code> function can be analyzed as follows:</p>
<p>In the worst case, the function needs to visit every node in both trees once to determine if they are the same.
Since each node is visited exactly once, the time complexity is <span class="math notranslate nohighlight">\(O(n)\)</span>, where <span class="math notranslate nohighlight">\(n\)</span> is the total number of nodes in the input trees.</p>
<p><strong>Space Complexity</strong>
The space complexity of the <code class="docutils literal notranslate"><span class="pre">isSameTree</span></code> function can be analyzed as follows:</p>
<p>The space used by the function’s call stack during recursion is proportional to the maximum depth of the binary trees.
In the worst case, when the trees are completely unbalanced (all nodes form a single branch), the maximum depth will be <span class="math notranslate nohighlight">\(n\)</span>, where <span class="math notranslate nohighlight">\(n\)</span> is the total number of nodes in the input trees.
Therefore, the space complexity is <span class="math notranslate nohighlight">\(O(n)\)</span> due to the recursive call stack.
In addition to the call stack, there is a small constant amount of space used for variables and comparisons within each recursive call, but this space is not significant in terms of the overall space complexity.</p>
<p><strong>In summary:</strong></p>
<ul class="simple">
<li><p>Time Complexity: <span class="math notranslate nohighlight">\(O(n)\)</span> where <span class="math notranslate nohighlight">\(n\)</span> is the total number of nodes in the input trees.</p></li>
<li><p>Space Complexity: <span class="math notranslate nohighlight">\(O(n)\)</span> due to the recursive call stack.</p></li>
</ul>
</section>
</section>
<span id="document-01. Array Hashing/128. Longest Consecutive Sequence"></span><section class="tex2jax_ignore mathjax_ignore" id="longest-consecutive-sequence">
<h3>128. Longest Consecutive Sequence<a class="headerlink" href="#longest-consecutive-sequence" title="Permalink to this heading">#</a></h3>
<p><strong>Difficulty:</strong> Medium</p>
<p><strong>Link to Problem:</strong> <a class="reference external" href="https://leetcode.com/problems/longest-consecutive-sequence/">To see the Longest Consecutive Sequence problem on LeetCode, click here!</a></p>
<hr class="docutils" />
<p>Given an unsorted array of integers <code class="docutils literal notranslate"><span class="pre">nums</span></code>, return <em>the length of the longest consecutive elements sequence.</em></p>
<p>You must write an algorithm that runs in <code class="docutils literal notranslate"><span class="pre">O(n)</span></code> time.</p>
<p><em>Constraints:</em>*</p>
<ul class="simple">
<li><p>0 &lt;= <code class="docutils literal notranslate"><span class="pre">nums.length</span></code> &lt;= <span class="math notranslate nohighlight">\(10^5\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(-10^9\)</span> &lt;= <code class="docutils literal notranslate"><span class="pre">nums[i]</span></code> &lt;= <span class="math notranslate nohighlight">\(10^9\)</span></p></li>
</ul>
<section id="solution">
<h4>Solution:<a class="headerlink" href="#solution" title="Permalink to this heading">#</a></h4>
<p>Here’s a Python function to solve this problem:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">longestConsecutive</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nums</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="n">num_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
    <span class="n">max_length</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">num_set</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">num</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">num_set</span><span class="p">:</span>
            <span class="n">current_num</span> <span class="o">=</span> <span class="n">num</span>
            <span class="n">current_length</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="k">while</span> <span class="n">current_num</span> <span class="o">+</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">num_set</span><span class="p">:</span>
                <span class="n">current_num</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">current_length</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="n">max_length</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_length</span><span class="p">,</span> <span class="n">current_length</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">max_length</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="explanation">
<h4>Explanation:<a class="headerlink" href="#explanation" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p>We start by defining the <code class="docutils literal notranslate"><span class="pre">longestConsecutive</span></code> function that takes the <code class="docutils literal notranslate"><span class="pre">nums</span></code> array as input.</p></li>
<li><p>We check if the <code class="docutils literal notranslate"><span class="pre">nums</span></code> array is empty. If it’s empty, there are no consecutive elements, so we return 0.</p></li>
<li><p>We create a Python set called <code class="docutils literal notranslate"><span class="pre">num_set</span></code> and insert all elements from the <code class="docutils literal notranslate"><span class="pre">nums</span></code> array into it. Using a set allows us to efficiently check for the existence of elements in O(1) time.</p></li>
<li><p>We initialize a variable <code class="docutils literal notranslate"><span class="pre">max_length</span></code> to 0. This variable will keep track of the maximum length of consecutive elements sequence found.</p></li>
<li><p>We iterate through the elements of the <code class="docutils literal notranslate"><span class="pre">num_set</span></code>. For each element <code class="docutils literal notranslate"><span class="pre">num</span></code>, we check if <code class="docutils literal notranslate"><span class="pre">num</span> <span class="pre">-</span> <span class="pre">1</span></code> exists in the <code class="docutils literal notranslate"><span class="pre">num_set</span></code>. If it doesn’t exist, it means <code class="docutils literal notranslate"><span class="pre">num</span></code> is the starting element of a potential consecutive sequence.</p></li>
<li><p>Inside the loop, we initialize two variables: <code class="docutils literal notranslate"><span class="pre">current_num</span></code> to the current element <code class="docutils literal notranslate"><span class="pre">num</span></code> and <code class="docutils literal notranslate"><span class="pre">current_length</span></code> to 1. We start with a length of 1 because <code class="docutils literal notranslate"><span class="pre">num</span></code> itself is part of the sequence.</p></li>
<li><p>We then enter a while loop that continues as long as <code class="docutils literal notranslate"><span class="pre">current_num</span> <span class="pre">+</span> <span class="pre">1</span></code> exists in the <code class="docutils literal notranslate"><span class="pre">num_set</span></code>. This means we are incrementing the consecutive sequence.</p></li>
<li><p>Inside the while loop, we increment <code class="docutils literal notranslate"><span class="pre">current_num</span></code> by 1 and also increment <code class="docutils literal notranslate"><span class="pre">current_length</span></code> by 1 to account for the next consecutive element.</p></li>
<li><p>We compare <code class="docutils literal notranslate"><span class="pre">current_length</span></code> with the <code class="docutils literal notranslate"><span class="pre">max_length</span></code> and update <code class="docutils literal notranslate"><span class="pre">max_length</span></code> if the current sequence is longer.</p></li>
<li><p>After the while loop, we move to the next element in the outer loop and repeat the process.</p></li>
<li><p>Finally, we return the <code class="docutils literal notranslate"><span class="pre">max_length</span></code> as the result, which represents the length of the longest consecutive elements sequence in the <code class="docutils literal notranslate"><span class="pre">nums</span></code> array.</p></li>
</ol>
<p>The key idea here is to use a set to efficiently check for the existence of elements and to iterate through the elements, considering each element as the potential start of a consecutive sequence. By doing this, we can find the longest consecutive sequence in O(n) time complexity, where n is the number of elements in the array.</p>
</section>
<section id="test-cases">
<h4>Test cases<a class="headerlink" href="#test-cases" title="Permalink to this heading">#</a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 1: </span>

<span class="n">nums1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">longestConsecutive</span><span class="p">(</span><span class="n">nums1</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>4
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 2:</span>

<span class="n">nums2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">longestConsecutive</span><span class="p">(</span><span class="n">nums2</span><span class="p">))</span> 
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>9
</pre></div>
</div>
</div>
</div>
</section>
<section id="time-and-space-complexity-analysis">
<h4>Time and Space Complexity Analysis<a class="headerlink" href="#time-and-space-complexity-analysis" title="Permalink to this heading">#</a></h4>
<p>Let’s analyze the time and space complexity of the provided code:</p>
<p><strong>Time Complexity:</strong>
The code is designed to run in O(n) time complexity, where n is the number of elements in the <code class="docutils literal notranslate"><span class="pre">nums</span></code> array. Here’s the breakdown:</p>
<ol class="arabic simple">
<li><p>Constructing the <code class="docutils literal notranslate"><span class="pre">num_set</span></code> by inserting all elements from <code class="docutils literal notranslate"><span class="pre">nums</span></code> into it takes O(n) time because we perform an insertion operation for each element in <code class="docutils literal notranslate"><span class="pre">nums</span></code>.</p></li>
<li><p>The main loop iterates through the elements in <code class="docutils literal notranslate"><span class="pre">num_set</span></code>. In the worst case, each element is visited only once, so the loop itself takes O(n) time.</p></li>
<li><p>Within the loop, we have a while loop that may also take O(n) time in the worst case. However, this while loop is nested inside the main loop, so its overall time complexity remains O(n).</p></li>
</ol>
<p>Therefore, the overall time complexity of the code is O(n).</p>
<p><strong>Space Complexity:</strong>
The space complexity of the code is determined by the space used by the <code class="docutils literal notranslate"><span class="pre">num_set</span></code> and a few additional variables. Here’s the breakdown:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">num_set</span></code> is a set that stores the unique elements from <code class="docutils literal notranslate"><span class="pre">nums</span></code>. In the worst case, it can store all n elements from <code class="docutils literal notranslate"><span class="pre">nums</span></code>, so the space complexity is O(n).</p></li>
<li><p>The additional variables used, such as <code class="docutils literal notranslate"><span class="pre">max_length</span></code>, <code class="docutils literal notranslate"><span class="pre">current_num</span></code>, and <code class="docutils literal notranslate"><span class="pre">current_length</span></code>, have constant space requirements and do not depend on the size of the input array.</p></li>
</ol>
<p>Therefore, the overall space complexity of the code is O(n) due to the space used by the <code class="docutils literal notranslate"><span class="pre">num_set</span></code>.</p>
</section>
<section id="challenging-exercises">
<h4>Challenging Exercises:<a class="headerlink" href="#challenging-exercises" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p>Write an algorithm that not only returns the length of the longest consecutive elements sequence but also returns the actual consecutive sequence itself.</p></li>
<li><p>Extend the problem to allow elements to be considered consecutive if they are within a certain absolute difference (e.g., less than or equal to k) instead of exactly 1. Write an algorithm that finds the longest such sequence and runs in O(n) time.</p></li>
</ol>
</section>
</section>
<span id="document-01. Array Hashing/217. Contains Duplicate"></span><section class="tex2jax_ignore mathjax_ignore" id="contains-duplicate">
<h3>217. Contains Duplicate<a class="headerlink" href="#contains-duplicate" title="Permalink to this heading">#</a></h3>
<p><strong>Difficulty:</strong> Easy</p>
<p><strong>Link to Problem:</strong> <a class="reference external" href="https://leetcode.com/problems/contains-duplicate/">To see the Contains Duplicate problem on LeetCode, click here!</a></p>
<hr class="docutils" />
<p>Given an integer array <code class="docutils literal notranslate"><span class="pre">nums</span></code>, return <code class="docutils literal notranslate"><span class="pre">true</span></code> if any value appears <strong>at least twice</strong> in the array, and return <code class="docutils literal notranslate"><span class="pre">false</span></code> if every element is distinct.</p>
<p><strong>Constraints:</strong></p>
<ul class="simple">
<li><p>1 &lt;= <code class="docutils literal notranslate"><span class="pre">nums.length</span></code> &lt;= <span class="math notranslate nohighlight">\(10^5\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(-10^9\)</span> &lt;= <code class="docutils literal notranslate"><span class="pre">nums[i]</span></code> &lt;= <span class="math notranslate nohighlight">\(10^9\)</span></p></li>
</ul>
<section id="solution">
<h4>Solution:<a class="headerlink" href="#solution" title="Permalink to this heading">#</a></h4>
<p>Here’s a Python function to solve this problem:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">containsDuplicate</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
    <span class="c1"># Create an empty set to store unique elements</span>
    <span class="n">unique_elements</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    
    <span class="c1"># Iterate through the array</span>
    <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
        <span class="c1"># If the element is already in the set, return True</span>
        <span class="k">if</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">unique_elements</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="c1"># Otherwise, add it to the set</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">unique_elements</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
    
    <span class="c1"># If the loop completes without finding duplicates, return False</span>
    <span class="k">return</span> <span class="kc">False</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="explanation">
<h4>Explanation:<a class="headerlink" href="#explanation" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">containsDuplicate</span></code> function takes a single argument, <code class="docutils literal notranslate"><span class="pre">nums</span></code>, which is the input integer array.</p></li>
<li><p>Inside the function, an empty set called <code class="docutils literal notranslate"><span class="pre">unique_elements</span></code> is created. This set will be used to keep track of unique elements in the input array.</p></li>
<li><p>The function then iterates through the input array <code class="docutils literal notranslate"><span class="pre">nums</span></code> using a <code class="docutils literal notranslate"><span class="pre">for</span></code> loop.</p></li>
<li><p>For each element <code class="docutils literal notranslate"><span class="pre">num</span></code> in the array, it checks whether <code class="docutils literal notranslate"><span class="pre">num</span></code> is already in the <code class="docutils literal notranslate"><span class="pre">unique_elements</span></code> set using the <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">num</span> <span class="pre">in</span> <span class="pre">unique_elements:</span></code> condition.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">num</span></code> is already in the set, it means there is a duplicate element in the array, and the function immediately returns <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">num</span></code> is not in the set, it is added to the <code class="docutils literal notranslate"><span class="pre">unique_elements</span></code> set using <code class="docutils literal notranslate"><span class="pre">unique_elements.add(num)</span></code>.</p></li>
<li><p>The loop continues to the next element, and the process repeats.</p></li>
<li><p>If the loop completes without finding any duplicates, it means that all elements in the array are distinct, and the function returns <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
</ol>
<p>The code efficiently utilizes a set data structure to keep track of unique elements while iterating through the array, allowing it to quickly detect duplicate elements. This code meets the problem’s requirements and constraints, as explained earlier.</p>
</section>
<section id="test-cases">
<h4>Test cases<a class="headerlink" href="#test-cases" title="Permalink to this heading">#</a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 1:</span>
<span class="n">nums1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">containsDuplicate</span><span class="p">(</span><span class="n">nums1</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 2</span>
<span class="n">nums2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">containsDuplicate</span><span class="p">(</span><span class="n">nums2</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>False
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 3</span>
<span class="n">nums3</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">containsDuplicate</span><span class="p">(</span><span class="n">nums3</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
</section>
<section id="time-and-space-complexity-analysis">
<h4>Time and Space Complexity Analysis<a class="headerlink" href="#time-and-space-complexity-analysis" title="Permalink to this heading">#</a></h4>
<p>Let’s analyze the time and space complexity of the provided code for the “Contains Duplicate” problem:</p>
<p><strong>Time Complexity:</strong></p>
<p>The primary operation that affects the time complexity is the <code class="docutils literal notranslate"><span class="pre">for</span></code> loop that iterates through the input array <code class="docutils literal notranslate"><span class="pre">nums</span></code>. In the worst case, the loop will iterate through all <code class="docutils literal notranslate"><span class="pre">n</span></code> elements of the array, where <code class="docutils literal notranslate"><span class="pre">n</span></code> is the length of the input array.</p>
<ul class="simple">
<li><p>Iterating through the array: O(n)</p></li>
</ul>
<p>Inside the loop, we perform two operations:</p>
<ol class="arabic simple">
<li><p>Checking whether an element exists in the <code class="docutils literal notranslate"><span class="pre">unique_elements</span></code> set (<code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">num</span> <span class="pre">in</span> <span class="pre">unique_elements</span></code>). This operation has an average time complexity of O(1) for a set.</p></li>
<li><p>Adding an element to the <code class="docutils literal notranslate"><span class="pre">unique_elements</span></code> set (<code class="docutils literal notranslate"><span class="pre">unique_elements.add(num)</span></code>), which also has an average time complexity of O(1) for a set.</p></li>
</ol>
<p>Since these operations are performed for each element in the array, the overall time complexity remains O(n).</p>
<p><strong>Space Complexity:</strong></p>
<p>The space complexity is determined by the additional data structures used in the code, which are the <code class="docutils literal notranslate"><span class="pre">unique_elements</span></code> set.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">unique_elements</span></code> set: This set stores unique elements from the input array. In the worst case, if all elements in the input array are distinct, the set will store all <code class="docutils literal notranslate"><span class="pre">n</span></code> elements.</p></li>
</ul>
<p>Therefore, the space complexity is O(n) because, in the worst case, the set’s size will grow linearly with the input array’s size.</p>
<p><strong>In summary</strong>, the time complexity of the code is O(n), where <code class="docutils literal notranslate"><span class="pre">n</span></code> is the length of the input array, and the space complexity is also O(n) in the worst case. This code is efficient and meets the constraints of the problem.</p>
</section>
<section id="challenging-exercises">
<h4>Challenging Exercises:<a class="headerlink" href="#challenging-exercises" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p><strong>K Duplicates:</strong> Modify the problem to return <code class="docutils literal notranslate"><span class="pre">true</span></code> if there are exactly K duplicate elements in the array. Write a function that takes an additional integer parameter K and returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if there are exactly K duplicates.</p></li>
<li><p><strong>Frequency Count:</strong> Write a function that returns a list of all the elements that appear more than once in the array, along with their frequencies.</p></li>
</ol>
</section>
</section>
<span id="document-01. Array Hashing/238. Product of Array Except Self"></span><section class="tex2jax_ignore mathjax_ignore" id="product-of-array-except-self">
<h3>238. Product of Array Except Self<a class="headerlink" href="#product-of-array-except-self" title="Permalink to this heading">#</a></h3>
<p><strong>Difficulty:</strong> Medium</p>
<p><strong>Link to Problem:</strong> <a class="reference external" href="https://leetcode.com/problems/product-of-array-except-self/">To see the Product of Array Except Self problem on LeetCode, click here!</a></p>
<hr class="docutils" />
<p>Given an integer array <code class="docutils literal notranslate"><span class="pre">nums</span></code>, return <em>an array <code class="docutils literal notranslate"><span class="pre">answer</span></code> such that <code class="docutils literal notranslate"><span class="pre">answer[i]</span></code> is equal to the product of all the elements of <code class="docutils literal notranslate"><span class="pre">nums</span></code> except <code class="docutils literal notranslate"><span class="pre">nums[i]</span></code>.</em></p>
<p>The product of any prefix or suffix of <code class="docutils literal notranslate"><span class="pre">nums</span></code> is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> integer.</p>
<p>You must write an algorithm that runs in O(n) time and without using the division operation.</p>
<p>Constraints:</p>
<ul class="simple">
<li><p>2 &lt;= <code class="docutils literal notranslate"><span class="pre">nums.length</span></code> &lt;= <span class="math notranslate nohighlight">\(10^5\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-30</span> <span class="pre">&lt;=</span> <span class="pre">nums[i]</span> <span class="pre">&lt;=</span> <span class="pre">30</span></code></p></li>
<li><p>The product of any prefix or suffix of <code class="docutils literal notranslate"><span class="pre">nums</span></code> is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> integer.</p></li>
</ul>
<p><strong>Follow-up:</strong> Can you solve the problem in O(1) extra space complexity? (The output array <strong>does not</strong> count as extra space for space complexity analysis.)</p>
<section id="solution">
<h4>Solution:<a class="headerlink" href="#solution" title="Permalink to this heading">#</a></h4>
<p>Here’s a Python function to solve this problem:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">productExceptSelf</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
    
    <span class="c1"># Initialize two arrays to store products to the left and right of each element</span>
    <span class="n">left_products</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
    <span class="n">right_products</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
    
    <span class="c1"># Calculate products to the left of each element</span>
    <span class="n">left_product</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">left_products</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">left_product</span>
        <span class="n">left_product</span> <span class="o">*=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    
    <span class="c1"># Calculate products to the right of each element</span>
    <span class="n">right_product</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">right_products</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">right_product</span>
        <span class="n">right_product</span> <span class="o">*=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    
    <span class="c1"># Calculate the final answer using left and right products</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="p">[</span><span class="n">left_products</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">right_products</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
    
    <span class="k">return</span> <span class="n">answer</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="explanation">
<h4>Explanation:<a class="headerlink" href="#explanation" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">n</span></code> is initialized as the length of the <code class="docutils literal notranslate"><span class="pre">nums</span></code> array.</p></li>
<li><p>Two arrays, <code class="docutils literal notranslate"><span class="pre">left_products</span></code> and <code class="docutils literal notranslate"><span class="pre">right_products</span></code>, are created, each with a length of <code class="docutils literal notranslate"><span class="pre">n</span></code> and filled with ones initially.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">left_product</span></code> is initialized to 1.</p></li>
<li><p>A loop iterates through the <code class="docutils literal notranslate"><span class="pre">nums</span></code> array, from left to right. For each element at index <code class="docutils literal notranslate"><span class="pre">i</span></code>, it stores the product of all elements to its left (including itself) in the <code class="docutils literal notranslate"><span class="pre">left_products</span></code> array and updates <code class="docutils literal notranslate"><span class="pre">left_product</span></code> accordingly.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">right_product</span></code> is initialized to 1.</p></li>
<li><p>Another loop iterates through the <code class="docutils literal notranslate"><span class="pre">nums</span></code> array in reverse order, from right to left. For each element at index <code class="docutils literal notranslate"><span class="pre">i</span></code>, it stores the product of all elements to its right (including itself) in the <code class="docutils literal notranslate"><span class="pre">right_products</span></code> array and updates <code class="docutils literal notranslate"><span class="pre">right_product</span></code>.</p></li>
<li><p>The final <code class="docutils literal notranslate"><span class="pre">answer</span></code> list is constructed by multiplying corresponding elements from the <code class="docutils literal notranslate"><span class="pre">left_products</span></code> and <code class="docutils literal notranslate"><span class="pre">right_products</span></code> arrays for each index <code class="docutils literal notranslate"><span class="pre">i</span></code>.</p></li>
<li><p>The function returns the <code class="docutils literal notranslate"><span class="pre">answer</span></code> list, which contains the desired results.</p></li>
</ol>
<p>Overall, this algorithm efficiently computes the product of all elements except the current element, as required. It runs in O(n) time complexity and uses O(n) extra space, which is within the problem’s constraints.</p>
</section>
<section id="test-cases">
<h4>Test cases<a class="headerlink" href="#test-cases" title="Permalink to this heading">#</a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 1: </span>
<span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="n">result1</span> <span class="o">=</span> <span class="n">productExceptSelf</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[24, 12, 8, 6]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 2:</span>
<span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="n">result2</span> <span class="o">=</span> <span class="n">productExceptSelf</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[0, 0, 9, 0, 0]
</pre></div>
</div>
</div>
</div>
</section>
<section id="time-and-space-complexity-analysis">
<h4>Time and Space Complexity Analysis<a class="headerlink" href="#time-and-space-complexity-analysis" title="Permalink to this heading">#</a></h4>
<p>Let’s analyze the time and space complexity of the provided code:</p>
<p><strong>Time Complexity:</strong></p>
<ol class="arabic simple">
<li><p>The first loop iterates through the <code class="docutils literal notranslate"><span class="pre">nums</span></code> array to calculate the products to the left of each element. This loop runs in O(n) time, where n is the length of the <code class="docutils literal notranslate"><span class="pre">nums</span></code> array.</p></li>
<li><p>The second loop also iterates through the <code class="docutils literal notranslate"><span class="pre">nums</span></code> array in reverse order to calculate the products to the right of each element. This loop also runs in O(n) time.</p></li>
<li><p>The final loop constructs the <code class="docutils literal notranslate"><span class="pre">answer</span></code> list by multiplying elements from the <code class="docutils literal notranslate"><span class="pre">left_products</span></code> and <code class="docutils literal notranslate"><span class="pre">right_products</span></code> arrays. This loop runs in O(n) time.</p></li>
</ol>
<p>Since all the loops are independent and sequential, the overall time complexity is O(n).</p>
<p><strong>Space Complexity:</strong></p>
<ol class="arabic simple">
<li><p>Two additional arrays, <code class="docutils literal notranslate"><span class="pre">left_products</span></code> and <code class="docutils literal notranslate"><span class="pre">right_products</span></code>, are created with a length of <code class="docutils literal notranslate"><span class="pre">n</span></code>, where <code class="docutils literal notranslate"><span class="pre">n</span></code> is the length of the <code class="docutils literal notranslate"><span class="pre">nums</span></code> array. Therefore, these arrays consume O(n) extra space.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">left_product</span></code> and <code class="docutils literal notranslate"><span class="pre">right_product</span></code> variables are used to keep track of the product to the left and right of each element, respectively. These variables occupy O(1) extra space.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">answer</span></code> list, which contains the final results, also consumes O(n) space, but it’s not counted toward the extra space complexity analysis as per the problem’s constraints.</p></li>
</ol>
<p>Overall, the space complexity is O(n) for this solution.</p>
</section>
<section id="challenging-exercises">
<h4>Challenging Exercises:<a class="headerlink" href="#challenging-exercises" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p><strong>Handle Zeros in the Input</strong>: Modify the solution to handle cases where the input array contains zeros. For example, if <code class="docutils literal notranslate"><span class="pre">nums</span> <span class="pre">=</span> <span class="pre">[0,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">0]</span></code>, the output should be <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0]</span></code> because any element multiplied by zero results in zero.</p></li>
<li><p><strong>In-Place Modification</strong>: Attempt to solve the problem with in-place modification of the <code class="docutils literal notranslate"><span class="pre">nums</span></code> array, where the output is stored directly in the input array without using any additional space.</p></li>
</ol>
</section>
</section>
<span id="document-01. Array Hashing/242. Valid Anagram"></span><section class="tex2jax_ignore mathjax_ignore" id="valid-anagram">
<h3>242. Valid Anagram<a class="headerlink" href="#valid-anagram" title="Permalink to this heading">#</a></h3>
<p><strong>Difficulty:</strong> Easy</p>
<p><strong>Link to Problem:</strong> <a class="reference external" href="https://leetcode.com/problems/valid-anagram/">To see the Valid Anagram problem on LeetCode, click here!</a></p>
<hr class="docutils" />
<p>Given two strings <code class="docutils literal notranslate"><span class="pre">s</span></code> and <code class="docutils literal notranslate"><span class="pre">t</span></code>, return <code class="docutils literal notranslate"><span class="pre">true</span></code> if <code class="docutils literal notranslate"><span class="pre">t</span></code> is an anagram of <code class="docutils literal notranslate"><span class="pre">s</span></code>, and <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p>
<p>An <strong>Anagram</strong> is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p>
<p><strong>Constraints:</strong></p>
<ul class="simple">
<li><p>1 &lt;= <code class="docutils literal notranslate"><span class="pre">s.length</span></code>, <code class="docutils literal notranslate"><span class="pre">t.length</span></code> &lt;= <span class="math notranslate nohighlight">\(5 * 10^4\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">s</span></code> and <code class="docutils literal notranslate"><span class="pre">t</span></code> consist of lowercase English letters.</p></li>
</ul>
<p><strong>Follow-up:</strong> What if the inputs contain Unicode characters? How would you adapt your solution to such a case?</p>
<section id="solution">
<h4>Solution:<a class="headerlink" href="#solution" title="Permalink to this heading">#</a></h4>
<p>Here’s a Python function to solve this problem:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">isAnagram</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="c1"># Check if the lengths of s and t are not equal</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># Create dictionaries to store character frequencies for s and t</span>
    <span class="n">countS</span><span class="p">,</span> <span class="n">countT</span> <span class="o">=</span> <span class="p">{},</span> <span class="p">{}</span>

    <span class="c1"># Count character frequencies in s</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>
        <span class="n">countS</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">countS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Count character frequencies in t</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)):</span>
        <span class="n">countT</span><span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">countT</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Check if the character frequencies in s and t are the same</span>
    <span class="k">return</span> <span class="n">countS</span> <span class="o">==</span> <span class="n">countT</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="explanation">
<h4>Explanation:<a class="headerlink" href="#explanation" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p>The code defines a class called <code class="docutils literal notranslate"><span class="pre">Solution</span></code> with a method <code class="docutils literal notranslate"><span class="pre">isAnagram</span></code> that takes two input strings, <code class="docutils literal notranslate"><span class="pre">s</span></code> and <code class="docutils literal notranslate"><span class="pre">t</span></code>, and returns a boolean (<code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code>) based on whether <code class="docutils literal notranslate"><span class="pre">t</span></code> is an anagram of <code class="docutils literal notranslate"><span class="pre">s</span></code>.</p></li>
<li><p>The first check performed in the method is whether the lengths of <code class="docutils literal notranslate"><span class="pre">s</span></code> and <code class="docutils literal notranslate"><span class="pre">t</span></code> are equal. If they are not equal, it immediately returns <code class="docutils literal notranslate"><span class="pre">False</span></code> because strings of different lengths cannot be anagrams of each other.</p></li>
<li><p>Two dictionaries, <code class="docutils literal notranslate"><span class="pre">countS</span></code> and <code class="docutils literal notranslate"><span class="pre">countT</span></code>, are created to store the frequency of characters in <code class="docutils literal notranslate"><span class="pre">s</span></code> and <code class="docutils literal notranslate"><span class="pre">t</span></code>, respectively. These dictionaries will be used to count the occurrences of each character in the strings.</p></li>
<li><p>The code then enters a loop to iterate through each character in string <code class="docutils literal notranslate"><span class="pre">s</span></code> using a <code class="docutils literal notranslate"><span class="pre">for</span></code> loop. Inside the loop, it updates the <code class="docutils literal notranslate"><span class="pre">countS</span></code> dictionary. The line <code class="docutils literal notranslate"><span class="pre">countS[s[i]]</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">+</span> <span class="pre">countS.get(s[i],</span> <span class="pre">0)</span></code> increments the count of character <code class="docutils literal notranslate"><span class="pre">s[i]</span></code> in <code class="docutils literal notranslate"><span class="pre">countS</span></code> by 1. If the character is not already in the dictionary, it initializes the count to 1.</p></li>
<li><p>Similarly, the code iterates through each character in string <code class="docutils literal notranslate"><span class="pre">t</span></code> and updates the <code class="docutils literal notranslate"><span class="pre">countT</span></code> dictionary in the same way.</p></li>
<li><p>After counting the character frequencies in both strings, the code compares the two dictionaries using <code class="docutils literal notranslate"><span class="pre">countS</span> <span class="pre">==</span> <span class="pre">countT</span></code>. If the dictionaries are equal, it means that both strings have the same character frequencies, and therefore, <code class="docutils literal notranslate"><span class="pre">t</span></code> is an anagram of <code class="docutils literal notranslate"><span class="pre">s</span></code>. In this case, the method returns <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p></li>
<li><p>If the dictionaries are not equal, the method returns <code class="docutils literal notranslate"><span class="pre">False</span></code>, indicating that <code class="docutils literal notranslate"><span class="pre">t</span></code> is not an anagram of <code class="docutils literal notranslate"><span class="pre">s</span></code>.</p></li>
</ol>
<p>In summary, this code efficiently determines whether two input strings are anagrams by counting the character frequencies in each string using dictionaries and then comparing these counts. If the character frequencies match, the strings are considered anagrams, and the method returns <code class="docutils literal notranslate"><span class="pre">True</span></code>; otherwise, it returns <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</section>
<section id="test-cases">
<h4>Test cases<a class="headerlink" href="#test-cases" title="Permalink to this heading">#</a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 1:</span>
<span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;anagram&quot;</span>
<span class="n">t</span> <span class="o">=</span> <span class="s2">&quot;nagaram&quot;</span>
<span class="nb">print</span><span class="p">(</span><span class="n">isAnagram</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 2</span>
<span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;rat&quot;</span>
<span class="n">t</span> <span class="o">=</span> <span class="s2">&quot;car&quot;</span>
<span class="nb">print</span><span class="p">(</span><span class="n">isAnagram</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>False
</pre></div>
</div>
</div>
</div>
</section>
<section id="time-and-space-complexity-analysis">
<h4>Time and Space Complexity Analysis<a class="headerlink" href="#time-and-space-complexity-analysis" title="Permalink to this heading">#</a></h4>
<p>Let’s analyze the time and space complexity of the provided code:</p>
<p><strong>Time Complexity:</strong></p>
<ol class="arabic simple">
<li><p>The code first checks whether the lengths of the input strings <code class="docutils literal notranslate"><span class="pre">s</span></code> and <code class="docutils literal notranslate"><span class="pre">t</span></code> are equal, which takes constant time. This check has a time complexity of O(1).</p></li>
<li><p>The code then iterates through both strings, <code class="docutils literal notranslate"><span class="pre">s</span></code> and <code class="docutils literal notranslate"><span class="pre">t</span></code>, once to count the character frequencies. Since both strings have a maximum length of 5 * 10^4, the worst-case scenario is that the code iterates through 5 * 10^4 characters in each string. This results in a linear time complexity of O(n), where n is the length of the longer of the two input strings (<code class="docutils literal notranslate"><span class="pre">s</span></code> or <code class="docutils literal notranslate"><span class="pre">t</span></code>).</p></li>
<li><p>Finally, the code compares the two dictionaries <code class="docutils literal notranslate"><span class="pre">countS</span></code> and <code class="docutils literal notranslate"><span class="pre">countT</span></code> to check if the character frequencies match. This comparison takes O(n) time in the worst case, where n is the length of the longer string.</p></li>
</ol>
<p>Overall, the time complexity of the code is O(n), where n is the length of the longer input string.</p>
<p><strong>Space Complexity:</strong></p>
<ol class="arabic simple">
<li><p>The code uses two dictionaries, <code class="docutils literal notranslate"><span class="pre">countS</span></code> and <code class="docutils literal notranslate"><span class="pre">countT</span></code>, to store the character frequencies of the input strings <code class="docutils literal notranslate"><span class="pre">s</span></code> and <code class="docutils literal notranslate"><span class="pre">t</span></code>. In the worst case, both dictionaries can contain all unique characters from the input strings. Since the input strings can have a maximum length of 5 * 10^4, the space complexity for these dictionaries is O(5 * 10^4) or simply O(n), where n is the length of the longer input string.</p></li>
<li><p>The code uses a few additional variables for bookkeeping, but these variables have constant space requirements and do not depend on the input size. Therefore, they do not significantly impact the overall space complexity.</p></li>
</ol>
<p><strong>In summary</strong>, the space complexity of the code is O(n), where n is the length of the longer input string.</p>
</section>
<section id="challenging-exercises">
<h4>Challenging Exercises:<a class="headerlink" href="#challenging-exercises" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p><strong>Anagram Chains</strong>: Given a list of words, find the longest chain of anagrams, where each word in the chain is an anagram of the previous word. For example, given [“bat”, “tab”, “cat”, “tac”, “dog”], the longest anagram chain is [“bat”, “tab”, “cat”, “tac”].</p></li>
<li><p><strong>Minimum Deletions to Make Anagrams</strong>: Given two strings <code class="docutils literal notranslate"><span class="pre">s</span></code> and <code class="docutils literal notranslate"><span class="pre">t</span></code>, find the minimum number of character deletions required in both strings to make them anagrams of each other. For example, if <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">=</span> <span class="pre">&quot;hello&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">=</span> <span class="pre">&quot;billion&quot;</span></code>, you can remove the characters “heo” from <code class="docutils literal notranslate"><span class="pre">s</span></code> and “billi” from <code class="docutils literal notranslate"><span class="pre">t</span></code> to make them anagrams (“lo” and “on” are left in the two strings).</p></li>
</ol>
</section>
</section>
<span id="document-01. Array Hashing/347. Top K Frequent Elements"></span><section class="tex2jax_ignore mathjax_ignore" id="top-k-frequent-elements">
<h3>347. Top K Frequent Elements<a class="headerlink" href="#top-k-frequent-elements" title="Permalink to this heading">#</a></h3>
<p><strong>Difficulty:</strong> Medium</p>
<p><strong>Link to Problem:</strong> <a class="reference external" href="https://leetcode.com/problems/top-k-frequent-elements/">To see the Top K Frequent Elements problem on LeetCode, click here!</a></p>
<hr class="docutils" />
<p>Given an integer array <code class="docutils literal notranslate"><span class="pre">nums</span></code> and an integer <code class="docutils literal notranslate"><span class="pre">k</span></code>, return the <code class="docutils literal notranslate"><span class="pre">k</span></code> most frequent elements. You may return the answer in <strong>any order</strong>.</p>
<p>Constraints:</p>
<ul class="simple">
<li><p>1 &lt;= <code class="docutils literal notranslate"><span class="pre">nums.length</span></code> &lt;= <span class="math notranslate nohighlight">\(10^5\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(-10^4\)</span> &lt;= <code class="docutils literal notranslate"><span class="pre">nums[i]</span></code> &lt;= <span class="math notranslate nohighlight">\(10^4\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">k</span></code> is in the range <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">the</span> <span class="pre">number</span> <span class="pre">of</span> <span class="pre">unique</span> <span class="pre">elements</span> <span class="pre">in</span> <span class="pre">the</span> <span class="pre">array]</span></code>.</p></li>
<li><p>It is <strong>guaranteed</strong> that the answer is <strong>unique</strong>.</p></li>
</ul>
<p><strong>Follow-up:</strong> Your algorithm’s time complexity must be better than <span class="math notranslate nohighlight">\(O(n\ log\ n)\)</span>, where n is the array’s size.</p>
<section id="solution">
<h4>Solution:<a class="headerlink" href="#solution" title="Permalink to this heading">#</a></h4>
<p>Here’s a Python function to solve this problem:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">topKFrequent</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="c1"># Create a dictionary to store the frequency of each element</span>
    <span class="n">count</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># Create a list of lists to store elements with the same frequency</span>
    <span class="n">frequency</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>

    <span class="c1"># Count the frequency of each element in nums</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
        <span class="n">count</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">count</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Place elements in the freq list according to their frequency</span>
    <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">count</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">frequency</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Traverse freq list from the end (higher frequencies)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">frequency</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">frequency</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">==</span> <span class="n">k</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">res</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="explanation">
<h4>Explanation:<a class="headerlink" href="#explanation" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">def</span> <span class="pre">topKFrequent(nums,</span> <span class="pre">k):</span></code>: This is a function that takes two arguments: <code class="docutils literal notranslate"><span class="pre">nums</span></code>, which is the input array of integers, and <code class="docutils literal notranslate"><span class="pre">k</span></code>, which is the number of most frequent elements to return.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">count</span> <span class="pre">=</span> <span class="pre">{}</span></code>: This dictionary <code class="docutils literal notranslate"><span class="pre">count</span></code> will be used to store the frequency of each unique element in the <code class="docutils literal notranslate"><span class="pre">nums</span></code> array. The keys are elements from the input array, and the values are their corresponding frequencies.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">frequency</span> <span class="pre">=</span> <span class="pre">[[]</span> <span class="pre">for</span> <span class="pre">i</span> <span class="pre">in</span> <span class="pre">range(len(nums)</span> <span class="pre">+</span> <span class="pre">1)]</span></code>: This creates a list of empty lists called <code class="docutils literal notranslate"><span class="pre">frequency</span></code>. It’s used to store elements based on their frequencies, similar to the <code class="docutils literal notranslate"><span class="pre">freq</span></code> list in the previous code. The size of this list is set to be one greater than the length of the input <code class="docutils literal notranslate"><span class="pre">nums</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">n</span> <span class="pre">in</span> <span class="pre">nums:</span></code>: This loop iterates through each element <code class="docutils literal notranslate"><span class="pre">n</span></code> in the input <code class="docutils literal notranslate"><span class="pre">nums</span></code> array.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">count[n]</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">+</span> <span class="pre">count.get(n,</span> <span class="pre">0)</span></code>: This line counts the frequency of each element <code class="docutils literal notranslate"><span class="pre">n</span></code> in the <code class="docutils literal notranslate"><span class="pre">nums</span></code> array. It uses the <code class="docutils literal notranslate"><span class="pre">count.get(n,</span> <span class="pre">0)</span></code> method to retrieve the current count of <code class="docutils literal notranslate"><span class="pre">n</span></code> from the <code class="docutils literal notranslate"><span class="pre">count</span></code> dictionary. If <code class="docutils literal notranslate"><span class="pre">n</span></code> is not in the dictionary, it defaults to 0. It then increments the count by 1.</p></li>
<li><p>After the above loop, the <code class="docutils literal notranslate"><span class="pre">count</span></code> dictionary will contain counts of each unique element in the <code class="docutils literal notranslate"><span class="pre">nums</span></code> array.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">n,</span> <span class="pre">c</span> <span class="pre">in</span> <span class="pre">count.items():</span></code>: This loop iterates through the items (key-value pairs) of the <code class="docutils literal notranslate"><span class="pre">count</span></code> dictionary. <code class="docutils literal notranslate"><span class="pre">n</span></code> represents the element, and <code class="docutils literal notranslate"><span class="pre">c</span></code> represents its frequency.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">frequency[c].append(n)</span></code>: This line places the element <code class="docutils literal notranslate"><span class="pre">n</span></code> into the bucket corresponding to its frequency <code class="docutils literal notranslate"><span class="pre">c</span></code>. Buckets are represented by the <code class="docutils literal notranslate"><span class="pre">frequency</span></code> list. For example, if an element <code class="docutils literal notranslate"><span class="pre">n</span></code> has a frequency of 3, it will be added to <code class="docutils literal notranslate"><span class="pre">frequency[3]</span></code>.</p></li>
<li><p>After this loop, the <code class="docutils literal notranslate"><span class="pre">frequency</span></code> list will contain buckets of elements grouped by their frequencies.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">res</span> <span class="pre">=</span> <span class="pre">[]</span></code>: This list <code class="docutils literal notranslate"><span class="pre">res</span></code> will be used to store the k most frequent elements.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">i</span> <span class="pre">in</span> <span class="pre">range(len(freq)</span> <span class="pre">-</span> <span class="pre">1,</span> <span class="pre">0,</span> <span class="pre">-1):</span></code>: This loop iterates in reverse order through the <code class="docutils literal notranslate"><span class="pre">frequency</span></code> list, starting from the highest frequency and going down to 1. Note that there is a typo here; it should be <code class="docutils literal notranslate"><span class="pre">frequency</span></code> instead of <code class="docutils literal notranslate"><span class="pre">freq</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">n</span> <span class="pre">in</span> <span class="pre">frequency[i]:</span></code>: For each element <code class="docutils literal notranslate"><span class="pre">n</span></code> in the current bucket (i.e., elements with frequency <code class="docutils literal notranslate"><span class="pre">i</span></code>), it appends <code class="docutils literal notranslate"><span class="pre">n</span></code> to the result list <code class="docutils literal notranslate"><span class="pre">res</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">len(res)</span> <span class="pre">==</span> <span class="pre">k:</span></code>: Once <code class="docutils literal notranslate"><span class="pre">res</span></code> contains k elements, the code exits and returns the result.</p></li>
</ol>
<p>The code efficiently finds the k most frequent elements in the input array without using sorting, similar to the previous explanation, with the only difference being the variable names (e.g., <code class="docutils literal notranslate"><span class="pre">frequency</span></code> instead of <code class="docutils literal notranslate"><span class="pre">freq</span></code>).</p>
</section>
<section id="test-cases">
<h4>Test cases<a class="headerlink" href="#test-cases" title="Permalink to this heading">#</a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 1: </span>
<span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="n">k</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">result1</span> <span class="o">=</span> <span class="n">topKFrequent</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[1, 2]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 2:</span>
<span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">k</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">result2</span> <span class="o">=</span> <span class="n">topKFrequent</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[1]
</pre></div>
</div>
</div>
</div>
</section>
<section id="time-and-space-complexity-analysis">
<h4>Time and Space Complexity Analysis<a class="headerlink" href="#time-and-space-complexity-analysis" title="Permalink to this heading">#</a></h4>
<p>Let’s analyze the time and space complexity of the provided code:</p>
<p><strong>Time Complexity:</strong></p>
<ol class="arabic simple">
<li><p>The first loop that counts the frequency of elements by iterating through <code class="docutils literal notranslate"><span class="pre">nums</span></code> has a time complexity of O(n), where n is the number of elements in the input array <code class="docutils literal notranslate"><span class="pre">nums</span></code>.</p></li>
<li><p>The second loop iterates through the keys in the <code class="docutils literal notranslate"><span class="pre">count</span></code> dictionary, which has at most <code class="docutils literal notranslate"><span class="pre">k</span></code> unique elements (as per the constraints). Therefore, the second loop also has a time complexity of O(k).</p></li>
<li><p>The third loop iterates through the <code class="docutils literal notranslate"><span class="pre">frequency</span></code> list, which has a length equal to the maximum frequency of elements in <code class="docutils literal notranslate"><span class="pre">nums</span></code>. In the worst case, this loop can have a time complexity of O(n), where n is the number of elements in <code class="docutils literal notranslate"><span class="pre">nums</span></code>.</p></li>
</ol>
<p>Overall, the dominant factor in terms of time complexity is the loop that iterates through the <code class="docutils literal notranslate"><span class="pre">count</span></code> dictionary. So, the total time complexity of the code is O(n + k).</p>
<p><strong>Space Complexity:</strong></p>
<ol class="arabic simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">count</span></code> dictionary stores the frequency of each unique element in <code class="docutils literal notranslate"><span class="pre">nums</span></code>. In the worst case, it can have at most <code class="docutils literal notranslate"><span class="pre">k</span></code> unique elements, so the space complexity for <code class="docutils literal notranslate"><span class="pre">count</span></code> is O(k).</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">frequency</span></code> list is used to store elements grouped by their frequencies. It has a length of <code class="docutils literal notranslate"><span class="pre">len(nums)</span> <span class="pre">+</span> <span class="pre">1</span></code>, which can be at most 105 based on the constraints. Therefore, the space complexity for <code class="docutils literal notranslate"><span class="pre">frequency</span></code> is O(105).</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">res</span></code> list stores the k most frequent elements, which can be at most <code class="docutils literal notranslate"><span class="pre">k</span></code> elements, so the space complexity for <code class="docutils literal notranslate"><span class="pre">res</span></code> is O(k).</p></li>
</ol>
<p><strong>In summary</strong>, the space complexity is dominated by the <code class="docutils literal notranslate"><span class="pre">count</span></code> dictionary and the <code class="docutils literal notranslate"><span class="pre">frequency</span></code> list, both of which have a space complexity of O(k + 105).</p>
</section>
<section id="challenging-exercises">
<h4>Challenging Exercises:<a class="headerlink" href="#challenging-exercises" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p><strong>Optimized k Most Frequent Elements:</strong> Modify the code to find the k most frequent elements in an array while ensuring that the time complexity is O(n + klogk). You can use a priority queue (heap) to achieve this.</p></li>
<li><p><strong>Handling Duplicate Frequencies:</strong> Extend the code to handle cases where multiple elements have the same frequency and are among the k most frequent elements. Ensure that the output contains exactly k elements.</p></li>
</ol>
</section>
</section>
<span id="document-01. Array Hashing/49. Group Anagrams"></span><section class="tex2jax_ignore mathjax_ignore" id="group-anagrams">
<h3>49. Group Anagrams<a class="headerlink" href="#group-anagrams" title="Permalink to this heading">#</a></h3>
<p><strong>Difficulty:</strong> Medium</p>
<p><strong>Link to Problem:</strong> <a class="reference external" href="https://leetcode.com/problems/group-anagrams/">To see the Group Anagrams problem on LeetCode, click here!</a></p>
<hr class="docutils" />
<p>Given an array of strings <code class="docutils literal notranslate"><span class="pre">strs</span></code>, group <strong>the anagrams</strong> together. You can return the answer in <strong>any order</strong>.</p>
<p>An <strong>Anagram</strong> is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p>
<p><strong>Constraints:</strong></p>
<ul class="simple">
<li><p>1 &lt;= `strs.length &lt;= <span class="math notranslate nohighlight">\(10^4\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">strs[i].length</span> <span class="pre">&lt;=</span> <span class="pre">100</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">strs[i]</span></code> consists of lowercase English letters.</p></li>
</ul>
<section id="solution">
<h4>Solution:<a class="headerlink" href="#solution" title="Permalink to this heading">#</a></h4>
<p>Here’s a Python function to solve this problem:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>


<span class="k">def</span> <span class="nf">groupAnagrams</span><span class="p">(</span><span class="n">strs</span><span class="p">):</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

    <span class="c1"># Iterate through the list of input strings</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strs</span><span class="p">:</span>
        <span class="c1"># Initialize a list to represent character counts for each character (a-z)</span>
        <span class="n">count</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">26</span>

        <span class="c1"># Count the occurrences of each character in the current word</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
            <span class="n">count</span><span class="p">[</span><span class="nb">ord</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">-</span> <span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)]</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Use a tuple of character counts as the key and append the word to the anagram group</span>
        <span class="n">ans</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">count</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

    <span class="c1"># Convert the values (lists of anagrams) to a list of lists</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">ans</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="explanation">
<h4>Explanation:<a class="headerlink" href="#explanation" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p>Inside the method, a <code class="docutils literal notranslate"><span class="pre">defaultdict</span></code> called <code class="docutils literal notranslate"><span class="pre">ans</span></code> is created to store anagram groups. This dictionary will have a list as its default value, meaning that each key in the dictionary will be associated with an empty list by default.</p></li>
<li><p>The code then iterates through the list of input strings, <code class="docutils literal notranslate"><span class="pre">strs</span></code>, using a <code class="docutils literal notranslate"><span class="pre">for</span></code> loop. For each word <code class="docutils literal notranslate"><span class="pre">s</span></code> in <code class="docutils literal notranslate"><span class="pre">strs</span></code>, it performs the following steps:</p>
<ul class="simple">
<li><p>It initializes a list <code class="docutils literal notranslate"><span class="pre">count</span></code> of length 26, where each element represents the count of a specific character (a-z) in the word <code class="docutils literal notranslate"><span class="pre">s</span></code>.</p></li>
<li><p>The code then iterates through the characters of <code class="docutils literal notranslate"><span class="pre">s</span></code>. For each character <code class="docutils literal notranslate"><span class="pre">c</span></code>, it increments the corresponding count in the <code class="docutils literal notranslate"><span class="pre">count</span></code> list based on its ASCII value.</p></li>
<li><p>After counting the characters in <code class="docutils literal notranslate"><span class="pre">s</span></code>, it converts the <code class="docutils literal notranslate"><span class="pre">count</span></code> list into a tuple <code class="docutils literal notranslate"><span class="pre">tuple(count)</span></code> to use as a key for the <code class="docutils literal notranslate"><span class="pre">ans</span></code> dictionary.</p></li>
<li><p>It appends the word <code class="docutils literal notranslate"><span class="pre">s</span></code> to the list associated with the key (tuple) in the <code class="docutils literal notranslate"><span class="pre">ans</span></code> dictionary. This groups all anagrams of the same word together under the same key.</p></li>
</ul>
</li>
<li><p>After processing all words in <code class="docutils literal notranslate"><span class="pre">strs</span></code>, the code converts the values of the <code class="docutils literal notranslate"><span class="pre">ans</span></code> dictionary (which are lists of anagrams) to a list of lists using the <code class="docutils literal notranslate"><span class="pre">list()</span></code> constructor.</p></li>
<li><p>Finally, the code returns the list of anagram groups, which is the result of grouping the anagrams in the input list.</p></li>
</ol>
<p>In summary, the code efficiently groups anagrams together by counting the characters in each word and using a dictionary to store them under the same key. The result is a list of lists, where each inner list represents a group of anagrams.</p>
</section>
<section id="test-cases">
<h4>Test cases<a class="headerlink" href="#test-cases" title="Permalink to this heading">#</a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 1: Group anagrams from a list of words</span>
<span class="n">strs1</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;eat&quot;</span><span class="p">,</span> <span class="s2">&quot;tea&quot;</span><span class="p">,</span> <span class="s2">&quot;tan&quot;</span><span class="p">,</span> <span class="s2">&quot;ate&quot;</span><span class="p">,</span> <span class="s2">&quot;nat&quot;</span><span class="p">,</span> <span class="s2">&quot;bat&quot;</span><span class="p">]</span>
<span class="n">result1</span> <span class="o">=</span> <span class="n">groupAnagrams</span><span class="p">(</span><span class="n">strs1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[&#39;eat&#39;, &#39;tea&#39;, &#39;ate&#39;], [&#39;tan&#39;, &#39;nat&#39;], [&#39;bat&#39;]]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 2: Group anagrams from a list with an empty string</span>
<span class="n">strs2</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">]</span>
<span class="n">result2</span> <span class="o">=</span> <span class="n">groupAnagrams</span><span class="p">(</span><span class="n">strs2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[&#39;&#39;]]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 3: Group anagrams from a list with a single word</span>
<span class="n">strs3</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">]</span>
<span class="n">result3</span> <span class="o">=</span> <span class="n">groupAnagrams</span><span class="p">(</span><span class="n">strs3</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result3</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[&#39;a&#39;]]
</pre></div>
</div>
</div>
</div>
</section>
<section id="time-and-space-complexity-analysis">
<h4>Time and Space Complexity Analysis<a class="headerlink" href="#time-and-space-complexity-analysis" title="Permalink to this heading">#</a></h4>
<p>Let’s analyze the time and space complexity of the <code class="docutils literal notranslate"><span class="pre">groupAnagrams</span></code> method:</p>
<p><strong>Time Complexity:</strong></p>
<ol class="arabic simple">
<li><p>First, we create an instance of the <code class="docutils literal notranslate"><span class="pre">Solution</span></code> class, which is an O(1) operation.</p></li>
<li><p>Inside the <code class="docutils literal notranslate"><span class="pre">groupAnagrams</span></code> method, we iterate through the list of input strings <code class="docutils literal notranslate"><span class="pre">strs</span></code> once in a loop:</p>
<ul class="simple">
<li><p>For each word in <code class="docutils literal notranslate"><span class="pre">strs</span></code>, we perform character counting, which is done in O(K) time, where K is the maximum length of a word in the list.</p></li>
</ul>
</li>
<li><p>The overall time complexity of the method is O(N * K), where N is the number of words in the input list <code class="docutils literal notranslate"><span class="pre">strs</span></code>, and K is the maximum length of a word in <code class="docutils literal notranslate"><span class="pre">strs</span></code>.</p></li>
</ol>
<p><strong>Space Complexity:</strong></p>
<ol class="arabic simple">
<li><p>We use a <code class="docutils literal notranslate"><span class="pre">defaultdict</span></code> called <code class="docutils literal notranslate"><span class="pre">ans</span></code> to store the anagram groups. In the worst case, each word belongs to a distinct anagram group, so the space complexity for <code class="docutils literal notranslate"><span class="pre">ans</span></code> is O(N).</p></li>
<li><p>Within the loop, we create a <code class="docutils literal notranslate"><span class="pre">count</span></code> list of length 26 to store character counts for each word. This is a fixed-size list and does not depend on the input size, so it has a constant space complexity of O(26), which is effectively O(1).</p></li>
<li><p>The space used for other variables is also constant and does not depend on the input size.</p></li>
<li><p>The final result, <code class="docutils literal notranslate"><span class="pre">result</span></code>, is a list of lists that contains the grouped anagrams. In the worst case, each word is a distinct anagram group, so the space complexity for <code class="docutils literal notranslate"><span class="pre">result</span></code> is O(N).</p></li>
<li><p>The overall space complexity of the method is O(N) due to the space used by <code class="docutils literal notranslate"><span class="pre">ans</span></code> and <code class="docutils literal notranslate"><span class="pre">result</span></code>. The space used by the <code class="docutils literal notranslate"><span class="pre">count</span></code> list and other variables is constant and does not significantly affect the overall space complexity.</p></li>
</ol>
<p><strong>In summary,</strong> the time complexity of the <code class="docutils literal notranslate"><span class="pre">groupAnagrams</span></code> method is O(N * K), and the space complexity is O(N), where N is the number of words in the input list <code class="docutils literal notranslate"><span class="pre">strs</span></code>, and K is the maximum length of a word in <code class="docutils literal notranslate"><span class="pre">strs</span></code>.</p>
</section>
<section id="challenging-exercises">
<h4>Challenging Exercises:<a class="headerlink" href="#challenging-exercises" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p><strong>Anagramic Palindromes</strong>: Given a list of strings, find all the groups of anagrams where each group contains words that can be rearranged into a palindrome. For example, in the list [“bat”, “tab”, “act”, “tac”, “dog”], there are two groups: [“bat”, “tab”, “act”, “tac”] and [“dog”].</p></li>
<li><p><strong>Largest Anagram Group</strong>: Given a list of strings, find the largest group of anagrams. Return the list of anagrams in that group. If there are multiple largest groups, return all of them.</p></li>
</ol>
</section>
</section>
<span id="document-01. Array Hashing/659. Encode and Decode Strings"></span><section class="tex2jax_ignore mathjax_ignore" id="encode-and-decode-strings">
<h3>659· Encode and Decode Strings<a class="headerlink" href="#encode-and-decode-strings" title="Permalink to this heading">#</a></h3>
<p><strong>Difficulty:</strong> Medium</p>
<p><strong>Link to Problem:</strong> <a class="reference external" href="https://www.lintcode.com/problem/659/">To see the Encode and Decode Strings problem on LintCode, click here!</a></p>
<hr class="docutils" />
<p>Design an algorithm to encode a list of strings to a string. The encoded string is then sent over the network and is decoded back to the original list of strings.</p>
<p>Please implement <code class="docutils literal notranslate"><span class="pre">encode</span></code> and <code class="docutils literal notranslate"><span class="pre">decode</span></code>.</p>
<section id="solution">
<h4>Solution:<a class="headerlink" href="#solution" title="Permalink to this heading">#</a></h4>
<p>Here’s a Python function to solve this problem:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Codec</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">encode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Encodes a list of strings to a single string.</span>
<span class="sd">        </span>
<span class="sd">        :type strs: List[str]</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">encoded</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strs</span><span class="p">:</span>
            <span class="n">encoded</span> <span class="o">+=</span> <span class="n">s</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="s1">&#39;::&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;:;&#39;</span>
        <span class="k">return</span> <span class="n">encoded</span>

    <span class="k">def</span> <span class="nf">decode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Decodes a single string to a list of strings.</span>
<span class="sd">        </span>
<span class="sd">        :type s: str</span>
<span class="sd">        :rtype: List[str]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">decoded</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;:;&#39;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">end</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">end</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="n">decoded</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">end</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;::&#39;</span><span class="p">,</span> <span class="s1">&#39;:&#39;</span><span class="p">))</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">end</span> <span class="o">+</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="n">decoded</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="explanation">
<h4>Explanation:<a class="headerlink" href="#explanation" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p>We define a class called <code class="docutils literal notranslate"><span class="pre">Codec</span></code> to encapsulate the encoding and decoding operations for a list of strings.</p></li>
<li><p>In the <code class="docutils literal notranslate"><span class="pre">encode</span></code> method, we take a list of strings (<code class="docutils literal notranslate"><span class="pre">strs</span></code>) as input and return a single encoded string. The encoding process involves concatenating the strings together with a delimiter <code class="docutils literal notranslate"><span class="pre">:;</span></code>. We iterate through each string in the input list, replace any occurrence of <code class="docutils literal notranslate"><span class="pre">:</span></code> with <code class="docutils literal notranslate"><span class="pre">::</span></code> (to avoid conflicts with the delimiter), and then append <code class="docutils literal notranslate"><span class="pre">:;</span></code> to indicate the end of that string.</p></li>
<li><p>In the <code class="docutils literal notranslate"><span class="pre">decode</span></code> method, we take an encoded string (<code class="docutils literal notranslate"><span class="pre">s</span></code>) as input and return a list of strings. The decoding process involves splitting the encoded string using the <code class="docutils literal notranslate"><span class="pre">:;</span></code> delimiter. We start from the beginning of the encoded string (<code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">=</span> <span class="pre">0</span></code>) and repeatedly find the next occurrence of <code class="docutils literal notranslate"><span class="pre">:;</span></code>. We extract the substring between the current position (<code class="docutils literal notranslate"><span class="pre">i</span></code>) and the next delimiter (<code class="docutils literal notranslate"><span class="pre">end</span></code>). Before adding it to the result list, we replace any <code class="docutils literal notranslate"><span class="pre">::</span></code> with <code class="docutils literal notranslate"><span class="pre">:</span></code> to revert the encoding. We then update the current position <code class="docutils literal notranslate"><span class="pre">i</span></code> to be after the delimiter, so we can find the next substring in the next iteration.</p></li>
<li><p>Finally, we create an instance of the <code class="docutils literal notranslate"><span class="pre">Codec</span></code> class and test it with two examples:</p></li>
</ol>
<p>By using the <code class="docutils literal notranslate"><span class="pre">:;</span></code> delimiter and handling the <code class="docutils literal notranslate"><span class="pre">::</span></code> escaping, this code can encode and decode lists of strings, preserving the original content even if it contains colons or the delimiter itself.</p>
</section>
<section id="test-cases">
<h4>Test cases<a class="headerlink" href="#test-cases" title="Permalink to this heading">#</a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 1: </span>
<span class="n">codec</span> <span class="o">=</span> <span class="n">Codec</span><span class="p">()</span>

<span class="n">input1</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;lint&quot;</span><span class="p">,</span> <span class="s2">&quot;code&quot;</span><span class="p">,</span> <span class="s2">&quot;love&quot;</span><span class="p">,</span> <span class="s2">&quot;you&quot;</span><span class="p">]</span>
<span class="n">encoded1</span> <span class="o">=</span> <span class="n">codec</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">input1</span><span class="p">)</span>
<span class="n">decoded1</span> <span class="o">=</span> <span class="n">codec</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">encoded1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">decoded1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;lint&#39;, &#39;code&#39;, &#39;love&#39;, &#39;you&#39;]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 2:</span>
<span class="n">codec</span> <span class="o">=</span> <span class="n">Codec</span><span class="p">()</span> 

<span class="n">input2</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;we&quot;</span><span class="p">,</span> <span class="s2">&quot;say&quot;</span><span class="p">,</span> <span class="s2">&quot;:&quot;</span><span class="p">,</span> <span class="s2">&quot;yes&quot;</span><span class="p">]</span>
<span class="n">encoded2</span> <span class="o">=</span> <span class="n">codec</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">input2</span><span class="p">)</span>
<span class="n">decoded2</span> <span class="o">=</span> <span class="n">codec</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">encoded2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">decoded2</span><span class="p">)</span>  
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;we&#39;, &#39;say&#39;, &#39;:&#39;, &#39;yes&#39;]
</pre></div>
</div>
</div>
</div>
</section>
<section id="time-and-space-complexity-analysis">
<h4>Time and Space Complexity Analysis<a class="headerlink" href="#time-and-space-complexity-analysis" title="Permalink to this heading">#</a></h4>
<p>Let’s analyze the time and space complexity of the <code class="docutils literal notranslate"><span class="pre">encode</span></code> and <code class="docutils literal notranslate"><span class="pre">decode</span></code> methods in the provided code.</p>
<p><strong>Encode Method (<code class="docutils literal notranslate"><span class="pre">encode</span></code>):</strong></p>
<ul class="simple">
<li><p>Time Complexity: O(n * m)</p>
<ul>
<li><p>Here, <code class="docutils literal notranslate"><span class="pre">n</span></code> is the number of strings in the input list <code class="docutils literal notranslate"><span class="pre">strs</span></code>, and <code class="docutils literal notranslate"><span class="pre">m</span></code> is the average length of these strings.</p></li>
<li><p>In the worst case, for each string in the list, we iterate over its characters once to replace any colons (<code class="docutils literal notranslate"><span class="pre">:</span></code>) with double colons (<code class="docutils literal notranslate"><span class="pre">::</span></code>) and then append <code class="docutils literal notranslate"><span class="pre">:;</span></code>. This is done for each string in the list.</p></li>
</ul>
</li>
<li><p>Space Complexity: O(n * m)</p>
<ul>
<li><p>The space complexity is also O(n * m) because we build the encoded string by concatenating the modified strings. In the worst case, the encoded string can be of the same length as the original strings.</p></li>
</ul>
</li>
</ul>
<p><strong>Decode Method (<code class="docutils literal notranslate"><span class="pre">decode</span></code>):</strong></p>
<ul class="simple">
<li><p>Time Complexity: O(n * m)</p>
<ul>
<li><p>Similar to the encode method, we iterate through the encoded string in the decode method. In the worst case, we may have to scan each character in the encoded string to find the <code class="docutils literal notranslate"><span class="pre">:;</span></code> delimiter.</p></li>
</ul>
</li>
<li><p>Space Complexity: O(n * m)</p>
<ul>
<li><p>The space complexity of the decode method is also O(n * m) because we build the list of decoded strings, which can be of the same length as the encoded string.</p></li>
</ul>
</li>
</ul>
<p>Overall, both the <code class="docutils literal notranslate"><span class="pre">encode</span></code> and <code class="docutils literal notranslate"><span class="pre">decode</span></code> methods have time and space complexities of O(n * m), where <code class="docutils literal notranslate"><span class="pre">n</span></code> is the number of strings in the input list, and <code class="docutils literal notranslate"><span class="pre">m</span></code> is the average length of these strings. The space complexity arises from storing the encoded or decoded strings, and the time complexity arises from iterating through the characters in these strings.</p>
</section>
<section id="challenging-exercises">
<h4>Challenging Exercises:<a class="headerlink" href="#challenging-exercises" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p><strong>Multiple Delimiters</strong>: Modify the code to allow for multiple delimiters, not just one. Each string could have its own delimiter, and the code should be able to handle this complexity.</p></li>
<li><p><strong>Optimize Encoding</strong>: Modify the <code class="docutils literal notranslate"><span class="pre">encode</span></code> method to achieve a more efficient encoding algorithm. Try to minimize the length of the encoded string while ensuring that it can be correctly decoded.</p></li>
</ol>
</section>
</section>
</div>
</section>
<span id="document-02. Two Pointers/README"></span><section class="tex2jax_ignore mathjax_ignore" id="two-pointers-problems-blind-75-leetcode">
<h2>Two Pointers Problems - Blind 75 LeetCode<a class="headerlink" href="#two-pointers-problems-blind-75-leetcode" title="Permalink to this heading">#</a></h2>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Problem Name</p></th>
<th class="head"><p>Difficulty</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/valid-palindrome/">125. Valid Palindrome</a></p></td>
<td><p>Easy</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/3sum/">15. 3Sum</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/container-with-most-water/">11. Container With Most Water</a></p></td>
<td><p>Medium</p></td>
</tr>
</tbody>
</table>
<section id="contribute">
<h3>Contribute<a class="headerlink" href="#contribute" title="Permalink to this heading">#</a></h3>
<p>If you have a better solution or want to add more problems to the collection, feel free to contribute. You can create a pull request or open an issue to discuss additions or improvements.</p>
</section>
<section id="resources">
<h3>Resources<a class="headerlink" href="#resources" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p><a class="reference external" href="https://leetcode.com/">LeetCode</a>: The official LeetCode website.</p></li>
<li><p><a class="reference external" href="https://leetcode.com/discuss/">LeetCode Discuss</a>: LeetCode’s discussion forum for each problem. You can find helpful hints and discussions here.</p></li>
</ul>
<p>Happy coding!</p>
</section>
<div class="toctree-wrapper compound">
<span id="document-02. Two Pointers/11. Container With Most Water"></span><section class="tex2jax_ignore mathjax_ignore" id="container-with-most-water">
<h3>11. Container With Most Water<a class="headerlink" href="#container-with-most-water" title="Permalink to this heading">#</a></h3>
<p><strong>Difficulty:</strong> Medium</p>
<p><strong>Link to Problem:</strong> <a class="reference external" href="https://leetcode.com/problems/container-with-most-water/">To see the Container With Most Water problem on LeetCode, click here!</a></p>
<hr class="docutils" />
<p>You are given an integer array <code class="docutils literal notranslate"><span class="pre">height</span></code> of length <code class="docutils literal notranslate"><span class="pre">n</span></code>. There are <code class="docutils literal notranslate"><span class="pre">n</span></code> vertical lines drawn such that the two endpoints of the <span class="math notranslate nohighlight">\(i^{th}\)</span> line are <code class="docutils literal notranslate"><span class="pre">(i,</span> <span class="pre">0)</span></code> and <code class="docutils literal notranslate"><span class="pre">(i,</span> <span class="pre">height[i])</span></code>.</p>
<p>Find two lines that together with the x-axis form a container, such that the container contains the most water.</p>
<p>Return <em>the maximum amount of water a container can store.</em></p>
<p><strong>Notice</strong> that you may not slant the container.</p>
<p><strong>Constraints:</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">==</span> <span class="pre">height.length</span></code></p></li>
<li><p>2 &lt;= <code class="docutils literal notranslate"><span class="pre">n</span></code> &lt;= <span class="math notranslate nohighlight">\(10^5\)</span></p></li>
<li><p>0 &lt;= <code class="docutils literal notranslate"><span class="pre">height[i]</span></code> &lt;= <span class="math notranslate nohighlight">\(10^4\)</span></p></li>
</ul>
<section id="solution">
<h4>Solution:<a class="headerlink" href="#solution" title="Permalink to this heading">#</a></h4>
<p>Here’s a Python function to solve this problem:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">maxArea</span><span class="p">(</span><span class="n">height</span><span class="p">):</span>
    <span class="c1"># Initialize the maximum area to 0.</span>
    <span class="n">max_area</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># Initialize two pointers, one at the beginning (left) and one at the end (right) of the array.</span>
    <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">right</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">height</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="c1"># Iterate until the left pointer is less than the right pointer.</span>
    <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">:</span>
        <span class="c1"># Calculate the height of the container, which is the minimum height of the two lines.</span>
        <span class="n">h</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">height</span><span class="p">[</span><span class="n">left</span><span class="p">],</span> <span class="n">height</span><span class="p">[</span><span class="n">right</span><span class="p">])</span>
        <span class="c1"># Calculate the width of the container, which is the distance between the two pointers.</span>
        <span class="n">width</span> <span class="o">=</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span>
        <span class="c1"># Calculate the area of the container using height and width and update max_area if it&#39;s greater.</span>
        <span class="n">max_area</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_area</span><span class="p">,</span> <span class="n">h</span> <span class="o">*</span> <span class="n">width</span><span class="p">)</span>

        <span class="c1"># Move the pointer with the shorter line inward.</span>
        <span class="k">if</span> <span class="n">height</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">[</span><span class="n">right</span><span class="p">]:</span>
            <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">right</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="c1"># Continue this process until left &lt; right, and then return the maximum area.</span>
    <span class="k">return</span> <span class="n">max_area</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="explanation">
<h4>Explanation:<a class="headerlink" href="#explanation" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p>We start with initializing <code class="docutils literal notranslate"><span class="pre">max_area</span></code> to 0, which will store the maximum area of water that can be contained by the lines.</p></li>
<li><p>Two pointers, <code class="docutils literal notranslate"><span class="pre">left</span></code> and <code class="docutils literal notranslate"><span class="pre">right</span></code>, are initialized to the beginning and end of the input <code class="docutils literal notranslate"><span class="pre">height</span></code> array.</p></li>
<li><p>The main loop runs while <code class="docutils literal notranslate"><span class="pre">left</span></code> is less than <code class="docutils literal notranslate"><span class="pre">right</span></code>. This ensures that we are checking all possible pairs of lines in a systematic way.</p></li>
<li><p>Inside the loop:</p>
<ul class="simple">
<li><p>We calculate the height of the container <code class="docutils literal notranslate"><span class="pre">h</span></code> as the minimum of the heights at the <code class="docutils literal notranslate"><span class="pre">left</span></code> and <code class="docutils literal notranslate"><span class="pre">right</span></code> pointers. This represents the height of the water the container can hold.</p></li>
<li><p>We calculate the width of the container as the difference between <code class="docutils literal notranslate"><span class="pre">right</span></code> and <code class="docutils literal notranslate"><span class="pre">left</span></code>. This represents the distance between the two lines.</p></li>
<li><p>We calculate the area of the container using <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">*</span> <span class="pre">width</span></code> and update <code class="docutils literal notranslate"><span class="pre">max_area</span></code> if the calculated area is greater than the current <code class="docutils literal notranslate"><span class="pre">max_area</span></code>.</p></li>
</ul>
</li>
<li><p>After calculating the area and updating <code class="docutils literal notranslate"><span class="pre">max_area</span></code>, we move one of the pointers. We move the pointer pointing to the shorter line inward because moving the pointer pointing to the taller line won’t increase the height and will only decrease the width, which will result in a smaller area.</p></li>
<li><p>We continue this process until <code class="docutils literal notranslate"><span class="pre">left</span></code> is no longer less than <code class="docutils literal notranslate"><span class="pre">right</span></code>, indicating that we have checked all possible pairs of lines.</p></li>
<li><p>Finally, we return the <code class="docutils literal notranslate"><span class="pre">max_area</span></code> which contains the maximum area of water that can be contained by two lines from the input array.</p></li>
</ol>
</section>
<section id="test-cases">
<h4>Test cases<a class="headerlink" href="#test-cases" title="Permalink to this heading">#</a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 1:</span>
<span class="n">height1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>
<span class="n">result1</span> <span class="o">=</span> <span class="n">maxArea</span><span class="p">(</span><span class="n">height1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Output:&quot;</span><span class="p">,</span> <span class="n">result1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Output: 49
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 2</span>
<span class="n">height2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">result2</span> <span class="o">=</span> <span class="n">maxArea</span><span class="p">(</span><span class="n">height2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Output:&quot;</span><span class="p">,</span> <span class="n">result2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Output: 1
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Additional Example</span>
<span class="n">height3</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="n">result3</span> <span class="o">=</span> <span class="n">maxArea</span><span class="p">(</span><span class="n">height3</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Output:&quot;</span><span class="p">,</span> <span class="n">result3</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Output: 45
</pre></div>
</div>
</div>
</div>
</section>
<section id="time-and-space-complexity-analysis">
<h4>Time and Space Complexity Analysis<a class="headerlink" href="#time-and-space-complexity-analysis" title="Permalink to this heading">#</a></h4>
<p>Let’s analyze the time and space complexity of the <code class="docutils literal notranslate"><span class="pre">maxArea</span></code> function:</p>
<p><strong>Time Complexity:</strong>
The function uses a two-pointer approach to find the maximum area of water. In the worst case, both the left and right pointers traverse the entire input array once. Therefore, the time complexity is O(n), where n is the number of elements in the <code class="docutils literal notranslate"><span class="pre">height</span></code> array.</p>
<p><strong>Space Complexity:</strong>
The function uses a constant amount of extra space for variables like <code class="docutils literal notranslate"><span class="pre">max_area</span></code>, <code class="docutils literal notranslate"><span class="pre">left</span></code>, <code class="docutils literal notranslate"><span class="pre">right</span></code>, <code class="docutils literal notranslate"><span class="pre">h</span></code>, and <code class="docutils literal notranslate"><span class="pre">width</span></code>. It does not use any data structures whose space consumption depends on the input size. As a result, the space complexity is O(1), which means it has constant space complexity.</p>
<p><strong>In summary,</strong> the <code class="docutils literal notranslate"><span class="pre">maxArea</span></code> function has a time complexity of O(n) and a space complexity of O(1), making it an efficient algorithm for finding the maximum area of water that can be contained by two lines in the input array.</p>
</section>
<section id="challenging-exercises">
<h4>Challenging Exercises:<a class="headerlink" href="#challenging-exercises" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p><strong>Optimization Challenge:</strong> Modify the maxArea function to not only return the maximum area but also the indices of the two lines that form the container with the maximum area.</p></li>
<li><p><strong>Variant Problem:</strong> Instead of finding the maximum area of water, find the minimum amount of water required to fill all the gaps between the lines. You’ll need to return the total water volume needed.</p></li>
</ol>
</section>
</section>
<span id="document-02. Two Pointers/125. Valid Palindrome"></span><section class="tex2jax_ignore mathjax_ignore" id="valid-palindrome">
<h3>125. Valid Palindrome<a class="headerlink" href="#valid-palindrome" title="Permalink to this heading">#</a></h3>
<p><strong>Difficulty:</strong> Easy</p>
<p><strong>Link to Problem:</strong> <a class="reference external" href="https://leetcode.com/problems/valid-palindrome/">To see the Valid Palindrome problem on LeetCode, click here!</a></p>
<hr class="docutils" />
<p>A phrase is a <strong>palindrome</strong> if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.</p>
<p>Given a string <code class="docutils literal notranslate"><span class="pre">s</span></code>, <em>return <code class="docutils literal notranslate"><span class="pre">true</span></code> if it is a <strong>palindrome</strong>, or <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</em></p>
<p><strong>Constraints:</strong></p>
<ul class="simple">
<li><p>1 &lt;= <code class="docutils literal notranslate"><span class="pre">s.length</span></code> &lt;= <span class="math notranslate nohighlight">\(2*10^5\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">s</span></code> consists only of printable ASCII characters.</p></li>
</ul>
<section id="solution">
<h4>Solution:<a class="headerlink" href="#solution" title="Permalink to this heading">#</a></h4>
<p>Here’s a Python function to solve this problem:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">isPalindrome</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="c1"># Step 1: Convert the input string to lowercase</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    
    <span class="c1"># Step 2: Remove all non-alphanumeric characters from the string</span>
    <span class="n">cleaned_s</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">s</span> <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">isalnum</span><span class="p">())</span>
    
    <span class="c1"># Step 3: Initialize two pointers, one at the beginning and one at the end of the cleaned string</span>
    <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">cleaned_s</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    
    <span class="c1"># Step 4: Compare characters using the two pointers while moving them towards each other</span>
    <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">cleaned_s</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">!=</span> <span class="n">cleaned_s</span><span class="p">[</span><span class="n">right</span><span class="p">]:</span>
            <span class="k">return</span> <span class="kc">False</span>  <span class="c1"># If characters don&#39;t match, it&#39;s not a palindrome</span>
        <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">right</span> <span class="o">-=</span> <span class="mi">1</span>
    
    <span class="c1"># Step 5: If the loop completes without returning False, it&#39;s a palindrome</span>
    <span class="k">return</span> <span class="kc">True</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="explanation">
<h4>Explanation:<a class="headerlink" href="#explanation" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">isPalindrome</span></code> function takes an input string <code class="docutils literal notranslate"><span class="pre">s</span></code>.</p></li>
<li><p>It starts by converting the input string to lowercase using <code class="docutils literal notranslate"><span class="pre">s.lower()</span></code>. This step ensures that the function is case-insensitive when checking for palindromes.</p></li>
<li><p>Next, it removes all non-alphanumeric characters from the string and stores the result in the <code class="docutils literal notranslate"><span class="pre">cleaned_s</span></code> variable. It does this by iterating through each character in the input string and only keeping characters that are alphanumeric (letters and digits). This step removes spaces, punctuation, and other non-alphanumeric characters.</p></li>
<li><p>The function then initializes two pointers, <code class="docutils literal notranslate"><span class="pre">left</span></code> and <code class="docutils literal notranslate"><span class="pre">right</span></code>, which will be used to compare characters from the beginning and end of the cleaned string.</p></li>
<li><p>In a while loop, it compares characters using the two pointers while moving them towards each other. The loop continues until the <code class="docutils literal notranslate"><span class="pre">left</span></code> pointer is less than the <code class="docutils literal notranslate"><span class="pre">right</span></code> pointer. This is done to check all characters in the cleaned string.</p></li>
<li><p>Inside the loop, it checks if the characters at the <code class="docutils literal notranslate"><span class="pre">left</span></code> and <code class="docutils literal notranslate"><span class="pre">right</span></code> pointers don’t match. If they don’t match, it means the input is not a palindrome, so the function returns <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
<li><p>If the characters at the <code class="docutils literal notranslate"><span class="pre">left</span></code> and <code class="docutils literal notranslate"><span class="pre">right</span></code> pointers match, the pointers are moved closer to each other by incrementing <code class="docutils literal notranslate"><span class="pre">left</span></code> and decrementing <code class="docutils literal notranslate"><span class="pre">right</span></code>.</p></li>
<li><p>The loop continues to compare characters until it either finds a mismatch (returning <code class="docutils literal notranslate"><span class="pre">False</span></code>) or until the <code class="docutils literal notranslate"><span class="pre">left</span></code> pointer is greater than or equal to the <code class="docutils literal notranslate"><span class="pre">right</span></code> pointer. If the loop completes without finding a mismatch, it means the input is a palindrome, so the function returns <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p></li>
</ol>
<p>In summary, the code converts the input string to lowercase, removes non-alphanumeric characters, and then uses two pointers to compare characters from the cleaned string’s beginning and end. If all characters match during the comparison, the function returns <code class="docutils literal notranslate"><span class="pre">True</span></code>, indicating that the input is a palindrome. If any characters do not match, it returns <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</section>
<section id="test-cases">
<h4>Test cases<a class="headerlink" href="#test-cases" title="Permalink to this heading">#</a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 1:</span>
<span class="n">input1</span> <span class="o">=</span> <span class="s2">&quot;A man, a plan, a canal: Panama&quot;</span>
<span class="n">output1</span> <span class="o">=</span> <span class="n">isPalindrome</span><span class="p">(</span><span class="n">input1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">output1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 2</span>
<span class="n">input2</span> <span class="o">=</span> <span class="s2">&quot;race a car&quot;</span>
<span class="n">output2</span> <span class="o">=</span> <span class="n">isPalindrome</span><span class="p">(</span><span class="n">input2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">output2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>False
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 3</span>
<span class="n">input3</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
<span class="n">output3</span> <span class="o">=</span> <span class="n">isPalindrome</span><span class="p">(</span><span class="n">input3</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">output3</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
</section>
<section id="time-and-space-complexity-analysis">
<h4>Time and Space Complexity Analysis<a class="headerlink" href="#time-and-space-complexity-analysis" title="Permalink to this heading">#</a></h4>
<p>Let’s analyze the time and space complexity of the <code class="docutils literal notranslate"><span class="pre">isPalindrome</span></code> function that uses two pointers:</p>
<ol class="arabic">
<li><p><strong>Time Complexity:</strong></p>
<ul class="simple">
<li><p>Converting the input string to lowercase using <code class="docutils literal notranslate"><span class="pre">s.lower()</span></code> takes O(n) time, where ‘n’ is the length of the input string.</p></li>
<li><p>Removing non-alphanumeric characters using the list comprehension <code class="docutils literal notranslate"><span class="pre">''.join(c</span> <span class="pre">for</span> <span class="pre">c</span> <span class="pre">in</span> <span class="pre">s</span> <span class="pre">if</span> <span class="pre">c.isalnum())</span></code> also takes O(n) time because it iterates through each character in the string once.</p></li>
<li><p>The comparison of characters using the two pointers (<code class="docutils literal notranslate"><span class="pre">left</span></code> and <code class="docutils literal notranslate"><span class="pre">right</span></code>) is done in a loop that runs until <code class="docutils literal notranslate"><span class="pre">left</span></code> is less than <code class="docutils literal notranslate"><span class="pre">right</span></code>. In the worst case, the loop iterates through half of the string, so it takes O(n/2) time, which is still considered O(n).</p></li>
</ul>
<p>Therefore, the overall time complexity of the <code class="docutils literal notranslate"><span class="pre">isPalindrome</span></code> function is O(n), where ‘n’ is the length of the input string.</p>
</li>
<li><p><strong>Space Complexity:</strong></p>
<ul class="simple">
<li><p>The space complexity is primarily determined by the additional string <code class="docutils literal notranslate"><span class="pre">cleaned_s</span></code> created to store the cleaned version of the input string. In the worst case, if all characters in the input string are alphanumeric, this cleaned string can be as large as the original input string.</p></li>
<li><p>Additionally, the function uses two pointers, <code class="docutils literal notranslate"><span class="pre">left</span></code> and <code class="docutils literal notranslate"><span class="pre">right</span></code>, which consume constant space and do not depend on the size of the input.</p></li>
</ul>
</li>
</ol>
<p><strong>In summary,</strong> the overall space complexity of the <code class="docutils literal notranslate"><span class="pre">isPalindrome</span></code> function is O(n) in the worst case, where ‘n’ is the length of the input string. The space complexity is dominated by the space required for <code class="docutils literal notranslate"><span class="pre">cleaned_s</span></code>.</p>
</section>
<section id="challenging-exercises">
<h4>Challenging Exercises:<a class="headerlink" href="#challenging-exercises" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p><strong>Longest Palindromic Substring:</strong> Given a string <code class="docutils literal notranslate"><span class="pre">s</span></code>, find and return the longest palindromic substring within <code class="docutils literal notranslate"><span class="pre">s</span></code>. For example, if <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">=</span> <span class="pre">&quot;babad&quot;</span></code>, the function should return <code class="docutils literal notranslate"><span class="pre">&quot;bab&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;aba&quot;</span></code>.</p></li>
<li><p><strong>Palindrome with Limited Characters:</strong> Given a string <code class="docutils literal notranslate"><span class="pre">s</span></code> and a list of characters <code class="docutils literal notranslate"><span class="pre">allowed_chars</span></code>, check if <code class="docutils literal notranslate"><span class="pre">s</span></code> is a palindrome considering only the characters from <code class="docutils literal notranslate"><span class="pre">allowed_chars</span></code>. Ignore all other characters. For example, if <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">=</span> <span class="pre">&quot;A</span> <span class="pre">man,</span> <span class="pre">a</span> <span class="pre">plan,</span> <span class="pre">a</span> <span class="pre">canal:</span> <span class="pre">Panama&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">allowed_chars</span> <span class="pre">=</span> <span class="pre">['a',</span> <span class="pre">'m',</span> <span class="pre">'n',</span> <span class="pre">'p']</span></code>, the function should return <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p></li>
</ol>
</section>
</section>
<span id="document-02. Two Pointers/15. 3Sum"></span><section class="tex2jax_ignore mathjax_ignore" id="sum">
<h3>15. 3Sum<a class="headerlink" href="#sum" title="Permalink to this heading">#</a></h3>
<p><strong>Difficulty:</strong> Medium</p>
<p><strong>Link to Problem:</strong> <a class="reference external" href="https://leetcode.com/problems/3sum/">To see the 3Sum problem on LeetCode, click here!</a></p>
<hr class="docutils" />
<p>Given an integer array nums, <em>return all the triplets <code class="docutils literal notranslate"><span class="pre">[nums[i],</span> <span class="pre">nums[j],</span> <span class="pre">nums[k]]</span></code> such that <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">!=</span> <span class="pre">j</span></code>, <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">!=</span> <span class="pre">k</span></code>, and <code class="docutils literal notranslate"><span class="pre">j</span> <span class="pre">!=</span> <span class="pre">k</span></code>, and <code class="docutils literal notranslate"><span class="pre">nums[i]</span> <span class="pre">+</span> <span class="pre">nums[j]</span> <span class="pre">+</span> <span class="pre">nums[k]</span> <span class="pre">==</span> <span class="pre">0</span></code>.</em></p>
<p><strong>Notice</strong> that the solution set must not contain duplicate triplets.</p>
<p><strong>Constraints:</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">&lt;=</span> <span class="pre">nums.length</span> <span class="pre">&lt;=</span> <span class="pre">3000</span></code></p></li>
<li><p><span class="math notranslate nohighlight">\(-10^5\)</span> &lt;= <code class="docutils literal notranslate"><span class="pre">nums[i]</span></code> &lt;= <span class="math notranslate nohighlight">\(10^5\)</span></p></li>
</ul>
<section id="solution">
<h4>Solution:<a class="headerlink" href="#solution" title="Permalink to this heading">#</a></h4>
<p>Here’s a Python function to solve this problem:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">threeSum</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
    <span class="c1"># Sort the input array in ascending order</span>
    <span class="n">nums</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="n">triplets</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">):</span>
        <span class="c1"># Skip duplicates to avoid duplicate triplets</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="k">continue</span>
        
        <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        
        <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">:</span>
            <span class="c1"># Calculate the total sum of the current triplet</span>
            <span class="n">total</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span>
            
            <span class="k">if</span> <span class="n">total</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># If the total is zero, we found a valid triplet</span>
                <span class="n">triplets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]])</span>
                
                <span class="c1"># Skip duplicates of left and right pointers</span>
                <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                    <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
                    <span class="n">right</span> <span class="o">-=</span> <span class="mi">1</span>
                
                <span class="c1"># Move the pointers to the next unique elements</span>
                <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">right</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">total</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># If the total is negative, we need to increase the sum by moving the left pointer to the right</span>
                <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># If the total is positive, we need to decrease the sum by moving the right pointer to the left</span>
                <span class="n">right</span> <span class="o">-=</span> <span class="mi">1</span>
    
    <span class="k">return</span> <span class="n">triplets</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="explanation">
<h4>Explanation:<a class="headerlink" href="#explanation" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p>It starts by sorting the input array <code class="docutils literal notranslate"><span class="pre">nums</span></code> in ascending order. Sorting helps in efficiently finding triplets that sum up to zero.</p></li>
<li><p>It initializes an empty list <code class="docutils literal notranslate"><span class="pre">triplets</span></code> to store the unique triplets that meet the given conditions.</p></li>
<li><p>The code then iterates through the <code class="docutils literal notranslate"><span class="pre">nums</span></code> array using a loop with index <code class="docutils literal notranslate"><span class="pre">i</span></code>. This loop will consider each element of the array as a potential starting point for a triplet.</p></li>
<li><p>Inside the loop, it checks for duplicates and skips them. This is done to ensure that the solution set does not contain duplicate triplets. If <code class="docutils literal notranslate"><span class="pre">nums[i]</span></code> is the same as the previous element <code class="docutils literal notranslate"><span class="pre">nums[i-1]</span></code>, it continues to the next iteration of the loop.</p></li>
<li><p>Two pointers, <code class="docutils literal notranslate"><span class="pre">left</span></code> and <code class="docutils literal notranslate"><span class="pre">right</span></code>, are initialized. <code class="docutils literal notranslate"><span class="pre">left</span></code> starts just after the current element <code class="docutils literal notranslate"><span class="pre">nums[i]</span></code>, and <code class="docutils literal notranslate"><span class="pre">right</span></code> starts at the end of the array.</p></li>
<li><p>The code enters another loop with <code class="docutils literal notranslate"><span class="pre">left</span></code> and <code class="docutils literal notranslate"><span class="pre">right</span></code> pointers, trying to find a triplet that sums up to zero.</p></li>
<li><p>It calculates the <code class="docutils literal notranslate"><span class="pre">total</span></code> sum of the current triplet as <code class="docutils literal notranslate"><span class="pre">nums[i]</span> <span class="pre">+</span> <span class="pre">nums[left]</span> <span class="pre">+</span> <span class="pre">nums[right]</span></code>.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">total</span></code> is zero, it means a valid triplet is found, so it appends <code class="docutils literal notranslate"><span class="pre">[nums[i],</span> <span class="pre">nums[left],</span> <span class="pre">nums[right]]</span></code> to the <code class="docutils literal notranslate"><span class="pre">triplets</span></code> list. Then, it moves both the <code class="docutils literal notranslate"><span class="pre">left</span></code> and <code class="docutils literal notranslate"><span class="pre">right</span></code> pointers to their next unique elements while skipping duplicates.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">total</span></code> is less than zero, it means the sum is negative, so it increments the <code class="docutils literal notranslate"><span class="pre">left</span></code> pointer to move towards a larger sum.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">total</span></code> is greater than zero, it means the sum is positive, so it decrements the <code class="docutils literal notranslate"><span class="pre">right</span></code> pointer to move towards a smaller sum.</p></li>
<li><p>This process continues until all possible triplets have been considered.</p></li>
<li><p>Finally, the function returns the <code class="docutils literal notranslate"><span class="pre">triplets</span></code> list, which contains all the unique triplets that sum up to zero in the sorted <code class="docutils literal notranslate"><span class="pre">nums</span></code> array.</p></li>
</ol>
</section>
<section id="test-cases">
<h4>Test cases<a class="headerlink" href="#test-cases" title="Permalink to this heading">#</a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 1:</span>
<span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">]</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">threeSum</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[-1, -1, 2], [-1, 0, 1]]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 2</span>
<span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">threeSum</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 3</span>
<span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">threeSum</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[0, 0, 0]]
</pre></div>
</div>
</div>
</div>
</section>
<section id="time-and-space-complexity-analysis">
<h4>Time and Space Complexity Analysis<a class="headerlink" href="#time-and-space-complexity-analysis" title="Permalink to this heading">#</a></h4>
<p>Let’s analyze the time and space complexity of the <code class="docutils literal notranslate"><span class="pre">threeSum</span></code> function:</p>
<p><strong>Time Complexity:</strong></p>
<ol class="arabic simple">
<li><p>Sorting the input array <code class="docutils literal notranslate"><span class="pre">nums</span></code> takes O(n log n) time, where n is the length of the array.</p></li>
<li><p>The outer loop runs for each element of the array, so it iterates O(n) times.</p></li>
<li><p>Inside the outer loop, we have a while loop with two pointers (<code class="docutils literal notranslate"><span class="pre">left</span></code> and <code class="docutils literal notranslate"><span class="pre">right</span></code>). In the worst case, the while loop can iterate O(n) times (when all elements are unique).</p></li>
<li><p>Inside the while loop, we have constant time operations (additions, comparisons, and list appends).</p></li>
</ol>
<p>Overall, the time complexity of the <code class="docutils literal notranslate"><span class="pre">threeSum</span></code> function is dominated by the sorting step, so it is O(n log n) due to the sorting. The other operations inside the loops contribute linearly but are dominated by the sorting step.</p>
<p><strong>Space Complexity:</strong></p>
<ol class="arabic simple">
<li><p>The space used by the <code class="docutils literal notranslate"><span class="pre">triplets</span></code> list to store the output triplets is O(k), where k is the number of unique triplets that sum up to zero. In the worst case, this can be O(n^2/3) because there can be roughly O(n^2) possible triplets, and many of them may sum up to zero.</p></li>
<li><p>Other than the <code class="docutils literal notranslate"><span class="pre">triplets</span></code> list, the function uses only a constant amount of additional space for variables like <code class="docutils literal notranslate"><span class="pre">i</span></code>, <code class="docutils literal notranslate"><span class="pre">left</span></code>, <code class="docutils literal notranslate"><span class="pre">right</span></code>, and <code class="docutils literal notranslate"><span class="pre">total</span></code>.</p></li>
</ol>
<p>Overall, the space complexity of the <code class="docutils literal notranslate"><span class="pre">threeSum</span></code> function is O(k), where k is the number of unique triplets that meet the criteria. It’s important to note that the space complexity does not depend on the size of the input array but rather on the number of valid triplets found.</p>
<p><strong>In summary:</strong></p>
<ul class="simple">
<li><p>Time Complexity: O(n log n) due to sorting (dominant factor) and O(n^2) in the worst case for the nested loops.</p></li>
<li><p>Space Complexity: O(k) for storing the output triplets, where k is the number of unique triplets that meet the criteria.</p></li>
</ul>
</section>
<section id="challenging-exercises">
<h4>Challenging Exercises:<a class="headerlink" href="#challenging-exercises" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p><strong>K-Sum Problem:</strong> Generalize the problem to the K-Sum problem, where instead of finding triplets that sum to zero, you need to find K elements that sum to a target value. Implement a function for this generalization.</p></li>
<li><p><strong>Count the Number of Unique Triplets:</strong> Modify the algorithm to count the number of unique triplets that satisfy the conditions instead of returning the triplets themselves. This will require some modifications to handle duplicates efficiently.</p></li>
</ol>
</section>
</section>
</div>
</section>
<span id="document-03. Sliding Window/README"></span><section class="tex2jax_ignore mathjax_ignore" id="sliding-window-problems-blind-75-leetcode">
<h2>Sliding Window Problems - Blind 75 LeetCode<a class="headerlink" href="#sliding-window-problems-blind-75-leetcode" title="Permalink to this heading">#</a></h2>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Problem Name</p></th>
<th class="head"><p>Difficulty</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/">121. Best Time to Buy And Sell Stock</a></p></td>
<td><p>Easy</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">3. Longest Substring Without Repeating Characters</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/longest-repeating-character-replacement/">424. Longest Repeating Character Replacement</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/minimum-window-substring/">76. Minimum Window Substring</a></p></td>
<td><p>Hard</p></td>
</tr>
</tbody>
</table>
<section id="contribute">
<h3>Contribute<a class="headerlink" href="#contribute" title="Permalink to this heading">#</a></h3>
<p>If you have a better solution or want to add more problems to the collection, feel free to contribute. You can create a pull request or open an issue to discuss additions or improvements.</p>
</section>
<section id="resources">
<h3>Resources<a class="headerlink" href="#resources" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p><a class="reference external" href="https://leetcode.com/">LeetCode</a>: The official LeetCode website.</p></li>
<li><p><a class="reference external" href="https://leetcode.com/discuss/">LeetCode Discuss</a>: LeetCode’s discussion forum for each problem. You can find helpful hints and discussions here.</p></li>
</ul>
<p>Happy coding!</p>
</section>
<div class="toctree-wrapper compound">
<span id="document-03. Sliding Window/121. Best Time to Buy and Sell Stock"></span><section class="tex2jax_ignore mathjax_ignore" id="best-time-to-buy-and-sell-stock">
<h3>121. Best Time to Buy and Sell Stock<a class="headerlink" href="#best-time-to-buy-and-sell-stock" title="Permalink to this heading">#</a></h3>
<p><strong>Difficulty:</strong> Easy</p>
<p><strong>Link to Problem:</strong> <a class="reference external" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/">To see the Best Time to Buy and Sell Stock problem on LeetCode, click here!</a></p>
<hr class="docutils" />
<p>You are given an array <code class="docutils literal notranslate"><span class="pre">prices</span></code> where <code class="docutils literal notranslate"><span class="pre">prices[i]</span></code> is the price of a given stock on the <span class="math notranslate nohighlight">\(i^{th}\)</span> day.</p>
<p>You want to maximize your profit by choosing a <strong>single day</strong> to buy one stock and choosing a <strong>different day in the future</strong> to sell that stock.</p>
<p><em>Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return <code class="docutils literal notranslate"><span class="pre">0</span></code>.</em></p>
<p><strong>Constraints:</strong></p>
<ul class="simple">
<li><p>1 &lt;= <code class="docutils literal notranslate"><span class="pre">prices.length</span></code> &lt;= <span class="math notranslate nohighlight">\(10^5\)</span></p></li>
<li><p>0 &lt;= <code class="docutils literal notranslate"><span class="pre">prices[i]</span></code> &lt;= <span class="math notranslate nohighlight">\(10^4\)</span></p></li>
</ul>
<section id="solution">
<h4>Solution:<a class="headerlink" href="#solution" title="Permalink to this heading">#</a></h4>
<p>Here’s a Python function to solve this problem:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">maxProfit</span><span class="p">(</span><span class="n">prices</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">prices</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    
    <span class="n">min_price</span> <span class="o">=</span> <span class="n">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">max_profit</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="k">for</span> <span class="n">price</span> <span class="ow">in</span> <span class="n">prices</span><span class="p">:</span>
        <span class="c1"># Update the minimum price if a lower price is encountered</span>
        <span class="n">min_price</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">min_price</span><span class="p">,</span> <span class="n">price</span><span class="p">)</span>
        <span class="c1"># Calculate the profit if selling at the current price</span>
        <span class="n">max_profit</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_profit</span><span class="p">,</span> <span class="n">price</span> <span class="o">-</span> <span class="n">min_price</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">max_profit</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="explanation">
<h4>Explanation:<a class="headerlink" href="#explanation" title="Permalink to this heading">#</a></h4>
<ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">maxProfit</span></code> function takes a single argument, <code class="docutils literal notranslate"><span class="pre">prices</span></code>, which is a list of stock prices.</p></li>
<li><p>The first line of the function checks if the <code class="docutils literal notranslate"><span class="pre">prices</span></code> list is empty. If it’s empty, there are no prices to analyze, so the function returns 0 (no profit can be made).</p></li>
<li><p>Then, we initialize two variables:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">min_price</span></code>: This variable will keep track of the minimum price seen so far. We initialize it with the price of the first day in the list (<code class="docutils literal notranslate"><span class="pre">prices[0]</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">max_profit</span></code>: This variable will keep track of the maximum profit we can achieve. We initialize it to 0 because initially, we haven’t made any profit.</p></li>
</ul>
</li>
<li><p>We start iterating through the <code class="docutils literal notranslate"><span class="pre">prices</span></code> list, where <code class="docutils literal notranslate"><span class="pre">price</span></code> represents the stock price for the current day.</p></li>
<li><p>In each iteration, we check if the current <code class="docutils literal notranslate"><span class="pre">price</span></code> is lower than the <code class="docutils literal notranslate"><span class="pre">min_price</span></code> we’ve seen so far. If it is, we update <code class="docutils literal notranslate"><span class="pre">min_price</span></code> to the current <code class="docutils literal notranslate"><span class="pre">price</span></code>. This is because we want to buy the stock at the lowest possible price.</p></li>
<li><p>Next, we calculate the profit we would make if we sold the stock at the current <code class="docutils literal notranslate"><span class="pre">price</span></code> (assuming we bought it at <code class="docutils literal notranslate"><span class="pre">min_price</span></code>). We do this by subtracting <code class="docutils literal notranslate"><span class="pre">min_price</span></code> from the current <code class="docutils literal notranslate"><span class="pre">price</span></code>. This represents the profit for the current day.</p></li>
<li><p>We also use the <code class="docutils literal notranslate"><span class="pre">max</span></code> function to keep track of the maximum profit seen so far. If the profit calculated for the current day is greater than the <code class="docutils literal notranslate"><span class="pre">max_profit</span></code> we’ve seen previously, we update <code class="docutils literal notranslate"><span class="pre">max_profit</span></code> with this higher value.</p></li>
<li><p>Finally, after iterating through all the days in the <code class="docutils literal notranslate"><span class="pre">prices</span></code> list, we return <code class="docutils literal notranslate"><span class="pre">max_profit</span></code>, which represents the maximum profit that can be achieved by buying and selling a single stock.</p></li>
</ul>
</section>
<section id="test-cases">
<h4>Test cases<a class="headerlink" href="#test-cases" title="Permalink to this heading">#</a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 1:</span>
<span class="n">prices1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">maxProfit</span><span class="p">(</span><span class="n">prices1</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>5
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 2:</span>
<span class="n">prices2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">maxProfit</span><span class="p">(</span><span class="n">prices2</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0
</pre></div>
</div>
</div>
</div>
</section>
<section id="time-and-space-complexity-analysis">
<h4>Time and Space Complexity Analysis<a class="headerlink" href="#time-and-space-complexity-analysis" title="Permalink to this heading">#</a></h4>
<p>Let’s analyze the time and space complexity of the provided code:</p>
<p><strong>Time Complexity:</strong></p>
<ul class="simple">
<li><p>The code iterates through the <code class="docutils literal notranslate"><span class="pre">prices</span></code> array once, examining each price exactly once.</p></li>
<li><p>Within the loop, there are constant-time operations such as comparisons, additions, and subtractions.</p></li>
<li><p>Therefore, the time complexity of this code is O(n), where n is the length of the <code class="docutils literal notranslate"><span class="pre">prices</span></code> array. It performs a linear number of operations relative to the size of the input.</p></li>
</ul>
<p><strong>Space Complexity:</strong></p>
<ul class="simple">
<li><p>The space complexity of the code is constant, O(1).</p></li>
<li><p>Regardless of the size of the input <code class="docutils literal notranslate"><span class="pre">prices</span></code> array, the code only uses a fixed amount of additional memory to store two variables (<code class="docutils literal notranslate"><span class="pre">min_price</span></code> and <code class="docutils literal notranslate"><span class="pre">max_profit</span></code>) and a few loop variables.</p></li>
<li><p>The memory usage does not depend on the size of the input, so it is considered constant space complexity.</p></li>
</ul>
<p><strong>In summary:</strong></p>
<ul class="simple">
<li><p>Time Complexity: O(n) where n is the length of the <code class="docutils literal notranslate"><span class="pre">prices</span></code> array.</p></li>
<li><p>Space Complexity: O(1) (constant space usage).</p></li>
</ul>
</section>
<section id="challenging-exercises">
<h4>Challenging Exercises:<a class="headerlink" href="#challenging-exercises" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p><strong>Multiple Transactions Allowed:</strong> Modify the problem to allow multiple transactions (buy and sell multiple times), but you must sell before buying again. Find the maximum profit in this scenario.</p></li>
<li><p><strong>K Transactions Allowed:</strong> Extend the problem to allow at most k transactions. Find the maximum profit considering this constraint.</p></li>
<li><p><strong>With Transaction Fee:</strong> Introduce a transaction fee for each buy/sell operation. Modify the code to maximize profit while considering the transaction fee.</p></li>
</ol>
</section>
</section>
<span id="document-03. Sliding Window/3. Longest Substring Without Repeating Characters"></span><section class="tex2jax_ignore mathjax_ignore" id="longest-substring-without-repeating-characters">
<h3>3. Longest Substring Without Repeating Characters<a class="headerlink" href="#longest-substring-without-repeating-characters" title="Permalink to this heading">#</a></h3>
<p><strong>Difficulty:</strong> Medium</p>
<p><strong>Link to Problem:</strong> <a class="reference external" href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">To see the Longest Substring Without Repeating Characters problem on LeetCode, click here!</a></p>
<hr class="docutils" />
<p>Given a string <code class="docutils literal notranslate"><span class="pre">s</span></code>, find the length of the <strong>longest substring</strong> without repeating characters.</p>
<p><strong>Constraints:</strong></p>
<ul class="simple">
<li><p>0 &lt;= <code class="docutils literal notranslate"><span class="pre">s.length</span></code> &lt;= <span class="math notranslate nohighlight">\(5 * 10^4\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">s</span></code> consists of English letters, digits, symbols and spaces.</p></li>
</ul>
<section id="solution">
<h4>Solution:<a class="headerlink" href="#solution" title="Permalink to this heading">#</a></h4>
<p>Here’s a Python function to solve this problem:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">length_of_longest_substring</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="c1"># Create a dictionary to store the index of each character&#39;s last occurrence.</span>
    <span class="n">char_index</span> <span class="o">=</span> <span class="p">{}</span>
    
    <span class="c1"># Initialize variables to keep track of the start and end of the current substring.</span>
    <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">max_length</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="k">for</span> <span class="n">end</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>
        <span class="c1"># If the character is in the dictionary and its last occurrence is after the start of the current substring,</span>
        <span class="c1"># update the start of the substring to the next character after its last occurrence.</span>
        <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="ow">in</span> <span class="n">char_index</span> <span class="ow">and</span> <span class="n">char_index</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">end</span><span class="p">]]</span> <span class="o">&gt;=</span> <span class="n">start</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">char_index</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">end</span><span class="p">]]</span> <span class="o">+</span> <span class="mi">1</span>
        
        <span class="c1"># Update the last occurrence index of the current character.</span>
        <span class="n">char_index</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">end</span><span class="p">]]</span> <span class="o">=</span> <span class="n">end</span>
        
        <span class="c1"># Calculate the length of the current substring and update the maximum length if necessary.</span>
        <span class="n">current_length</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">max_length</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_length</span><span class="p">,</span> <span class="n">current_length</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">max_length</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="explanation">
<h4>Explanation:<a class="headerlink" href="#explanation" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p>We start by defining a function called <code class="docutils literal notranslate"><span class="pre">length_of_longest_substring</span></code> that takes a single argument <code class="docutils literal notranslate"><span class="pre">s</span></code>, which is the input string for which we want to find the length of the longest substring without repeating characters.</p></li>
<li><p>We create a dictionary called <code class="docutils literal notranslate"><span class="pre">char_index</span></code> to store the index of the last occurrence of each character in the input string. This dictionary will help us keep track of where each character was last seen.</p></li>
<li><p>We initialize two variables, <code class="docutils literal notranslate"><span class="pre">start</span></code> and <code class="docutils literal notranslate"><span class="pre">max_length</span></code>.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">start</span></code> represents the start index of the current substring without repeating characters. It starts at 0.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">max_length</span></code> is used to keep track of the maximum length found so far and is initially set to 0.</p></li>
</ul>
</li>
<li><p>We then iterate through the input string <code class="docutils literal notranslate"><span class="pre">s</span></code> using a for loop, where the loop variable <code class="docutils literal notranslate"><span class="pre">end</span></code> represents the current end index of the substring we are considering.</p></li>
<li><p>Inside the loop:</p>
<ul class="simple">
<li><p>We check if the character <code class="docutils literal notranslate"><span class="pre">s[end]</span></code> is already in the <code class="docutils literal notranslate"><span class="pre">char_index</span></code> dictionary and if its last occurrence is within or after the current substring. If so, it means that we’ve encountered a repeating character, and we need to update the <code class="docutils literal notranslate"><span class="pre">start</span></code> of the substring to the next character after the last occurrence of <code class="docutils literal notranslate"><span class="pre">s[end]</span></code>. This ensures that we have a new valid substring without repeating characters.</p></li>
<li><p>We then update the <code class="docutils literal notranslate"><span class="pre">char_index</span></code> dictionary by storing the current index <code class="docutils literal notranslate"><span class="pre">end</span></code> as the last occurrence index of the character <code class="docutils literal notranslate"><span class="pre">s[end]</span></code>.</p></li>
</ul>
</li>
<li><p>Next, we calculate the length of the current substring without repeating characters, which is <code class="docutils literal notranslate"><span class="pre">current_length</span> <span class="pre">=</span> <span class="pre">end</span> <span class="pre">-</span> <span class="pre">start</span> <span class="pre">+</span> <span class="pre">1</span></code>. We add 1 to account for the fact that the indices are zero-based.</p></li>
<li><p>We update the <code class="docutils literal notranslate"><span class="pre">max_length</span></code> with the maximum of its current value and the <code class="docutils literal notranslate"><span class="pre">current_length</span></code>. This step ensures that we keep track of the longest valid substring we have encountered so far.</p></li>
<li><p>The loop continues to iterate through the input string, and at the end, we return the <code class="docutils literal notranslate"><span class="pre">max_length</span></code>, which represents the length of the longest substring without repeating characters.</p></li>
</ol>
</section>
<section id="test-cases">
<h4>Test cases<a class="headerlink" href="#test-cases" title="Permalink to this heading">#</a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 1:</span>
<span class="nb">print</span><span class="p">(</span><span class="n">length_of_longest_substring</span><span class="p">(</span><span class="s2">&quot;abcabcbb&quot;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>3
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 2:</span>
<span class="nb">print</span><span class="p">(</span><span class="n">length_of_longest_substring</span><span class="p">(</span><span class="s2">&quot;bbbbb&quot;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 3:</span>
<span class="nb">print</span><span class="p">(</span><span class="n">length_of_longest_substring</span><span class="p">(</span><span class="s2">&quot;pwwkew&quot;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>3
</pre></div>
</div>
</div>
</div>
</section>
<section id="time-and-space-complexity-analysis">
<h4>Time and Space Complexity Analysis<a class="headerlink" href="#time-and-space-complexity-analysis" title="Permalink to this heading">#</a></h4>
<p>Let’s analyze the time and space complexity of the <code class="docutils literal notranslate"><span class="pre">length_of_longest_substring</span></code> function:</p>
<p><strong>Time Complexity:</strong></p>
<ul class="simple">
<li><p>The function iterates through the input string <code class="docutils literal notranslate"><span class="pre">s</span></code> using a single for loop. The loop runs from the beginning of the string to the end once.</p></li>
<li><p>Inside the loop, we perform constant-time operations such as dictionary lookups and updates, comparisons, and arithmetic operations.</p></li>
<li><p>Therefore, the time complexity of the function is O(n), where n is the length of the input string <code class="docutils literal notranslate"><span class="pre">s</span></code>.</p></li>
</ul>
<p><strong>Space Complexity:</strong></p>
<ul class="simple">
<li><p>The primary data structure that consumes space in this function is the <code class="docutils literal notranslate"><span class="pre">char_index</span></code> dictionary.</p></li>
<li><p>In the worst case, if there are no repeating characters in the input string, the dictionary can store all unique characters in the string.</p></li>
<li><p>Therefore, the space complexity is O(min(n, m)), where n is the length of the input string <code class="docutils literal notranslate"><span class="pre">s</span></code>, and m is the number of unique characters in the string. In the worst case, when all characters are unique, m is equal to n, so the space complexity is O(n).</p></li>
<li><p>Additionally, there are a few integer variables used for indices and lengths, which consume constant space.</p></li>
<li><p>Overall, the space complexity of the function is O(min(n, m)) or simply O(n) in the worst case.</p></li>
</ul>
<p><strong>In summary,</strong> the time complexity of the <code class="docutils literal notranslate"><span class="pre">length_of_longest_substring</span></code> function is O(n), and the space complexity is O(n) in the worst case due to the <code class="docutils literal notranslate"><span class="pre">char_index</span></code> dictionary. This algorithm provides an efficient way to find the length of the longest substring without repeating characters in linear time.</p>
</section>
<section id="challenging-exercises">
<h4>Challenging Exercises:<a class="headerlink" href="#challenging-exercises" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p><strong>Longest Substring with K Distinct Characters:</strong> Modify the problem to find the length of the longest substring with exactly K distinct characters. For example, given the input string “abcabcbb” and K = 2, the answer would be 4 because the longest substring with two distinct characters is “abca.”</p></li>
<li><p><strong>Longest Substring with Unique Characters:</strong> Write a function to find the length of the longest substring in a given string where all characters are unique. For example, given the input string “abcabcbb,” the answer would be 4 because “abcd” is the longest substring with unique characters.</p></li>
</ol>
</section>
</section>
<span id="document-03. Sliding Window/424. Longest Repeating Character Replacement"></span><section class="tex2jax_ignore mathjax_ignore" id="longest-repeating-character-replacement">
<h3>424. Longest Repeating Character Replacement<a class="headerlink" href="#longest-repeating-character-replacement" title="Permalink to this heading">#</a></h3>
<p><strong>Difficulty:</strong> Medium</p>
<p><strong>Link to Problem:</strong> <a class="reference external" href="https://leetcode.com/problems/longest-repeating-character-replacement/">To see the Longest Repeating Character Replacement problem on LeetCode, click here!</a></p>
<hr class="docutils" />
<p>You are given a string <code class="docutils literal notranslate"><span class="pre">s</span></code> and an integer <code class="docutils literal notranslate"><span class="pre">k</span></code>. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most <code class="docutils literal notranslate"><span class="pre">k</span></code> times.</p>
<p><em>Return the length of the longest substring containing the same letter you can get after performing the above operations.</em></p>
<p><strong>Constraints:</strong></p>
<ul class="simple">
<li><p>1 &lt;= <code class="docutils literal notranslate"><span class="pre">s.length</span></code> &lt;= <span class="math notranslate nohighlight">\(10^5\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">s</span></code> consists of only uppercase English letters.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">k</span> <span class="pre">&lt;=</span> <span class="pre">s.length</span></code></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">characterReplacement</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="n">max_length</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Initialize the maximum length</span>
    <span class="n">max_count</span> <span class="o">=</span> <span class="mi">0</span>   <span class="c1"># Initialize the maximum count of repeating characters</span>
    <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>       <span class="c1"># Initialize the start of the sliding window</span>
    <span class="n">char_count</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># Dictionary to store the count of each character</span>

    <span class="k">for</span> <span class="n">end</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>
        <span class="c1"># Update the count of the current character in the dictionary</span>
        <span class="n">char_count</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">end</span><span class="p">]]</span> <span class="o">=</span> <span class="n">char_count</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">end</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        
        <span class="c1"># Update the maximum count of repeating characters</span>
        <span class="n">max_count</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_count</span><span class="p">,</span> <span class="n">char_count</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">end</span><span class="p">]])</span>
        
        <span class="c1"># Check if the current window size is greater than k</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">max_count</span> <span class="o">&gt;</span> <span class="n">k</span><span class="p">:</span>
            <span class="c1"># Move the start of the window to the right</span>
            <span class="n">char_count</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">start</span><span class="p">]]</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">start</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="c1"># Update the maximum length</span>
        <span class="n">max_length</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_length</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">max_length</span>
</pre></div>
</div>
</div>
</div>
<section id="explanation">
<h4>Explanation:<a class="headerlink" href="#explanation" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p>We initialize some variables:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">max_length</span></code> to keep track of the maximum length of the substring containing the same letter.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">max_count</span></code> to keep track of the maximum count of repeating characters within the current window.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">start</span></code> to represent the start index of the sliding window.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">char_count</span></code> is a dictionary that will store the count of each character within the current window.</p></li>
</ul>
</li>
<li><p>We use a <code class="docutils literal notranslate"><span class="pre">for</span></code> loop to iterate through the characters of the string <code class="docutils literal notranslate"><span class="pre">s</span></code>.</p></li>
<li><p>Inside the loop, we do the following for each character at position <code class="docutils literal notranslate"><span class="pre">end</span></code>:</p>
<ul class="simple">
<li><p>Update the count of the current character in the <code class="docutils literal notranslate"><span class="pre">char_count</span></code> dictionary.</p></li>
<li><p>Update the <code class="docutils literal notranslate"><span class="pre">max_count</span></code> to be the maximum of the current <code class="docutils literal notranslate"><span class="pre">max_count</span></code> and the count of the current character. This keeps track of the maximum count of repeating characters within the current window.</p></li>
</ul>
</li>
<li><p>We check if the current window size (the difference between <code class="docutils literal notranslate"><span class="pre">end</span></code> and <code class="docutils literal notranslate"><span class="pre">start</span></code> plus one) minus the <code class="docutils literal notranslate"><span class="pre">max_count</span></code> is greater than <code class="docutils literal notranslate"><span class="pre">k</span></code>. This condition checks whether we have exceeded the allowed number of replacements (<code class="docutils literal notranslate"><span class="pre">k</span></code>) within the current window.</p>
<ul class="simple">
<li><p>If we have exceeded the allowed replacements, it means we need to shrink the window from the left side. We do this by moving the <code class="docutils literal notranslate"><span class="pre">start</span></code> of the window to the right and decrementing the count of the character at <code class="docutils literal notranslate"><span class="pre">s[start]</span></code> in the <code class="docutils literal notranslate"><span class="pre">char_count</span></code> dictionary. This effectively removes characters from the left side of the window until we have a valid window again.</p></li>
<li><p>By doing this, we ensure that the difference between the current window size and the <code class="docutils literal notranslate"><span class="pre">max_count</span></code> is always less than or equal to <code class="docutils literal notranslate"><span class="pre">k</span></code>.</p></li>
</ul>
</li>
<li><p>After each character, we update the <code class="docutils literal notranslate"><span class="pre">max_length</span></code> to be the maximum of the current <code class="docutils literal notranslate"><span class="pre">max_length</span></code> and the size of the current window (<code class="docutils literal notranslate"><span class="pre">end</span> <span class="pre">-</span> <span class="pre">start</span> <span class="pre">+</span> <span class="pre">1</span></code>).</p></li>
<li><p>Finally, we return <code class="docutils literal notranslate"><span class="pre">max_length</span></code>, which holds the length of the longest substring containing the same letter with at most <code class="docutils literal notranslate"><span class="pre">k</span></code> replacements.</p></li>
</ol>
</section>
<section id="test-cases">
<h4>Test cases<a class="headerlink" href="#test-cases" title="Permalink to this heading">#</a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 1:</span>
<span class="n">s1</span> <span class="o">=</span> <span class="s2">&quot;ABAB&quot;</span>
<span class="n">k1</span> <span class="o">=</span> <span class="mi">2</span>
<span class="nb">print</span><span class="p">(</span><span class="n">characterReplacement</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">k1</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>4
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 2:</span>
<span class="n">s2</span> <span class="o">=</span> <span class="s2">&quot;AABABBA&quot;</span>
<span class="n">k2</span> <span class="o">=</span> <span class="mi">1</span>
<span class="nb">print</span><span class="p">(</span><span class="n">characterReplacement</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span> <span class="n">k2</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>4
</pre></div>
</div>
</div>
</div>
<p>Let’s analyze the time and space complexity of the provided code:</p>
<p><strong>Time Complexity:</strong></p>
<ul class="simple">
<li><p>The code uses a single <code class="docutils literal notranslate"><span class="pre">for</span></code> loop to iterate through the characters of the input string <code class="docutils literal notranslate"><span class="pre">s</span></code>. The loop runs from the beginning to the end of the string.</p></li>
<li><p>Inside the loop, we perform constant-time operations such as updating the <code class="docutils literal notranslate"><span class="pre">char_count</span></code> dictionary and updating variables like <code class="docutils literal notranslate"><span class="pre">max_count</span></code> and <code class="docutils literal notranslate"><span class="pre">max_length</span></code>.</p></li>
<li><p>The code’s time complexity is primarily determined by the loop, which iterates through each character in the string once. Therefore, the time complexity is O(n), where n is the length of the input string <code class="docutils literal notranslate"><span class="pre">s</span></code>.</p></li>
</ul>
<p><strong>Space Complexity:</strong></p>
<ul class="simple">
<li><p>The code uses several variables to store information, but the space they consume is constant and does not depend on the size of the input string. These variables include <code class="docutils literal notranslate"><span class="pre">max_length</span></code>, <code class="docutils literal notranslate"><span class="pre">max_count</span></code>, <code class="docutils literal notranslate"><span class="pre">start</span></code>, and <code class="docutils literal notranslate"><span class="pre">char_count</span></code>. Therefore, the space complexity is O(1) or constant space.</p></li>
</ul>
<p><strong>In summary</strong>, the time complexity of the code is O(n), where n is the length of the input string, and the space complexity is O(1), as it uses a constant amount of additional space regardless of the input size. This algorithm efficiently solves the problem with a linear time complexity.</p>
</section>
<section id="challenging-exercises">
<h4>Challenging Exercises:<a class="headerlink" href="#challenging-exercises" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p><strong>Optimization Challenge:</strong> Modify the code to find the longest substring containing the same letter with at most k replacements in O(n) time complexity and O(1) space complexity. Hint: You may need to update the approach to achieve this.</p></li>
<li><p><strong>Variation with Lowercase Letters:</strong> Extend the problem to include both uppercase and lowercase English letters in the input string s. Write a function that can handle this extended input and still find the longest substring with at most k replacements efficiently.</p></li>
</ol>
</section>
</section>
<span id="document-03. Sliding Window/76. Minimum Window Substring"></span><section class="tex2jax_ignore mathjax_ignore" id="minimum-window-substring">
<h3>76. Minimum Window Substring<a class="headerlink" href="#minimum-window-substring" title="Permalink to this heading">#</a></h3>
<p><strong>Difficulty:</strong> Hard</p>
<p><strong>Link to Problem:</strong> <a class="reference external" href="https://leetcode.com/problems/minimum-window-substring/">To see the Minimum Window Substring problem on LeetCode, click here!</a></p>
<hr class="docutils" />
<p>Given two strings <code class="docutils literal notranslate"><span class="pre">s</span></code> and <code class="docutils literal notranslate"><span class="pre">t</span></code> of lengths <code class="docutils literal notranslate"><span class="pre">m</span></code> and <code class="docutils literal notranslate"><span class="pre">n</span></code> respectively, return <em>the <strong>minimum window substring</strong> of <code class="docutils literal notranslate"><span class="pre">s</span></code> such that every character in <code class="docutils literal notranslate"><span class="pre">t</span></code> (<strong>including duplicates</strong>) is included in the window. If there is no such substring, return the empty string <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code>.</em></p>
<p>The testcases will be generated such that the answer is <strong>unique</strong>.</p>
<p><strong>Constraints:</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">==</span> <span class="pre">s.length</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">==</span> <span class="pre">t.length</span></code></p></li>
<li><p>1 &lt;= <code class="docutils literal notranslate"><span class="pre">m,</span> <span class="pre">n</span></code> &lt;= <span class="math notranslate nohighlight">\(10^5\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">s</span></code> and <code class="docutils literal notranslate"><span class="pre">t</span></code> consist of uppercase and lowercase English letters.</p></li>
</ul>
<p><strong>Follow up</strong>: Could you find an algorithm that runs in <span class="math notranslate nohighlight">\(O(m + n)\)</span> time?</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">min_window_substring</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">s</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">t</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span>

    <span class="c1"># Initialize dictionaries to keep track of character counts for t and the current window in s.</span>
    <span class="n">t_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">current_window_dict</span> <span class="o">=</span> <span class="p">{}</span>
    
    <span class="c1"># Populate t_dict with character counts for string t.</span>
    <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">t</span><span class="p">:</span>
        <span class="n">t_dict</span><span class="p">[</span><span class="n">char</span><span class="p">]</span> <span class="o">=</span> <span class="n">t_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">char</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1"># Initialize pointers for the sliding window.</span>
    <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">min_len</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span>
    <span class="n">min_window</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="n">required_chars</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t_dict</span><span class="p">)</span>

    <span class="c1"># Initialize a variable to keep track of how many required characters have been found in the current window.</span>
    <span class="n">found_chars</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Iterate over the string s using the right pointer.</span>
    <span class="k">for</span> <span class="n">right</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>
        <span class="n">char</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">right</span><span class="p">]</span>

        <span class="c1"># Update the current_window_dict.</span>
        <span class="n">current_window_dict</span><span class="p">[</span><span class="n">char</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_window_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">char</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># Check if the current character is a required character and if its count matches the required count.</span>
        <span class="k">if</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">t_dict</span> <span class="ow">and</span> <span class="n">current_window_dict</span><span class="p">[</span><span class="n">char</span><span class="p">]</span> <span class="o">==</span> <span class="n">t_dict</span><span class="p">[</span><span class="n">char</span><span class="p">]:</span>
            <span class="n">found_chars</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Try to minimize the window by moving the left pointer.</span>
        <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span> <span class="ow">and</span> <span class="n">found_chars</span> <span class="o">==</span> <span class="n">required_chars</span><span class="p">:</span>
            <span class="c1"># Calculate the current window size.</span>
            <span class="n">window_size</span> <span class="o">=</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="c1"># If the current window is smaller than the minimum found so far, update min_len and min_window.</span>
            <span class="k">if</span> <span class="n">window_size</span> <span class="o">&lt;</span> <span class="n">min_len</span><span class="p">:</span>
                <span class="n">min_len</span> <span class="o">=</span> <span class="n">window_size</span>
                <span class="n">min_window</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">left</span><span class="p">:</span><span class="n">right</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># Move the left pointer to the right to shrink the window.</span>
            <span class="n">left_char</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">left</span><span class="p">]</span>
            <span class="n">current_window_dict</span><span class="p">[</span><span class="n">left_char</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>

            <span class="c1"># Check if the character removed from the window was a required character.</span>
            <span class="k">if</span> <span class="n">left_char</span> <span class="ow">in</span> <span class="n">t_dict</span> <span class="ow">and</span> <span class="n">current_window_dict</span><span class="p">[</span><span class="n">left_char</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">t_dict</span><span class="p">[</span><span class="n">left_char</span><span class="p">]:</span>
                <span class="n">found_chars</span> <span class="o">-=</span> <span class="mi">1</span>

            <span class="c1"># Move the left pointer further to continue shrinking the window.</span>
            <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">min_window</span>
</pre></div>
</div>
</div>
</div>
<section id="explanation">
<h4>Explanation:<a class="headerlink" href="#explanation" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p>We start by checking if either of the input strings <code class="docutils literal notranslate"><span class="pre">s</span></code> or <code class="docutils literal notranslate"><span class="pre">t</span></code> is empty. If either of them is empty, we return an empty string since there can’t be any valid substring in this case.</p></li>
<li><p>We initialize two dictionaries: <code class="docutils literal notranslate"><span class="pre">t_dict</span></code> and <code class="docutils literal notranslate"><span class="pre">current_window_dict</span></code>. These dictionaries will be used to keep track of character counts in the string <code class="docutils literal notranslate"><span class="pre">t</span></code> and the current window in string <code class="docutils literal notranslate"><span class="pre">s</span></code>, respectively.</p></li>
<li><p>We populate the <code class="docutils literal notranslate"><span class="pre">t_dict</span></code> dictionary by iterating through string <code class="docutils literal notranslate"><span class="pre">t</span></code>. For each character, we increment its count in the dictionary using <code class="docutils literal notranslate"><span class="pre">t_dict.get(char,</span> <span class="pre">0)</span> <span class="pre">+</span> <span class="pre">1</span></code>. This allows us to count the occurrences of each character in <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p></li>
<li><p>We initialize two pointers: <code class="docutils literal notranslate"><span class="pre">left</span></code> and <code class="docutils literal notranslate"><span class="pre">right</span></code>. The <code class="docutils literal notranslate"><span class="pre">left</span></code> pointer will represent the start of the current window, and the <code class="docutils literal notranslate"><span class="pre">right</span></code> pointer will represent the end of the current window. We also initialize <code class="docutils literal notranslate"><span class="pre">min_len</span></code> to store the length of the minimum window found so far, and <code class="docutils literal notranslate"><span class="pre">min_window</span></code> to store the actual minimum window substring.</p></li>
<li><p>We determine the number of required characters in <code class="docutils literal notranslate"><span class="pre">t</span></code> (i.e., the number of distinct characters in <code class="docutils literal notranslate"><span class="pre">t</span></code>) and store it in the variable <code class="docutils literal notranslate"><span class="pre">required_chars</span></code>.</p></li>
<li><p>We initialize a variable <code class="docutils literal notranslate"><span class="pre">found_chars</span></code> to keep track of how many required characters have been found in the current window. Initially, it is set to 0.</p></li>
<li><p>We iterate over the string <code class="docutils literal notranslate"><span class="pre">s</span></code> using the <code class="docutils literal notranslate"><span class="pre">right</span></code> pointer. In each iteration, we do the following:</p>
<ul class="simple">
<li><p>Update the <code class="docutils literal notranslate"><span class="pre">current_window_dict</span></code> by incrementing the count of the current character.</p></li>
<li><p>Check if the current character is a required character (present in <code class="docutils literal notranslate"><span class="pre">t_dict</span></code>) and if its count in the <code class="docutils literal notranslate"><span class="pre">current_window_dict</span></code> matches the required count from <code class="docutils literal notranslate"><span class="pre">t_dict</span></code>. If so, we increment <code class="docutils literal notranslate"><span class="pre">found_chars</span></code>.</p></li>
</ul>
</li>
<li><p>After updating the window, we attempt to minimize the window size by moving the <code class="docutils literal notranslate"><span class="pre">left</span></code> pointer to the right. In this step, we:</p>
<ul class="simple">
<li><p>Calculate the size of the current window.</p></li>
<li><p>If the current window size is smaller than the minimum found so far (<code class="docutils literal notranslate"><span class="pre">min_len</span></code>), we update <code class="docutils literal notranslate"><span class="pre">min_len</span></code> and <code class="docutils literal notranslate"><span class="pre">min_window</span></code> to store the current window substring.</p></li>
<li><p>Move the <code class="docutils literal notranslate"><span class="pre">left</span></code> pointer to the right to shrink the window.</p></li>
<li><p>Check if the character being removed from the window was a required character. If it was, we decrement <code class="docutils literal notranslate"><span class="pre">found_chars</span></code>.</p></li>
<li><p>Continue moving the <code class="docutils literal notranslate"><span class="pre">left</span></code> pointer further to continue shrinking the window if the window still contains all required characters.</p></li>
</ul>
</li>
<li><p>Finally, we return <code class="docutils literal notranslate"><span class="pre">min_window</span></code>, which will contain the minimum window substring that contains all characters from <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p></li>
</ol>
</section>
<section id="test-cases">
<h4>Test cases<a class="headerlink" href="#test-cases" title="Permalink to this heading">#</a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 1:</span>
<span class="nb">print</span><span class="p">(</span><span class="n">min_window_substring</span><span class="p">(</span><span class="s2">&quot;ADOBECODEBANC&quot;</span><span class="p">,</span> <span class="s2">&quot;ABC&quot;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>BANC
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 2:</span>
<span class="nb">print</span><span class="p">(</span><span class="n">min_window_substring</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">))</span> 
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>a
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 3:</span>
<span class="nb">print</span><span class="p">(</span><span class="n">min_window_substring</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;aa&quot;</span><span class="p">))</span> 
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
</div>
</div>
<p>Let’s analyze the time and space complexity of the <code class="docutils literal notranslate"><span class="pre">min_window_substring</span></code> function:</p>
<p><strong>Time Complexity:</strong></p>
<ul class="simple">
<li><p>The main loop iterates through the string <code class="docutils literal notranslate"><span class="pre">s</span></code> from left to right using the <code class="docutils literal notranslate"><span class="pre">right</span></code> pointer. This loop runs in O(m) time, where ‘m’ is the length of string <code class="docutils literal notranslate"><span class="pre">s</span></code>.</p></li>
<li><p>Inside the loop, we have a while loop that moves the <code class="docutils literal notranslate"><span class="pre">left</span></code> pointer to the right to shrink the window as needed. In the worst case, this while loop can also run in O(m) time because in the worst case, we may have to move the <code class="docutils literal notranslate"><span class="pre">left</span></code> pointer all the way to the end of the string.</p></li>
<li><p>Within each iteration of the while loop, we perform constant time operations, such as updating dictionaries and comparing character counts.</p></li>
<li><p>The initialization of the <code class="docutils literal notranslate"><span class="pre">t_dict</span></code> dictionary takes O(n) time, where ‘n’ is the length of string <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p></li>
</ul>
<p>Therefore, the overall time complexity of the function is O(m + n) because the dominant factor is the length of string <code class="docutils literal notranslate"><span class="pre">s</span></code>, and the length of string <code class="docutils literal notranslate"><span class="pre">t</span></code> has a smaller impact.</p>
<p><strong>Space Complexity:</strong></p>
<ul class="simple">
<li><p>The space complexity is determined by the space used by the <code class="docutils literal notranslate"><span class="pre">t_dict</span></code> dictionary, the <code class="docutils literal notranslate"><span class="pre">current_window_dict</span></code> dictionary, and a few variables.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">t_dict</span></code> dictionary stores character counts for string <code class="docutils literal notranslate"><span class="pre">t</span></code>. In the worst case, when all characters in <code class="docutils literal notranslate"><span class="pre">t</span></code> are distinct, this dictionary can have a maximum of ‘n’ key-value pairs. So, the space complexity for <code class="docutils literal notranslate"><span class="pre">t_dict</span></code> is O(n).</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">current_window_dict</span></code> dictionary stores character counts for the current window. In the worst case, it can have a maximum of ‘m’ key-value pairs. So, the space complexity for <code class="docutils literal notranslate"><span class="pre">current_window_dict</span></code> is also O(m).</p></li>
<li><p>Other variables used in the function, such as <code class="docutils literal notranslate"><span class="pre">left</span></code>, <code class="docutils literal notranslate"><span class="pre">right</span></code>, <code class="docutils literal notranslate"><span class="pre">min_len</span></code>, <code class="docutils literal notranslate"><span class="pre">min_window</span></code>, <code class="docutils literal notranslate"><span class="pre">required_chars</span></code>, and <code class="docutils literal notranslate"><span class="pre">found_chars</span></code>, are all of constant size and do not depend on the input sizes.</p></li>
</ul>
<p><strong>In summary</strong>, the overall space complexity of the function is O(max(m, n)), which means it is determined by the larger of the two input strings’ lengths. This is because the space used for <code class="docutils literal notranslate"><span class="pre">t_dict</span></code> and <code class="docutils literal notranslate"><span class="pre">current_window_dict</span></code> dominates the space complexity.</p>
</section>
<section id="challenging-exercises">
<h4>Challenging Exercises:<a class="headerlink" href="#challenging-exercises" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p><strong>Smallest Distinct Substring:</strong> Instead of finding the minimum window substring containing all characters, find the smallest distinct (unique) substring of s that contains all characters from t. This variation adds complexity because you must find a substring with distinct characters.</p></li>
<li><p><strong>No Extra Space:</strong> Solve the problem without using any extra space, such as dictionaries or arrays, other than a constant amount of space. This is a significant optimization challenge.</p></li>
</ol>
</section>
</section>
</div>
</section>
<span id="document-04. Stack/README"></span><section class="tex2jax_ignore mathjax_ignore" id="stack-problems-blind-75-leetcode">
<h2>Stack Problems - Blind 75 LeetCode<a class="headerlink" href="#stack-problems-blind-75-leetcode" title="Permalink to this heading">#</a></h2>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Problem Name</p></th>
<th class="head"><p>Difficulty</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/valid-parentheses/">20. Valid Parentheses</a></p></td>
<td><p>Easy</p></td>
</tr>
</tbody>
</table>
<section id="contribute">
<h3>Contribute<a class="headerlink" href="#contribute" title="Permalink to this heading">#</a></h3>
<p>If you have a better solution or want to add more problems to the collection, feel free to contribute. You can create a pull request or open an issue to discuss additions or improvements.</p>
</section>
<section id="resources">
<h3>Resources<a class="headerlink" href="#resources" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p><a class="reference external" href="https://leetcode.com/">LeetCode</a>: The official LeetCode website.</p></li>
<li><p><a class="reference external" href="https://leetcode.com/discuss/">LeetCode Discuss</a>: LeetCode’s discussion forum for each problem. You can find helpful hints and discussions here.</p></li>
</ul>
<p>Happy coding!</p>
</section>
<div class="toctree-wrapper compound">
<span id="document-04. Stack/20. Valid Parentheses"></span><section class="tex2jax_ignore mathjax_ignore" id="valid-parentheses">
<h3>20. Valid Parentheses<a class="headerlink" href="#valid-parentheses" title="Permalink to this heading">#</a></h3>
<p><strong>Difficulty:</strong> Easy</p>
<p><strong>Link to Problem:</strong> <a class="reference external" href="https://leetcode.com/problems/valid-parentheses/">To see the Valid Parentheses problem on LeetCode, click here!</a></p>
<hr class="docutils" />
<p>Given a string s containing just the characters <code class="docutils literal notranslate"><span class="pre">'('</span></code>, <code class="docutils literal notranslate"><span class="pre">')'</span></code>, <code class="docutils literal notranslate"><span class="pre">'{'</span></code>, <code class="docutils literal notranslate"><span class="pre">'}'</span></code>, <code class="docutils literal notranslate"><span class="pre">'['</span></code> and <code class="docutils literal notranslate"><span class="pre">']'</span></code>, determine if the input string is valid.</p>
<p>An input string is valid if:</p>
<ol class="arabic simple">
<li><p>Open brackets must be closed by the same type of brackets.</p></li>
<li><p>Open brackets must be closed in the correct order.</p></li>
<li><p>Every close bracket has a corresponding open bracket of the same type.</p></li>
</ol>
<p><strong>Constraints:</strong></p>
<ul class="simple">
<li><p>1 &lt;= <code class="docutils literal notranslate"><span class="pre">s.length</span></code> &lt;= <span class="math notranslate nohighlight">\(10^4\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">s</span></code> consists of parentheses only <code class="docutils literal notranslate"><span class="pre">'()[]{}'</span></code>.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">isValid</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="c1"># Create an empty stack to store opening brackets</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c1"># Define a mapping for matching brackets</span>
    <span class="n">bracket_mapping</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;)&#39;</span><span class="p">:</span> <span class="s1">&#39;(&#39;</span><span class="p">,</span> <span class="s1">&#39;}&#39;</span><span class="p">:</span> <span class="s1">&#39;{&#39;</span><span class="p">,</span> <span class="s1">&#39;]&#39;</span><span class="p">:</span> <span class="s1">&#39;[&#39;</span><span class="p">}</span>
    
    <span class="c1"># Iterate through the characters in the input string</span>
    <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
        <span class="c1"># If the character is an opening bracket, push it onto the stack</span>
        <span class="k">if</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">bracket_mapping</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
        <span class="c1"># If the character is a closing bracket</span>
        <span class="k">elif</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">bracket_mapping</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="c1"># Pop the top element from the stack if it exists, or use a dummy value &#39;#&#39;</span>
            <span class="n">top_element</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="k">if</span> <span class="n">stack</span> <span class="k">else</span> <span class="s1">&#39;#&#39;</span>
            <span class="c1"># If the popped element does not match the corresponding opening bracket, return False</span>
            <span class="k">if</span> <span class="n">bracket_mapping</span><span class="p">[</span><span class="n">char</span><span class="p">]</span> <span class="o">!=</span> <span class="n">top_element</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="c1"># If the character is not a bracket, ignore it</span>
        
    <span class="c1"># After processing the entire string, if there are any unmatched opening brackets left in the stack, return False</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
</pre></div>
</div>
</div>
</div>
<section id="explanation">
<h4>Explanation:<a class="headerlink" href="#explanation" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p>We start by defining the <code class="docutils literal notranslate"><span class="pre">isValid</span></code> function that takes a single argument <code class="docutils literal notranslate"><span class="pre">s</span></code>, which is the input string containing parentheses and brackets.</p></li>
<li><p>Inside the function, we create an empty stack, which is a list in Python, to store opening brackets as we encounter them in the input string. The stack will help us keep track of the brackets and their order.</p></li>
<li><p>We define a <code class="docutils literal notranslate"><span class="pre">bracket_mapping</span></code> dictionary that maps each closing bracket to its corresponding opening bracket. This mapping will be used to check if a closing bracket matches the most recent opening bracket in the stack.</p></li>
<li><p>We iterate through each character <code class="docutils literal notranslate"><span class="pre">char</span></code> in the input string <code class="docutils literal notranslate"><span class="pre">s</span></code> using a <code class="docutils literal notranslate"><span class="pre">for</span></code> loop.</p></li>
<li><p>If the character <code class="docutils literal notranslate"><span class="pre">char</span></code> is an opening bracket (i.e., it exists in the <code class="docutils literal notranslate"><span class="pre">values()</span></code> of <code class="docutils literal notranslate"><span class="pre">bracket_mapping</span></code>), we push it onto the stack using the <code class="docutils literal notranslate"><span class="pre">append()</span></code> method.</p></li>
<li><p>If the character <code class="docutils literal notranslate"><span class="pre">char</span></code> is a closing bracket (i.e., it exists in the <code class="docutils literal notranslate"><span class="pre">keys()</span></code> of <code class="docutils literal notranslate"><span class="pre">bracket_mapping</span></code>), we need to check if it matches the corresponding opening bracket. To do this, we pop the top element from the stack (if it exists) and store it in <code class="docutils literal notranslate"><span class="pre">top_element</span></code>. We use a dummy value <code class="docutils literal notranslate"><span class="pre">'#'</span></code> if the stack is empty to avoid errors.</p></li>
<li><p>We then compare <code class="docutils literal notranslate"><span class="pre">top_element</span></code> with the corresponding opening bracket using <code class="docutils literal notranslate"><span class="pre">bracket_mapping[char]</span></code>. If they do not match, it means the string is not valid, and we return <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
<li><p>If the character <code class="docutils literal notranslate"><span class="pre">char</span></code> is not a bracket, we simply ignore it and continue the loop.</p></li>
<li><p>After processing the entire string, we check if there are any unmatched opening brackets left in the stack. If the stack is empty, it means all opening brackets have been properly matched and closed, and we return <code class="docutils literal notranslate"><span class="pre">True</span></code>. Otherwise, we return <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
<li><p>Finally, we provide some test cases at the bottom of the code to demonstrate how the function works for different input strings.</p></li>
</ol>
</section>
<section id="test-cases">
<h4>Test cases<a class="headerlink" href="#test-cases" title="Permalink to this heading">#</a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 1:</span>
<span class="nb">print</span><span class="p">(</span><span class="n">isValid</span><span class="p">(</span><span class="s2">&quot;()&quot;</span><span class="p">))</span>    
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 2:</span>
<span class="nb">print</span><span class="p">(</span><span class="n">isValid</span><span class="p">(</span><span class="s2">&quot;()[]</span><span class="si">{}</span><span class="s2">&quot;</span><span class="p">))</span> 
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 3:</span>
<span class="nb">print</span><span class="p">(</span><span class="n">isValid</span><span class="p">(</span><span class="s2">&quot;(]&quot;</span><span class="p">))</span>     
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>False
</pre></div>
</div>
</div>
</div>
<p>Let’s analyze the time and space complexity of the <code class="docutils literal notranslate"><span class="pre">isValid</span></code> function:</p>
<p><strong>Time Complexity:</strong></p>
<ul class="simple">
<li><p>The function iterates through each character in the input string <code class="docutils literal notranslate"><span class="pre">s</span></code> once, performing constant-time operations for each character.</p></li>
<li><p>Pushing and popping elements from the stack (list) also takes constant time in most cases.</p></li>
<li><p>Therefore, the overall time complexity of the function is <span class="math notranslate nohighlight">\(O(n)\)</span>, where <span class="math notranslate nohighlight">\(n\)</span> is the length of the input string <code class="docutils literal notranslate"><span class="pre">s</span></code>.</p></li>
</ul>
<p><strong>Space Complexity:</strong></p>
<ul class="simple">
<li><p>The space complexity of the function is determined by the space used by the stack and the <code class="docutils literal notranslate"><span class="pre">bracket_mapping</span></code> dictionary.</p></li>
<li><p>In the worst case, if the input string <code class="docutils literal notranslate"><span class="pre">s</span></code> consists entirely of opening brackets, the stack can potentially contain all of these opening brackets, resulting in a space complexity of <span class="math notranslate nohighlight">\(O(n)\)</span> in terms of the stack.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">bracket_mapping</span></code> dictionary has a constant number of key-value pairs (3 pairs in this case).</p></li>
<li><p>Therefore, the overall space complexity of the function is <span class="math notranslate nohighlight">\(O(n)\)</span>, where <span class="math notranslate nohighlight">\(n\)</span> is the length of the input string <code class="docutils literal notranslate"><span class="pre">s</span></code>, mainly due to the stack space.</p></li>
</ul>
<p><strong>In summary:</strong></p>
<ul class="simple">
<li><p>The time complexity is <span class="math notranslate nohighlight">\(O(n)\)</span> because we iterate through the string once.</p></li>
<li><p>The space complexity is <span class="math notranslate nohighlight">\(O(n)\)</span> due to the stack used to keep track of opening brackets.</p></li>
</ul>
</section>
<section id="challenging-exercises">
<h4>Challenging Exercises:<a class="headerlink" href="#challenging-exercises" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p><strong>Valid Expressions:</strong> Modify the problem to validate not only brackets but also arithmetic expressions containing parentheses, such as “<span class="math notranslate nohighlight">\(2 * (3 + 5) / (4 - 2)\)</span>”.</p></li>
<li><p><strong>Valid Parentheses Combinations:</strong>
Write a function to generate all valid combinations of n pairs of parentheses, where <span class="math notranslate nohighlight">\(n\)</span> is a positive integer. For example, for <span class="math notranslate nohighlight">\(n = 3\)</span>, the valid combinations are [“((()))”, “(()())”, “(())()”, “()(())”, “()()()”].</p></li>
</ol>
</section>
</section>
</div>
</section>
<span id="document-05. Binary Search/README"></span><section class="tex2jax_ignore mathjax_ignore" id="binary-search-problems-blind-75-leetcode">
<h2>Binary search Problems - Blind 75 LeetCode<a class="headerlink" href="#binary-search-problems-blind-75-leetcode" title="Permalink to this heading">#</a></h2>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Problem Name</p></th>
<th class="head"><p>Difficulty</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/">153. Find Minimum In Rotated Sorted Array</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/search-in-rotated-sorted-array/">33. Search In Rotated Sorted Array</a></p></td>
<td><p>Medium</p></td>
</tr>
</tbody>
</table>
<section id="contribute">
<h3>Contribute<a class="headerlink" href="#contribute" title="Permalink to this heading">#</a></h3>
<p>If you have a better solution or want to add more problems to the collection, feel free to contribute. You can create a pull request or open an issue to discuss additions or improvements.</p>
</section>
<section id="resources">
<h3>Resources<a class="headerlink" href="#resources" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p><a class="reference external" href="https://leetcode.com/">LeetCode</a>: The official LeetCode website.</p></li>
<li><p><a class="reference external" href="https://leetcode.com/discuss/">LeetCode Discuss</a>: LeetCode’s discussion forum for each problem. You can find helpful hints and discussions here.</p></li>
</ul>
<p>Happy coding!</p>
</section>
<div class="toctree-wrapper compound">
<span id="document-05. Binary Search/153. Find Minimum in Rotated Sorted Array"></span><section class="tex2jax_ignore mathjax_ignore" id="find-minimum-in-rotated-sorted-array">
<h3>153. Find Minimum in Rotated Sorted Array<a class="headerlink" href="#find-minimum-in-rotated-sorted-array" title="Permalink to this heading">#</a></h3>
<p><strong>Difficulty:</strong> Medium</p>
<p><strong>Link to Problem:</strong> <a class="reference external" href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/">To see the Find Minimum in Rotated Sorted Array problem on LeetCode, click here!</a></p>
<hr class="docutils" />
<p>Suppose an array of length <code class="docutils literal notranslate"><span class="pre">n</span></code> sorted in ascending order is <strong>rotated</strong> between <code class="docutils literal notranslate"><span class="pre">1</span></code> and <code class="docutils literal notranslate"><span class="pre">n</span></code> times. For example, the array <code class="docutils literal notranslate"><span class="pre">nums</span> <span class="pre">=</span> <span class="pre">[0,1,2,4,5,6,7]</span></code> might become:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[4,5,6,7,0,1,2]</span></code> if it was rotated <code class="docutils literal notranslate"><span class="pre">4</span></code> times.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[0,1,2,4,5,6,7]</span></code> if it was rotated <code class="docutils literal notranslate"><span class="pre">7</span></code> times.</p></li>
</ul>
<p>Notice that <strong>rotating</strong> an array <code class="docutils literal notranslate"><span class="pre">[a[0],</span> <span class="pre">a[1],</span> <span class="pre">a[2],</span> <span class="pre">...,</span> <span class="pre">a[n-1]]</span></code> 1 time results in the array <code class="docutils literal notranslate"><span class="pre">[a[n-1],</span> <span class="pre">a[0],</span> <span class="pre">a[1],</span> <span class="pre">a[2],</span> <span class="pre">...,</span> <span class="pre">a[n-2]]</span></code>.</p>
<p>Given the sorted rotated array <code class="docutils literal notranslate"><span class="pre">nums</span></code> of <strong>unique</strong> elements, return <em>the minimum element of this array.</em></p>
<p>You must write an algorithm that runs in <span class="math notranslate nohighlight">\(O(log\ n)\)</span> time.</p>
<p><strong>Constraints:</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">==</span> <span class="pre">nums.length</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">&lt;=</span> <span class="pre">n</span> <span class="pre">&lt;=</span> <span class="pre">5000</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-5000</span> <span class="pre">&lt;=</span> <span class="pre">nums[i]</span> <span class="pre">&lt;=</span> <span class="pre">5000</span></code></p></li>
<li><p>All the integers of <code class="docutils literal notranslate"><span class="pre">nums</span></code> are <strong>unique</strong>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nums</span></code> is sorted and rotated between <code class="docutils literal notranslate"><span class="pre">1</span></code> and <code class="docutils literal notranslate"><span class="pre">n</span></code> times.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">findMin</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
    <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    
    <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">:</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        
        <span class="c1"># If the mid element is greater than the rightmost element,</span>
        <span class="c1"># it means the minimum element is in the right half.</span>
        <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]:</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="c1"># If the mid element is less than or equal to the rightmost element,</span>
        <span class="c1"># it means the minimum element is in the left half or at the mid itself.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span>
    
    <span class="c1"># The loop will break when left and right converge to the minimum element.</span>
    <span class="c1"># At this point, left (or right) will be pointing to the minimum element.</span>
    <span class="k">return</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<section id="explanation">
<h4>Explanation:<a class="headerlink" href="#explanation" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p>The function <code class="docutils literal notranslate"><span class="pre">findMin(nums)</span></code> takes an input list <code class="docutils literal notranslate"><span class="pre">nums</span></code>, which represents the rotated sorted array.</p></li>
<li><p>Initialize two pointers <code class="docutils literal notranslate"><span class="pre">left</span></code> and <code class="docutils literal notranslate"><span class="pre">right</span></code> to track the current search range. Initially, <code class="docutils literal notranslate"><span class="pre">left</span></code> is set to 0 (the beginning of the array), and <code class="docutils literal notranslate"><span class="pre">right</span></code> is set to <code class="docutils literal notranslate"><span class="pre">len(nums)</span> <span class="pre">-</span> <span class="pre">1</span></code> (the end of the array).</p></li>
<li><p>Enter a <code class="docutils literal notranslate"><span class="pre">while</span></code> loop with the condition <code class="docutils literal notranslate"><span class="pre">left</span> <span class="pre">&lt;</span> <span class="pre">right</span></code>. This loop continues until <code class="docutils literal notranslate"><span class="pre">left</span></code> and <code class="docutils literal notranslate"><span class="pre">right</span></code> converge to a single element, which will be the minimum element in the rotated array.</p></li>
<li><p>Inside the loop, calculate the middle index <code class="docutils literal notranslate"><span class="pre">mid</span></code> using integer division. This helps in finding the middle element of the current search range.</p></li>
<li><p>Check if the element at the middle index (<code class="docutils literal notranslate"><span class="pre">nums[mid]</span></code>) is greater than the element at the rightmost index (<code class="docutils literal notranslate"><span class="pre">nums[right]</span></code>). If this condition is true, it means that the minimum element must be in the right half of the current search range. So, update <code class="docutils literal notranslate"><span class="pre">left</span></code> to <code class="docutils literal notranslate"><span class="pre">mid</span> <span class="pre">+</span> <span class="pre">1</span></code>, effectively eliminating the left half of the search range.</p></li>
<li><p>If the condition from step 5 is not met, it implies that the minimum element can be in the left half of the current search range or could be the element at the <code class="docutils literal notranslate"><span class="pre">mid</span></code> index itself. In this case, update <code class="docutils literal notranslate"><span class="pre">right</span></code> to <code class="docutils literal notranslate"><span class="pre">mid</span></code>, effectively eliminating the right half of the search range.</p></li>
<li><p>Repeat steps 4-6 until <code class="docutils literal notranslate"><span class="pre">left</span></code> and <code class="docutils literal notranslate"><span class="pre">right</span></code> converge to the minimum element.</p></li>
<li><p>When the loop exits, it means that <code class="docutils literal notranslate"><span class="pre">left</span></code> (or <code class="docutils literal notranslate"><span class="pre">right</span></code>) points to the minimum element in the array.</p></li>
<li><p>Return <code class="docutils literal notranslate"><span class="pre">nums[left]</span></code> (or <code class="docutils literal notranslate"><span class="pre">nums[right]</span></code>) as the result, which is the minimum element in the rotated sorted array.</p></li>
</ol>
</section>
<section id="test-cases">
<h4>Test cases<a class="headerlink" href="#test-cases" title="Permalink to this heading">#</a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">### Example 1:</span>
<span class="n">nums1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">findMin</span><span class="p">(</span><span class="n">nums1</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 2:</span>
<span class="n">nums2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">findMin</span><span class="p">(</span><span class="n">nums2</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 3:</span>
<span class="n">nums3</span> <span class="o">=</span> <span class="p">[</span><span class="mi">11</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">17</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">findMin</span><span class="p">(</span><span class="n">nums3</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>11
</pre></div>
</div>
</div>
</div>
<p>Let’s analyze the time and space complexity of the provided code:</p>
<p><strong>Time Complexity:</strong>
The time complexity of this code is <span class="math notranslate nohighlight">\(O(log\ n)\)</span>, where ‘<span class="math notranslate nohighlight">\(n\)</span>’ is the length of the input array <code class="docutils literal notranslate"><span class="pre">nums</span></code>. This is because the binary search algorithm is employed, which continually divides the search range in half with each iteration.</p>
<p>In each iteration of the <code class="docutils literal notranslate"><span class="pre">while</span></code> loop, the search range is halved, and this process continues until the <code class="docutils literal notranslate"><span class="pre">left</span></code> and <code class="docutils literal notranslate"><span class="pre">right</span></code> pointers converge to the minimum element. In the worst case, it will take logarithmic time to reduce the search range to a single element.</p>
<p>Therefore, the binary search used in this code runs in <span class="math notranslate nohighlight">\(O(log\ n)\)</span> time complexity.</p>
<p><strong>Space Complexity:</strong>
The space complexity of this code is <span class="math notranslate nohighlight">\(O(1)\)</span>, which means it uses a constant amount of additional space that does not depend on the size of the input array.</p>
<p>The algorithm uses a fixed number of variables (<code class="docutils literal notranslate"><span class="pre">left</span></code>, <code class="docutils literal notranslate"><span class="pre">right</span></code>, <code class="docutils literal notranslate"><span class="pre">mid</span></code>) to keep track of the search range and indices, but the number of these variables does not grow with the size of the input array. Hence, the space complexity is constant.</p>
<p><strong>In summary:</strong></p>
<ul class="simple">
<li><p>Time Complexity: <span class="math notranslate nohighlight">\(O(log\ n)\)</span></p></li>
<li><p>Space Complexity: <span class="math notranslate nohighlight">\(O(1)\)</span></p></li>
</ul>
</section>
<section id="challenging-exercises">
<h4>Challenging Exercises:<a class="headerlink" href="#challenging-exercises" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p>Solve the problem with a variation where the input array may contain duplicates.</p></li>
<li><p>Modify the problem to return the index of the minimum element in the rotated sorted array, rather than the element itself. The algorithm should still run in <span class="math notranslate nohighlight">\(O(log\ n)\)</span> time.</p></li>
<li><p>Implement a function that finds the maximum element in a rotated sorted array. How would you adapt the binary search algorithm to solve this problem efficiently in <span class="math notranslate nohighlight">\(O(log\ n)\)</span> time?</p></li>
<li><p>Implement a function that can find the kth smallest element in a rotated sorted array. This is an extension of the original problem, and the algorithm should still run in <span class="math notranslate nohighlight">\(O(log\ n)\)</span> time.</p></li>
</ol>
</section>
</section>
<span id="document-05. Binary Search/33. Search in Rotated Sorted Array"></span><section class="tex2jax_ignore mathjax_ignore" id="search-in-rotated-sorted-array">
<h3>33. Search in Rotated Sorted Array<a class="headerlink" href="#search-in-rotated-sorted-array" title="Permalink to this heading">#</a></h3>
<p><strong>Difficulty:</strong> Medium</p>
<p><strong>Link to Problem:</strong> <a class="reference external" href="https://leetcode.com/problems/search-in-rotated-sorted-array/">To see the Search in Rotated Sorted Array problem on LeetCode, click here!</a></p>
<hr class="docutils" />
<p>There is an integer array <code class="docutils literal notranslate"><span class="pre">nums</span></code> sorted in ascending order (with <strong>distinct</strong> values).</p>
<p>Prior to being passed to your function, <code class="docutils literal notranslate"><span class="pre">nums</span></code> is <strong>possibly rotated</strong> at an unknown pivot index <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">(1</span> <span class="pre">&lt;=</span> <span class="pre">k</span> <span class="pre">&lt;</span> <span class="pre">nums.length)</span></code> such that the resulting array is <code class="docutils literal notranslate"><span class="pre">[nums[k],</span> <span class="pre">nums[k+1],</span> <span class="pre">...,</span> <span class="pre">nums[n-1],</span> <span class="pre">nums[0],</span> <span class="pre">nums[1],</span> <span class="pre">...,</span> <span class="pre">nums[k-1]]</span></code> (<strong>0-indexed</strong>). For example, <code class="docutils literal notranslate"><span class="pre">[0,1,2,4,5,6,7]</span></code> might be rotated at pivot index 3 and become <code class="docutils literal notranslate"><span class="pre">[4,5,6,7,0,1,2]</span></code>.</p>
<p>Given the array <code class="docutils literal notranslate"><span class="pre">nums</span></code> <strong>after</strong> the possible rotation and an integer <code class="docutils literal notranslate"><span class="pre">target</span></code>, return <em>the index of <code class="docutils literal notranslate"><span class="pre">target</span></code> if it is in <code class="docutils literal notranslate"><span class="pre">nums</span></code>, or <code class="docutils literal notranslate"><span class="pre">-1</span></code> if it is not in <code class="docutils literal notranslate"><span class="pre">nums</span></code>.</em></p>
<p>You must write an algorithm with <span class="math notranslate nohighlight">\(O(log\ n)\)</span> runtime complexity.</p>
<p><strong>Constraints:</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">&lt;=</span> <span class="pre">nums.length</span> <span class="pre">&lt;=</span> <span class="pre">5000</span></code></p></li>
<li><p><span class="math notranslate nohighlight">\(-10^4\)</span> &lt;= <code class="docutils literal notranslate"><span class="pre">nums[i]</span></code> &lt;= <span class="math notranslate nohighlight">\(10^4\)</span></p></li>
<li><p>All values of <code class="docutils literal notranslate"><span class="pre">nums</span></code> are <strong>unique</strong>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nums</span></code> is an ascending array that is possibly rotated.</p></li>
<li><p><span class="math notranslate nohighlight">\(-10^4\)</span> &lt;= <code class="docutils literal notranslate"><span class="pre">target</span></code> &lt;= <span class="math notranslate nohighlight">\(10^4\)</span></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="c1"># Find the pivot index using binary search</span>
    <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">:</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>

        <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]:</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span>

    <span class="n">pivot</span> <span class="o">=</span> <span class="n">left</span>
    <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="c1"># Determine which part of the array to search in</span>
    <span class="k">if</span> <span class="n">target</span> <span class="o">&gt;=</span> <span class="n">nums</span><span class="p">[</span><span class="n">pivot</span><span class="p">]</span> <span class="ow">and</span> <span class="n">target</span> <span class="o">&lt;=</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]:</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">pivot</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">pivot</span>

    <span class="c1"># Perform binary search to find the target</span>
    <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">:</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>

        <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mid</span>
        <span class="k">elif</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">:</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</pre></div>
</div>
</div>
</div>
<section id="explanation">
<h4>Explanation:<a class="headerlink" href="#explanation" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">search</span></code> function takes two arguments: <code class="docutils literal notranslate"><span class="pre">nums</span></code>, which is the rotated sorted array, and <code class="docutils literal notranslate"><span class="pre">target</span></code>, which is the value we want to find in the array.</p></li>
<li><p>We initialize two pointers, <code class="docutils literal notranslate"><span class="pre">left</span></code> and <code class="docutils literal notranslate"><span class="pre">right</span></code>, which represent the range in which we are going to perform binary search. Initially, <code class="docutils literal notranslate"><span class="pre">left</span></code> is set to 0, and <code class="docutils literal notranslate"><span class="pre">right</span></code> is set to the index of the last element in the array (<code class="docutils literal notranslate"><span class="pre">len(nums)</span> <span class="pre">-</span> <span class="pre">1</span></code>).</p></li>
<li><p>We start by finding the pivot index using binary search. The pivot index is the index at which the array is rotated. We use a <code class="docutils literal notranslate"><span class="pre">while</span></code> loop to continue the search until <code class="docutils literal notranslate"><span class="pre">left</span></code> is less than <code class="docutils literal notranslate"><span class="pre">right</span></code>.</p></li>
<li><p>Inside the loop, we calculate the middle index <code class="docutils literal notranslate"><span class="pre">mid</span></code> using integer division. We then compare the value at <code class="docutils literal notranslate"><span class="pre">mid</span></code> with the value at <code class="docutils literal notranslate"><span class="pre">right</span></code>. If <code class="docutils literal notranslate"><span class="pre">nums[mid]</span></code> is greater than <code class="docutils literal notranslate"><span class="pre">nums[right]</span></code>, it means the pivot point lies to the right of <code class="docutils literal notranslate"><span class="pre">mid</span></code>, so we update <code class="docutils literal notranslate"><span class="pre">left</span></code> to <code class="docutils literal notranslate"><span class="pre">mid</span> <span class="pre">+</span> <span class="pre">1</span></code>. Otherwise, the pivot point lies to the left of <code class="docutils literal notranslate"><span class="pre">mid</span></code>, so we update <code class="docutils literal notranslate"><span class="pre">right</span></code> to <code class="docutils literal notranslate"><span class="pre">mid</span></code>. This process continues until we find the pivot index.</p></li>
<li><p>After finding the pivot index, we have divided the array into two parts: one part is sorted in ascending order, and the other part is also sorted in ascending order but rotated. We need to determine which part of the array contains the target value.</p></li>
<li><p>We reset <code class="docutils literal notranslate"><span class="pre">left</span></code> and <code class="docutils literal notranslate"><span class="pre">right</span></code> pointers. If the target value is within the range <code class="docutils literal notranslate"><span class="pre">[nums[pivot],</span> <span class="pre">nums[right]]</span></code>, we set <code class="docutils literal notranslate"><span class="pre">left</span></code> to <code class="docutils literal notranslate"><span class="pre">pivot</span></code> (the start of the rotated part), indicating that we should search in the rotated part. Otherwise, we set <code class="docutils literal notranslate"><span class="pre">right</span></code> to <code class="docutils literal notranslate"><span class="pre">pivot</span></code> (the end of the sorted part), indicating that we should search in the sorted part.</p></li>
<li><p>We then perform binary search again within the chosen range (<code class="docutils literal notranslate"><span class="pre">left</span></code> to <code class="docutils literal notranslate"><span class="pre">right</span></code>) to find the target element. The binary search continues until <code class="docutils literal notranslate"><span class="pre">left</span></code> is less than or equal to <code class="docutils literal notranslate"><span class="pre">right</span></code>.</p></li>
<li><p>Inside the binary search loop, we calculate the middle index <code class="docutils literal notranslate"><span class="pre">mid</span></code> and compare <code class="docutils literal notranslate"><span class="pre">nums[mid]</span></code> with the target value. If they are equal, we return <code class="docutils literal notranslate"><span class="pre">mid</span></code> as the index of the target element. If <code class="docutils literal notranslate"><span class="pre">nums[mid]</span></code> is less than the target, we update <code class="docutils literal notranslate"><span class="pre">left</span></code> to <code class="docutils literal notranslate"><span class="pre">mid</span> <span class="pre">+</span> <span class="pre">1</span></code> to search in the right half. If <code class="docutils literal notranslate"><span class="pre">nums[mid]</span></code> is greater than the target, we update <code class="docutils literal notranslate"><span class="pre">right</span></code> to <code class="docutils literal notranslate"><span class="pre">mid</span> <span class="pre">-</span> <span class="pre">1</span></code> to search in the left half.</p></li>
<li><p>If we exit the binary search loop without finding the target, we return -1 to indicate that the target is not present in the array.</p></li>
</ol>
</section>
<section id="test-cases">
<h4>Test cases<a class="headerlink" href="#test-cases" title="Permalink to this heading">#</a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">nums1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="n">target1</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">result1</span> <span class="o">=</span> <span class="n">search</span><span class="p">(</span><span class="n">nums1</span><span class="p">,</span> <span class="n">target1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result1</span><span class="p">)</span> 
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>4
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 2:</span>
<span class="n">nums2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="n">target2</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">result2</span> <span class="o">=</span> <span class="n">search</span><span class="p">(</span><span class="n">nums2</span><span class="p">,</span> <span class="n">target2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result2</span><span class="p">)</span> 
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>-1
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 3:</span>
<span class="n">nums3</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">target3</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">result3</span> <span class="o">=</span> <span class="n">search</span><span class="p">(</span><span class="n">nums3</span><span class="p">,</span> <span class="n">target3</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result3</span><span class="p">)</span> 
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>-1
</pre></div>
</div>
</div>
</div>
<p>Let’s analyze the time and space complexity of the provided code:</p>
<p><strong>Time Complexity:</strong></p>
<ol class="arabic simple">
<li><p>Finding the pivot index using binary search takes <span class="math notranslate nohighlight">\(O(log\ n)\)</span> time, where ‘<span class="math notranslate nohighlight">\(n\)</span>’ is the number of elements in the array.</p></li>
<li><p>After finding the pivot index, performing binary search to find the target element also takes <span class="math notranslate nohighlight">\(O(log\ n)\)</span> time in the worst case.</p></li>
</ol>
<p>The dominant factor in the time complexity is the binary search, and since we perform two binary searches sequentially, the overall time complexity of the code is <span class="math notranslate nohighlight">\(O(log\ n)\)</span>.</p>
<p><strong>Space Complexity:</strong></p>
<p>The space complexity of the code is very minimal:</p>
<ol class="arabic simple">
<li><p>We use a constant amount of additional space for variables such as <code class="docutils literal notranslate"><span class="pre">left</span></code>, <code class="docutils literal notranslate"><span class="pre">right</span></code>, <code class="docutils literal notranslate"><span class="pre">pivot</span></code>, and <code class="docutils literal notranslate"><span class="pre">mid</span></code>. These variables do not depend on the input size, so they contribute <span class="math notranslate nohighlight">\(O(1)\)</span> space complexity.</p></li>
<li><p>The function does not use any additional data structures that scale with the input size.</p></li>
</ol>
<p>Therefore, the space complexity of the code is <span class="math notranslate nohighlight">\(O(1)\)</span>, which means it has a constant space complexity and does not depend on the size of the input array.</p>
<p><strong>In summary:</strong></p>
<ul class="simple">
<li><p>Time Complexity: <span class="math notranslate nohighlight">\(O(log\ n)\)</span></p></li>
<li><p>Space Complexity: <span class="math notranslate nohighlight">\(O(1)\)</span></p></li>
</ul>
</section>
<section id="challenging-exercises">
<h4>Challenging Exercises:<a class="headerlink" href="#challenging-exercises" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p><strong>Find Minimum Element in Rotated Sorted Array</strong>: Write an algorithm to find the minimum element in a rotated sorted array. This is a variation of the problem where you don’t need to search for a target value but instead find the smallest element.</p></li>
<li><p><strong>Search in a Circularly Sorted Array</strong>: Consider an array that is sorted in a circular manner (e.g., [4, 5, 6, 7, 0, 1, 2, 3]). Adapt the search algorithm to work for circularly sorted arrays while maintaining <span class="math notranslate nohighlight">\(O(log\ n)\)</span> complexity.</p></li>
</ol>
</section>
</section>
</div>
</section>
<span id="document-06. Linked List/README"></span><section class="tex2jax_ignore mathjax_ignore" id="linked-list-problems-blind-75-leetcode">
<h2>Linked List Problems - Blind 75 LeetCode<a class="headerlink" href="#linked-list-problems-blind-75-leetcode" title="Permalink to this heading">#</a></h2>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Problem Name</p></th>
<th class="head"><p>Difficulty</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/reverse-linked-list/">206. Reverse Linked List</a></p></td>
<td><p>Easy</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/merge-two-sorted-lists/">21. Merge Two Sorted Lists</a></p></td>
<td><p>Easy</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/reorder-list/">143. Reorder List</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/">19. Remove Nth Node From End of List</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/linked-list-cycle/">141. Linked List Cycle</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/merge-k-sorted-lists/">23. Merge K Sorted Lists</a></p></td>
<td><p>Hard</p></td>
</tr>
</tbody>
</table>
<section id="contribute">
<h3>Contribute<a class="headerlink" href="#contribute" title="Permalink to this heading">#</a></h3>
<p>If you have a better solution or want to add more problems to the collection, feel free to contribute. You can create a pull request or open an issue to discuss additions or improvements.</p>
</section>
<section id="resources">
<h3>Resources<a class="headerlink" href="#resources" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p><a class="reference external" href="https://leetcode.com/">LeetCode</a>: The official LeetCode website.</p></li>
<li><p><a class="reference external" href="https://leetcode.com/discuss/">LeetCode Discuss</a>: LeetCode’s discussion forum for each problem. You can find helpful hints and discussions here.</p></li>
</ul>
<p>Happy coding!</p>
</section>
<div class="toctree-wrapper compound">
<span id="document-06. Linked List/141. Linked List Cycle"></span><section class="tex2jax_ignore mathjax_ignore" id="linked-list-cycle">
<h3>141. Linked List Cycle<a class="headerlink" href="#linked-list-cycle" title="Permalink to this heading">#</a></h3>
<p><strong>Difficulty:</strong> Easy</p>
<p><strong>Link to Problem:</strong> <a class="reference external" href="https://leetcode.com/problems/linked-list-cycle/">To see the Linked List Cycle problem on LeetCode, click here!</a></p>
<hr class="docutils" />
<p>Given <code class="docutils literal notranslate"><span class="pre">head</span></code>, the head of a linked list, determine if the linked list has a cycle in it.</p>
<p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the <code class="docutils literal notranslate"><span class="pre">next</span></code> pointer. Internally, <code class="docutils literal notranslate"><span class="pre">pos</span></code> is used to denote the index of the node that tail’s <code class="docutils literal notranslate"><span class="pre">next</span></code> pointer is connected to. <strong>Note that <code class="docutils literal notranslate"><span class="pre">pos</span></code> is not passed as a parameter.</strong></p>
<p>Return <code class="docutils literal notranslate"><span class="pre">true</span></code> if there is a cycle in the linked list. Otherwise, return <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
<p><strong>Constraints:</strong></p>
<ul class="simple">
<li><p>The number of the nodes in the list is in the range <span class="math notranslate nohighlight">\([0, 10^4]\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(-10^5\)</span> &lt;= Node.val &lt;= <span class="math notranslate nohighlight">\(10^5\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pos</span></code> is <code class="docutils literal notranslate"><span class="pre">-1</span></code> or a <strong>valid index</strong> in the linked-list.</p></li>
</ul>
<p><strong>Follow up:</strong> Can you solve it using <span class="math notranslate nohighlight">\(O(1)\)</span> (i.e. constant) memory?</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Definition for singly-linked list.</span>
<span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="kc">None</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">hasCycle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="n">ListNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">head</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        
        <span class="n">slow</span> <span class="o">=</span> <span class="n">head</span>
        <span class="n">fast</span> <span class="o">=</span> <span class="n">head</span>
        
        <span class="k">while</span> <span class="n">fast</span> <span class="ow">and</span> <span class="n">fast</span><span class="o">.</span><span class="n">next</span><span class="p">:</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="n">next</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">next</span>
            
            <span class="k">if</span> <span class="n">slow</span> <span class="o">==</span> <span class="n">fast</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
        
        <span class="k">return</span> <span class="kc">False</span>
</pre></div>
</div>
</div>
</div>
<section id="explanation">
<h4>Explanation:<a class="headerlink" href="#explanation" title="Permalink to this heading">#</a></h4>
<p>The given code defines a class <code class="docutils literal notranslate"><span class="pre">Solution</span></code> with a method <code class="docutils literal notranslate"><span class="pre">hasCycle</span></code> for determining if a linked list has a cycle.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">ListNode</span></code> class represents nodes in the linked list, where each node has a <code class="docutils literal notranslate"><span class="pre">val</span></code> (a value associated with the node) and a <code class="docutils literal notranslate"><span class="pre">next</span></code> attribute (a reference to the next node in the list).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">hasCycle</span></code> method takes the <code class="docutils literal notranslate"><span class="pre">head</span></code> of a linked list as input and returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if there is a cycle in the linked list, and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise. It uses two pointers, <code class="docutils literal notranslate"><span class="pre">slow</span></code> and <code class="docutils literal notranslate"><span class="pre">fast</span></code>, to traverse the linked list. If there is a cycle, the <code class="docutils literal notranslate"><span class="pre">fast</span></code> pointer will eventually catch up to the <code class="docutils literal notranslate"><span class="pre">slow</span></code> pointer.</p>
<p>The algorithm works as follows:</p>
<ol class="arabic simple">
<li><p>It checks if the input <code class="docutils literal notranslate"><span class="pre">head</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code> (an empty list). If it is, the method returns <code class="docutils literal notranslate"><span class="pre">False</span></code> because an empty list can’t have a cycle.</p></li>
<li><p>Two pointers, <code class="docutils literal notranslate"><span class="pre">slow</span></code> and <code class="docutils literal notranslate"><span class="pre">fast</span></code>, initially point to the <code class="docutils literal notranslate"><span class="pre">head</span></code> of the list.</p></li>
<li><p>The code enters a <code class="docutils literal notranslate"><span class="pre">while</span></code> loop where <code class="docutils literal notranslate"><span class="pre">fast</span></code> moves two steps at a time, and <code class="docutils literal notranslate"><span class="pre">slow</span></code> moves one step at a time.</p></li>
<li><p>If there is a cycle, <code class="docutils literal notranslate"><span class="pre">fast</span></code> will eventually catch up to <code class="docutils literal notranslate"><span class="pre">slow</span></code>, and the method returns <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p></li>
<li><p>If the loop completes without finding a cycle, the method returns <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Helper function to create a linked list with a cycle</span>
<span class="k">def</span> <span class="nf">create_linked_list_with_cycle</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
    <span class="n">dummy</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">()</span>
    <span class="n">current</span> <span class="o">=</span> <span class="n">dummy</span>
    <span class="n">cycle_node</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
        <span class="n">current</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">next</span>
        
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">pos</span><span class="p">:</span>
            <span class="n">cycle_node</span> <span class="o">=</span> <span class="n">current</span>
    
    <span class="k">if</span> <span class="n">cycle_node</span><span class="p">:</span>
        <span class="n">current</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">cycle_node</span>
    
    <span class="k">return</span> <span class="n">dummy</span><span class="o">.</span><span class="n">next</span>
</pre></div>
</div>
</div>
</div>
<p>This helper function is designed to create a linked list with a cycle for testing purposes. It takes two arguments:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">values</span></code>: A list of values representing the nodes in the linked list.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pos</span></code>: An integer representing the index of the node where the cycle begins.</p></li>
</ol>
<p>Here’s how the function works:</p>
<ul class="simple">
<li><p>It starts by creating an empty <code class="docutils literal notranslate"><span class="pre">ListNode</span></code> called <code class="docutils literal notranslate"><span class="pre">dummy</span></code>. This <code class="docutils literal notranslate"><span class="pre">dummy</span></code> node is used to simplify the creation of the linked list.</p></li>
<li><p>It initializes a <code class="docutils literal notranslate"><span class="pre">current</span></code> pointer to the <code class="docutils literal notranslate"><span class="pre">dummy</span></code> node. This pointer will be used to traverse the linked list.</p></li>
<li><p>It initializes a <code class="docutils literal notranslate"><span class="pre">cycle_node</span></code> variable to <code class="docutils literal notranslate"><span class="pre">None</span></code>. This variable will hold the reference to the node where the cycle begins, if any.</p></li>
<li><p>It then iterates through the <code class="docutils literal notranslate"><span class="pre">values</span></code> list, creating a new <code class="docutils literal notranslate"><span class="pre">ListNode</span></code> for each value and appending it to the linked list.</p></li>
<li><p>Inside the loop, it checks if the current index <code class="docutils literal notranslate"><span class="pre">i</span></code> is equal to the specified <code class="docutils literal notranslate"><span class="pre">pos</span></code>. If they match, it sets <code class="docutils literal notranslate"><span class="pre">cycle_node</span></code> to the current node. This simulates the creation of a cycle in the linked list.</p></li>
<li><p>After the loop, if <code class="docutils literal notranslate"><span class="pre">cycle_node</span></code> is not <code class="docutils literal notranslate"><span class="pre">None</span></code> (indicating a cycle should be created), it connects the last node in the linked list to <code class="docutils literal notranslate"><span class="pre">cycle_node</span></code>, effectively creating a cycle.</p></li>
<li><p>Finally, it returns the reference to the first node of the linked list (not the <code class="docutils literal notranslate"><span class="pre">dummy</span></code> node).</p></li>
</ul>
<p>This helper function allows you to easily create test cases where you can specify the values for the linked list and the position where the cycle starts. It’s particularly useful for testing the code’s ability to detect cycles in linked lists.</p>
</section>
<section id="test-cases">
<h4>Test cases<a class="headerlink" href="#test-cases" title="Permalink to this heading">#</a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">### Example 1</span>
<span class="n">head</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span>
<span class="n">pos</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">head</span> <span class="o">=</span> <span class="n">create_linked_list_with_cycle</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
<span class="n">solution</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">()</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">solution</span><span class="o">.</span><span class="n">hasCycle</span><span class="p">(</span><span class="n">head</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">### Example 2</span>
<span class="n">head</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span>

<span class="n">head</span> <span class="o">=</span> <span class="n">create_linked_list_with_cycle</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
<span class="n">solution</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">()</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">solution</span><span class="o">.</span><span class="n">hasCycle</span><span class="p">(</span><span class="n">head</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">### Example 3</span>
<span class="n">head</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">pos</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

<span class="n">head</span> <span class="o">=</span> <span class="n">create_linked_list_with_cycle</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
<span class="n">solution</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">()</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">solution</span><span class="o">.</span><span class="n">hasCycle</span><span class="p">(</span><span class="n">head</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>False
</pre></div>
</div>
</div>
</div>
<p>Let’s discuss the time and space complexity of the code for detecting a cycle in a linked list:</p>
<p><strong>Time Complexity:</strong></p>
<p>The time complexity of this code is <span class="math notranslate nohighlight">\(O(n)\)</span>, where “<span class="math notranslate nohighlight">\(n\)</span>” is the number of nodes in the linked list.</p>
<p>The reason for this is that both the <code class="docutils literal notranslate"><span class="pre">slow</span></code> and <code class="docutils literal notranslate"><span class="pre">fast</span></code> pointers traverse the linked list, and they move at different speeds. In the worst case, when there is no cycle, the <code class="docutils literal notranslate"><span class="pre">fast</span></code> pointer will reach the end of the list after going through approximately <span class="math notranslate nohighlight">\(n/2\)</span> nodes. In the case of a cycle, it may take some extra iterations for the <code class="docutils literal notranslate"><span class="pre">fast</span></code> pointer to catch up to the <code class="docutils literal notranslate"><span class="pre">slow</span></code> pointer. However, the total number of iterations is still proportional to the number of nodes in the linked list, making it <span class="math notranslate nohighlight">\(O(n)\)</span>.</p>
<p><strong>Space Complexity:</strong></p>
<p>The space complexity of this code is <span class="math notranslate nohighlight">\(O(1)\)</span>, which means it uses constant space.</p>
<p>The reason for this is that regardless of the size of the linked list, the code only uses two additional pointers (<code class="docutils literal notranslate"><span class="pre">slow</span></code> and <code class="docutils literal notranslate"><span class="pre">fast</span></code>) to traverse the list. These pointers do not depend on the size of the input linked list, so the space complexity remains constant.</p>
<p><strong>In summary</strong>, this code efficiently detects cycles in a linked list with a time complexity of <span class="math notranslate nohighlight">\(O(n)\)</span> and a space complexity of <span class="math notranslate nohighlight">\(O(1)\)</span>. It is an example of an algorithm that solves a complex problem with minimal memory usage.</p>
</section>
</section>
<span id="document-06. Linked List/143. Reorder List"></span><section class="tex2jax_ignore mathjax_ignore" id="reorder-list">
<h3>143. Reorder List<a class="headerlink" href="#reorder-list" title="Permalink to this heading">#</a></h3>
<p><strong>Difficulty:</strong> Medium</p>
<p><strong>Link to Problem:</strong> <a class="reference external" href="https://leetcode.com/problems/reorder-list/">To see the Reorder List problem on LeetCode, click here!</a></p>
<hr class="docutils" />
<p>You are given the head of a singly linked-list. The list can be represented as:</p>
<p><span class="math notranslate nohighlight">\(L_0 → L_1 → … → L_{n - 1} → L_n\)</span></p>
<p>Reorder the list to be on the following form:</p>
<p><span class="math notranslate nohighlight">\(L_0 → L_n → L_1 → L_{n - 1} → L_2 → L_{n - 2} → …\)</span></p>
<p>You may not modify the values in the list’s nodes. Only nodes themselves may be changed.</p>
<p><strong>Constraints:</strong></p>
<ul class="simple">
<li><p>The number of nodes in the list is in the range <span class="math notranslate nohighlight">\([1, 5 * 10^4]\)</span>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">&lt;=</span> <span class="pre">Node.val</span> <span class="pre">&lt;=</span> <span class="pre">1000</span></code></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">next</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="nb">next</span>

<span class="k">def</span> <span class="nf">reorderList</span><span class="p">(</span><span class="n">head</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">head</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">head</span><span class="o">.</span><span class="n">next</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">head</span>

    <span class="c1"># Step 1: Find the middle of the linked list</span>
    <span class="n">slow</span><span class="p">,</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="p">,</span> <span class="n">head</span>
    <span class="k">while</span> <span class="n">fast</span><span class="o">.</span><span class="n">next</span> <span class="ow">and</span> <span class="n">fast</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">next</span><span class="p">:</span>
        <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="n">next</span>
        <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">next</span>

    <span class="c1"># Split the list into two halves</span>
    <span class="n">first_half</span> <span class="o">=</span> <span class="n">head</span>
    <span class="n">second_half</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="n">next</span>
    <span class="n">slow</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Step 2: Reverse the second half of the linked list</span>
    <span class="n">prev</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">current</span> <span class="o">=</span> <span class="n">second_half</span>
    <span class="k">while</span> <span class="n">current</span><span class="p">:</span>
        <span class="n">next_node</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">next</span>
        <span class="n">current</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">prev</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">current</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">next_node</span>
    <span class="n">second_half</span> <span class="o">=</span> <span class="n">prev</span>

    <span class="c1"># Step 3: Merge the first and reversed second halves alternately</span>
    <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">first_half</span><span class="p">,</span> <span class="n">second_half</span>
    <span class="k">while</span> <span class="n">p2</span><span class="p">:</span>
        <span class="n">next_p1</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="n">next</span>
        <span class="n">next_p2</span> <span class="o">=</span> <span class="n">p2</span><span class="o">.</span><span class="n">next</span>
        <span class="n">p1</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">p2</span>
        <span class="n">p2</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">next_p1</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="n">next_p1</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="n">next_p2</span>

    <span class="k">return</span> <span class="n">head</span>
</pre></div>
</div>
</div>
</div>
<section id="explanation">
<h4>Explanation:<a class="headerlink" href="#explanation" title="Permalink to this heading">#</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">reorderList</span></code> function is designed to reorder a singly linked list following the specific pattern described in the problem statement. Here’s a detailed explanation of how the function works:</p>
<ol class="arabic simple">
<li><p><strong>Base Cases Handling</strong>:</p>
<ul class="simple">
<li><p>The function first checks if the input linked list is empty (<code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">head</span></code>) or contains only one element (<code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">head.next</span></code>). If either of these conditions is met, the list cannot be reordered, so the function returns the original list as-is.</p></li>
</ul>
</li>
<li><p><strong>Finding the Middle of the Linked List</strong>:</p>
<ul class="simple">
<li><p>To reorder the list, we first need to find the middle point so that we can split the list into two halves. This is done using two pointers, <code class="docutils literal notranslate"><span class="pre">slow</span></code> and <code class="docutils literal notranslate"><span class="pre">fast</span></code>, initialized to the head of the list.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">slow</span></code> moves one step at a time while <code class="docutils literal notranslate"><span class="pre">fast</span></code> moves two steps at a time. When <code class="docutils literal notranslate"><span class="pre">fast</span></code> reaches the end of the list or the second-to-last node, <code class="docutils literal notranslate"><span class="pre">slow</span></code> will be at the middle node.</p></li>
</ul>
</li>
<li><p><strong>Splitting the List</strong>:</p>
<ul class="simple">
<li><p>After finding the middle node, we split the list into two halves:</p>
<ul>
<li><p>The first half, <code class="docutils literal notranslate"><span class="pre">first_half</span></code>, contains nodes from the beginning up to the middle.</p></li>
<li><p>The second half, <code class="docutils literal notranslate"><span class="pre">second_half</span></code>, contains nodes from the middle to the end.</p></li>
</ul>
</li>
<li><p>To split the list, we set the <code class="docutils literal notranslate"><span class="pre">next</span></code> pointer of the node before the middle node to <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p></li>
</ul>
</li>
<li><p><strong>Reversing the Second Half</strong>:</p>
<ul class="simple">
<li><p>We reverse the second half of the linked list using the <code class="docutils literal notranslate"><span class="pre">prev</span></code>, <code class="docutils literal notranslate"><span class="pre">current</span></code>, and <code class="docutils literal notranslate"><span class="pre">next_node</span></code> pointers.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">prev</span></code> is initially <code class="docutils literal notranslate"><span class="pre">None</span></code>, and we iterate through the second half. For each node, we:</p>
<ul>
<li><p>Set the <code class="docutils literal notranslate"><span class="pre">next</span></code> of the current node to <code class="docutils literal notranslate"><span class="pre">prev</span></code>, effectively reversing the next pointer direction.</p></li>
<li><p>Update <code class="docutils literal notranslate"><span class="pre">prev</span></code> to the current node.</p></li>
<li><p>Move to the next node using the <code class="docutils literal notranslate"><span class="pre">next_node</span></code>.</p></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Merging the Two Halves Alternately</strong>:</p>
<ul class="simple">
<li><p>We now have two linked lists: <code class="docutils literal notranslate"><span class="pre">first_half</span></code> and the reversed <code class="docutils literal notranslate"><span class="pre">second_half</span></code>.</p></li>
<li><p>We merge these two lists alternately by adjusting the <code class="docutils literal notranslate"><span class="pre">next</span></code> pointers of the nodes.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">p1</span></code> and <code class="docutils literal notranslate"><span class="pre">p2</span></code> are pointers to the current nodes in <code class="docutils literal notranslate"><span class="pre">first_half</span></code> and <code class="docutils literal notranslate"><span class="pre">second_half</span></code>, respectively.</p></li>
<li><p>We iterate through both lists while reordering nodes:</p>
<ul>
<li><p>Set the <code class="docutils literal notranslate"><span class="pre">next</span></code> of <code class="docutils literal notranslate"><span class="pre">p1</span></code> to <code class="docutils literal notranslate"><span class="pre">p2</span></code> to link a node from the first half to a node from the reversed second half.</p></li>
<li><p>Update <code class="docutils literal notranslate"><span class="pre">p1</span></code> and <code class="docutils literal notranslate"><span class="pre">p2</span></code> to their respective next nodes.</p></li>
<li><p>Repeat this process until we have processed all nodes in both halves.</p></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Returning the Reordered List</strong>:</p>
<ul class="simple">
<li><p>After the merging process is complete, the linked list is reordered as specified.</p></li>
<li><p>The function returns the <code class="docutils literal notranslate"><span class="pre">head</span></code> of the reordered list.</p></li>
</ul>
</li>
</ol>
<p>The overall result is a singly linked list that has been reordered according to the given pattern. The time complexity of this algorithm is O(N), where N is the number of nodes in the linked list, as we traverse the list once to find the middle, once to reverse the second half, and once to merge the two halves.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Helper function to print the linked list</span>
<span class="k">def</span> <span class="nf">printLinkedList</span><span class="p">(</span><span class="n">head</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">head</span><span class="p">:</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">head</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="n">next</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s explain the helper functions:
<strong>printLinkedList Function</strong>:</p>
<ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">printLinkedList</span></code> function takes the <code class="docutils literal notranslate"><span class="pre">head</span></code> of a linked list as input and returns a list of values representing the nodes in the linked list.</p></li>
<li><p>Inside the function, a <code class="docutils literal notranslate"><span class="pre">result</span></code> list is initialized to store the values of the linked list nodes.</p></li>
<li><p>The function then iterates through the linked list starting from the <code class="docutils literal notranslate"><span class="pre">head</span></code> node and appends the <code class="docutils literal notranslate"><span class="pre">val</span></code> attribute of each node to the <code class="docutils literal notranslate"><span class="pre">result</span></code> list.</p></li>
<li><p>As it iterates through the list, it moves to the next node using the <code class="docutils literal notranslate"><span class="pre">next</span></code> attribute of each node.</p></li>
<li><p>Finally, the function returns the <code class="docutils literal notranslate"><span class="pre">result</span></code> list containing the values of the linked list nodes in the order they appear in the linked list.</p></li>
</ul>
<p>This function is useful for debugging and displaying the contents of a linked list. It allows you to easily convert a linked list into a regular Python list for visualization and testing purposes.</p>
</section>
<section id="test-cases">
<h4>Test cases<a class="headerlink" href="#test-cases" title="Permalink to this heading">#</a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 1</span>
<span class="n">head1</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">4</span><span class="p">))))</span>
<span class="n">reorderList</span><span class="p">(</span><span class="n">head1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">printLinkedList</span><span class="p">(</span><span class="n">head1</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[1, 4, 2, 3]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 2</span>
<span class="n">head2</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">5</span><span class="p">)))))</span>
<span class="n">reorderList</span><span class="p">(</span><span class="n">head2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">printLinkedList</span><span class="p">(</span><span class="n">head2</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[1, 5, 2, 4, 3]
</pre></div>
</div>
</div>
</div>
<p>Let’s analyze the time and space complexity of the <code class="docutils literal notranslate"><span class="pre">reorderList</span></code> function:</p>
<p><strong>Time Complexity</strong>:</p>
<ol class="arabic simple">
<li><p><strong>Finding the Middle of the Linked List</strong>: In this step, we use two pointers, one moving one step at a time (<code class="docutils literal notranslate"><span class="pre">slow</span></code>) and the other moving two steps at a time (<code class="docutils literal notranslate"><span class="pre">fast</span></code>). This process takes <span class="math notranslate nohighlight">\(O(N/2)\)</span> time, where <span class="math notranslate nohighlight">\(N\)</span> is the number of nodes in the linked list.</p></li>
<li><p><strong>Splitting the List</strong>: After finding the middle, we split the list into two halves by setting the <code class="docutils literal notranslate"><span class="pre">next</span></code> pointer of the node before the middle node to <code class="docutils literal notranslate"><span class="pre">None</span></code>. This step takes <span class="math notranslate nohighlight">\(O(1)\)</span> time.</p></li>
<li><p><strong>Reversing the Second Half</strong>: We reverse the second half of the linked list using a while loop that iterates through the second half of the list once. Therefore, this step also takes <span class="math notranslate nohighlight">\(O(N/2)\)</span> time.</p></li>
<li><p><strong>Merging the Two Halves Alternately</strong>: In this step, we merge the two halves alternately by adjusting the <code class="docutils literal notranslate"><span class="pre">next</span></code> pointers of the nodes. We iterate through both halves once, so this step takes <span class="math notranslate nohighlight">\(O(N/2)\)</span> time.</p></li>
</ol>
<p>Overall, the time complexity of the <code class="docutils literal notranslate"><span class="pre">reorderList</span></code> function is dominated by the steps involving reversing and merging the two halves, both of which take <span class="math notranslate nohighlight">\(O(N/2)\)</span> time. Therefore, the total time complexity is <span class="math notranslate nohighlight">\(O(N)\)</span>.</p>
<p><strong>Space Complexity</strong>:
The space complexity of the <code class="docutils literal notranslate"><span class="pre">reorderList</span></code> function is primarily determined by the variables and data structures used within the function. Let’s break down the space complexity components:</p>
<ol class="arabic simple">
<li><p><strong>Constant Space Variables</strong>: The variables <code class="docutils literal notranslate"><span class="pre">slow</span></code>, <code class="docutils literal notranslate"><span class="pre">fast</span></code>, <code class="docutils literal notranslate"><span class="pre">prev</span></code>, <code class="docutils literal notranslate"><span class="pre">current</span></code>, <code class="docutils literal notranslate"><span class="pre">next_node</span></code>, <code class="docutils literal notranslate"><span class="pre">p1</span></code>, and <code class="docutils literal notranslate"><span class="pre">p2</span></code> are used to traverse and manipulate the linked list. These variables occupy constant space, regardless of the input size. Therefore, they contribute <span class="math notranslate nohighlight">\(O(1)\)</span> to the space complexity.</p></li>
<li><p><strong>Split Linked Lists</strong>: In the splitting step, we create two new linked list segments (<code class="docutils literal notranslate"><span class="pre">first_half</span></code> and <code class="docutils literal notranslate"><span class="pre">second_half</span></code>) that store references to nodes from the original linked list. These segments occupy space proportional to half of the input list, <span class="math notranslate nohighlight">\(O(N/2)\)</span>.</p></li>
<li><p><strong>Reversed Second Half</strong>: During the reversal step, we reverse the second half of the linked list in-place without creating any additional data structures. Therefore, it doesn’t contribute to additional space complexity.</p></li>
<li><p><strong>Overall</strong>: Combining the above components, the total space complexity is <span class="math notranslate nohighlight">\(O(N/2)\)</span>, which simplifies to <span class="math notranslate nohighlight">\(O(N)\)</span> in terms of space complexity.</p></li>
</ol>
<p><strong>In summary</strong>, the <code class="docutils literal notranslate"><span class="pre">reorderList</span></code> function has a time complexity of <span class="math notranslate nohighlight">\(O(N)\)</span> and a space complexity of <span class="math notranslate nohighlight">\(O(N)\)</span> due to the creation of two new linked list segments while splitting the list. The constant space variables used for traversal do not significantly impact the overall space complexity.</p>
</section>
<section id="challenging-exercises">
<h4>Challenging Exercises:<a class="headerlink" href="#challenging-exercises" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p><strong>Reorder by K Elements:</strong> Generalize the reorderList function to reorder the list in a different pattern, where you reorder the list by <span class="math notranslate nohighlight">\(K\)</span> elements at a time. For example, for <span class="math notranslate nohighlight">\(K=3\)</span>, you would reorder it as (<span class="math notranslate nohighlight">\(L_0 → L_1 → L_2 → L_n → L_{n-1} → L_{n-2} → ...\)</span>).
You may need to handle cases where the number of nodes is not a multiple of <span class="math notranslate nohighlight">\(K\)</span>.</p></li>
<li><p><strong>Reorder by Odd and Even Nodes:</strong> Modify the reorderList function to reorder the list in a pattern where odd-indexed nodes (1-based index) come before even-indexed nodes. For example, (<span class="math notranslate nohighlight">\(L_0 → L_n → L_1 → L_{n-1} → L_2 → L_{n-2} → ...\)</span>).</p></li>
</ol>
</section>
</section>
<span id="document-06. Linked List/19. Remove Nth Node From End of List"></span><section class="tex2jax_ignore mathjax_ignore" id="remove-nth-node-from-end-of-list">
<h3>19. Remove Nth Node From End of List<a class="headerlink" href="#remove-nth-node-from-end-of-list" title="Permalink to this heading">#</a></h3>
<p><strong>Difficulty:</strong> Medium</p>
<p><strong>Link to Problem:</strong> <a class="reference external" href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/">To see the Remove Nth Node From End of List problem on LeetCode, click here!</a></p>
<hr class="docutils" />
<p>Given the head of a linked list, remove the <span class="math notranslate nohighlight">\(n^{th}\)</span> node from the end of the list and return its head.</p>
<p><strong>Constraints:</strong></p>
<ul class="simple">
<li><p>The number of nodes in the list is <code class="docutils literal notranslate"><span class="pre">sz</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">&lt;=</span> <span class="pre">sz</span> <span class="pre">&lt;=</span> <span class="pre">30</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">Node.val</span> <span class="pre">&lt;=</span> <span class="pre">100</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">&lt;=</span> <span class="pre">n</span> <span class="pre">&lt;=</span> <span class="pre">sz</span></code></p></li>
</ul>
<p><strong>Follow up:</strong> Could you do this in one pass?</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">next</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="nb">next</span>

<span class="k">def</span> <span class="nf">removeNthFromEnd</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="c1"># Create a dummy node to handle the case of removing the head node.</span>
    <span class="n">dummy</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">dummy</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span>
    <span class="n">first</span> <span class="o">=</span> <span class="n">dummy</span>
    <span class="n">second</span> <span class="o">=</span> <span class="n">dummy</span>
    
    <span class="c1"># Advance the first pointer by n+1 nodes.</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">.</span><span class="n">next</span>
    
    <span class="c1"># Move both pointers simultaneously until first reaches the end.</span>
    <span class="k">while</span> <span class="n">first</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">.</span><span class="n">next</span>
        <span class="n">second</span> <span class="o">=</span> <span class="n">second</span><span class="o">.</span><span class="n">next</span>
    
    <span class="c1"># Remove the nth node by updating the next pointer of the previous node.</span>
    <span class="n">second</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">second</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">next</span>
    
    <span class="k">return</span> <span class="n">dummy</span><span class="o">.</span><span class="n">next</span>  <span class="c1"># Return the modified head of the linked list</span>
</pre></div>
</div>
</div>
</div>
<section id="explanation">
<h4>Explanation:<a class="headerlink" href="#explanation" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p>We start by defining a <code class="docutils literal notranslate"><span class="pre">ListNode</span></code> class to represent individual nodes in a linked list. Each node has two attributes: <code class="docutils literal notranslate"><span class="pre">val</span></code> (the value of the node) and <code class="docutils literal notranslate"><span class="pre">next</span></code> (a reference to the next node in the list).</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">removeNthFromEnd</span></code> function takes the head of a linked list (<code class="docutils literal notranslate"><span class="pre">head</span></code>) and the value <code class="docutils literal notranslate"><span class="pre">n</span></code>, which represents the position from the end of the list of the node to be removed. It returns the modified head of the linked list after the removal.</p></li>
<li><p>We create a dummy node (<code class="docutils literal notranslate"><span class="pre">dummy</span></code>) at the beginning of the list. This dummy node simplifies the code by handling cases where the head of the list needs to be removed.</p></li>
<li><p>We initialize two pointers, <code class="docutils literal notranslate"><span class="pre">first</span></code> and <code class="docutils literal notranslate"><span class="pre">second</span></code>, both initially pointing to the dummy node.</p></li>
<li><p>To advance the <code class="docutils literal notranslate"><span class="pre">first</span></code> pointer by <code class="docutils literal notranslate"><span class="pre">n+1</span></code> nodes, we use a <code class="docutils literal notranslate"><span class="pre">for</span></code> loop. This positions the <code class="docutils literal notranslate"><span class="pre">first</span></code> pointer <code class="docutils literal notranslate"><span class="pre">n</span></code> nodes ahead of the <code class="docutils literal notranslate"><span class="pre">second</span></code> pointer.</p></li>
<li><p>We then move both <code class="docutils literal notranslate"><span class="pre">first</span></code> and <code class="docutils literal notranslate"><span class="pre">second</span></code> pointers simultaneously until <code class="docutils literal notranslate"><span class="pre">first</span></code> reaches the end of the list. This ensures that the <code class="docutils literal notranslate"><span class="pre">second</span></code> pointer ends up pointing to the node that needs to be removed.</p></li>
<li><p>To remove the nth node from the end, we update the <code class="docutils literal notranslate"><span class="pre">next</span></code> pointer of the node pointed to by the <code class="docutils literal notranslate"><span class="pre">second</span></code> pointer to skip over the node to be removed.</p></li>
<li><p>Finally, we return <code class="docutils literal notranslate"><span class="pre">dummy.next</span></code>, which is the modified head of the linked list without the removed node.</p></li>
<li><p>Additionally, there are two helper functions:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">createLinkedList(values)</span></code> creates a linked list from a list of values.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">convertToList(head)</span></code> converts a linked list back into a list of values.</p></li>
</ul>
</li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Helper function to create a linked list from a list of values.</span>
<span class="k">def</span> <span class="nf">createLinkedList</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">values</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="n">head</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">current</span> <span class="o">=</span> <span class="n">head</span>
    <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="n">current</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">next</span>
    <span class="k">return</span> <span class="n">head</span>

<span class="c1"># Helper function to convert a linked list to a list of values.</span>
<span class="k">def</span> <span class="nf">convertToList</span><span class="p">(</span><span class="n">head</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">current</span> <span class="o">=</span> <span class="n">head</span>
    <span class="k">while</span> <span class="n">current</span><span class="p">:</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">next</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s explain the two helper functions:</p>
<ol class="arabic">
<li><p><code class="docutils literal notranslate"><span class="pre">createLinkedList(values)</span></code>: This function creates a linked list from a list of values.</p>
<ul class="simple">
<li><p>Input: <code class="docutils literal notranslate"><span class="pre">values</span></code> is a list containing values that you want to insert into the linked list.</p></li>
<li><p>Output: The function returns the head of the created linked list.</p></li>
</ul>
<p>Explanation:</p>
<ul class="simple">
<li><p>The function starts by checking if the <code class="docutils literal notranslate"><span class="pre">values</span></code> list is empty. If it is, it returns <code class="docutils literal notranslate"><span class="pre">None</span></code> to indicate an empty linked list.</p></li>
<li><p>If the <code class="docutils literal notranslate"><span class="pre">values</span></code> list is not empty, it creates the first node of the linked list with the value from the first element of <code class="docutils literal notranslate"><span class="pre">values</span></code>.</p></li>
<li><p>It then iterates through the remaining elements of <code class="docutils literal notranslate"><span class="pre">values</span></code> and creates new nodes for each value, connecting them together using the <code class="docutils literal notranslate"><span class="pre">next</span></code> attribute to form a linked list.</p></li>
<li><p>Finally, it returns the head of the linked list, which is the first node created.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">convertToList(head)</span></code>: This function converts a linked list into a list of values.</p>
<ul class="simple">
<li><p>Input: <code class="docutils literal notranslate"><span class="pre">head</span></code> is the head node of the linked list that you want to convert.</p></li>
<li><p>Output: The function returns a list containing the values of the nodes in the linked list in order.</p></li>
</ul>
<p>Explanation:</p>
<ul class="simple">
<li><p>The function starts by initializing an empty list, <code class="docutils literal notranslate"><span class="pre">result</span></code>, to store the values of the linked list nodes.</p></li>
<li><p>It then iterates through the linked list starting from the <code class="docutils literal notranslate"><span class="pre">head</span></code> node and appends the <code class="docutils literal notranslate"><span class="pre">val</span></code> attribute of each node to the <code class="docutils literal notranslate"><span class="pre">result</span></code> list.</p></li>
<li><p>The iteration continues until it reaches the end of the linked list (i.e., the <code class="docutils literal notranslate"><span class="pre">next</span></code> attribute of the current node becomes <code class="docutils literal notranslate"><span class="pre">None</span></code>).</p></li>
<li><p>After the iteration is complete, the function returns the <code class="docutils literal notranslate"><span class="pre">result</span></code> list, which now contains the values of all the nodes in the linked list in the same order as they appear in the linked list.</p></li>
</ul>
</li>
</ol>
<p>These helper functions are useful for creating linked lists from lists of values and converting linked lists back into lists of values, making it easier to work with linked list examples and test cases in a more familiar list format.</p>
</section>
<section id="test-cases">
<h4>Test cases<a class="headerlink" href="#test-cases" title="Permalink to this heading">#</a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 1</span>
<span class="n">head1</span> <span class="o">=</span> <span class="n">createLinkedList</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="n">n1</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">new_head1</span> <span class="o">=</span> <span class="n">removeNthFromEnd</span><span class="p">(</span><span class="n">head1</span><span class="p">,</span> <span class="n">n1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">convertToList</span><span class="p">(</span><span class="n">new_head1</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[1, 2, 3, 5]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 2</span>
<span class="n">head2</span> <span class="o">=</span> <span class="n">createLinkedList</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="n">n2</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">new_head2</span> <span class="o">=</span> <span class="n">removeNthFromEnd</span><span class="p">(</span><span class="n">head2</span><span class="p">,</span> <span class="n">n2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">convertToList</span><span class="p">(</span><span class="n">new_head2</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 3</span>
<span class="n">head3</span> <span class="o">=</span> <span class="n">createLinkedList</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="n">n3</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">new_head3</span> <span class="o">=</span> <span class="n">removeNthFromEnd</span><span class="p">(</span><span class="n">head3</span><span class="p">,</span> <span class="n">n3</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">convertToList</span><span class="p">(</span><span class="n">new_head3</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[1]
</pre></div>
</div>
</div>
</div>
<p>Certainly! Let’s analyze the time and space complexity of the <code class="docutils literal notranslate"><span class="pre">removeNthFromEnd</span></code> function in isolation:</p>
<p><strong>Time Complexity:</strong></p>
<ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">removeNthFromEnd</span></code> function performs two passes through the linked list. In the worst case, it needs to traverse the entire linked list of length <span class="math notranslate nohighlight">\(N\)</span>.</p></li>
<li><p>The first pass positions the <code class="docutils literal notranslate"><span class="pre">first</span></code> pointer <span class="math notranslate nohighlight">\(n\)</span> nodes ahead of the <code class="docutils literal notranslate"><span class="pre">second</span></code> pointer. This pass takes <span class="math notranslate nohighlight">\(O(N)\)</span> time because it involves iterating through all N nodes.</p></li>
<li><p>The second pass moves both <code class="docutils literal notranslate"><span class="pre">first</span></code> and <code class="docutils literal notranslate"><span class="pre">second</span></code> pointers simultaneously until <code class="docutils literal notranslate"><span class="pre">first</span></code> reaches the end of the list. This also takes <span class="math notranslate nohighlight">\(O(N)\)</span> time in the worst case.</p></li>
<li><p>Therefore, the overall time complexity of the <code class="docutils literal notranslate"><span class="pre">removeNthFromEnd</span></code> function is <span class="math notranslate nohighlight">\(O(N)\)</span>.</p></li>
</ul>
<p><strong>Space Complexity:</strong></p>
<ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">removeNthFromEnd</span></code> function uses a constant amount of extra space for its variables (e.g., <code class="docutils literal notranslate"><span class="pre">first</span></code>, <code class="docutils literal notranslate"><span class="pre">second</span></code>, and <code class="docutils literal notranslate"><span class="pre">dummy</span></code>). This space usage does not depend on the size of the linked list.</p></li>
<li><p>The space complexity is <span class="math notranslate nohighlight">\(O(1)\)</span>, indicating that the space used by the function is constant and independent of the size of the input linked list.</p></li>
</ul>
<p><strong>In summary</strong>, the <code class="docutils literal notranslate"><span class="pre">removeNthFromEnd</span></code> function has a time complexity of <span class="math notranslate nohighlight">\(O(N)\)</span> and a space complexity of <span class="math notranslate nohighlight">\(O(1)\)</span>. It efficiently removes the nth node from the end of the linked list with a single pass through the list and constant extra space usage.</p>
</section>
</section>
<span id="document-06. Linked List/206. Reverse Linked List"></span><section class="tex2jax_ignore mathjax_ignore" id="reverse-linked-list">
<h3>206. Reverse Linked List<a class="headerlink" href="#reverse-linked-list" title="Permalink to this heading">#</a></h3>
<p><strong>Difficulty:</strong> Easy</p>
<p><strong>Link to Problem:</strong> <a class="reference external" href="https://leetcode.com/problems/reverse-linked-list/">To see the Reverse Linked List problem on LeetCode, click here!</a></p>
<hr class="docutils" />
<p>Given the <code class="docutils literal notranslate"><span class="pre">head</span></code> of a singly linked list, reverse the list, and return the reversed list.</p>
<p><strong>Constraints:</strong></p>
<ul class="simple">
<li><p>The number of nodes in the list is the range <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">5000]</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-5000</span> <span class="pre">&lt;=</span> <span class="pre">Node.val</span> <span class="pre">&lt;=</span> <span class="pre">5000</span></code></p></li>
</ul>
<p><strong>Follow up:</strong> A linked list can be reversed either iteratively or recursively. Could you implement both?</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Definition for singly-linked list.</span>
<span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">next</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="nb">next</span>

<span class="c1"># Function to reverse a linked list iteratively</span>
<span class="k">def</span> <span class="nf">reverseListIterative</span><span class="p">(</span><span class="n">head</span><span class="p">):</span>
    <span class="n">prev</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">current</span> <span class="o">=</span> <span class="n">head</span>
    
    <span class="k">while</span> <span class="n">current</span><span class="p">:</span>
        <span class="n">next_node</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">next</span>
        <span class="n">current</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">prev</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">current</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">next_node</span>
    
    <span class="k">return</span> <span class="n">prev</span>

<span class="c1"># Function to reverse a linked list recursively</span>
<span class="k">def</span> <span class="nf">reverseListRecursive</span><span class="p">(</span><span class="n">head</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">head</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">head</span><span class="o">.</span><span class="n">next</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">head</span>

    <span class="n">new_head</span> <span class="o">=</span> <span class="n">reverseListRecursive</span><span class="p">(</span><span class="n">head</span><span class="o">.</span><span class="n">next</span><span class="p">)</span>
    <span class="n">head</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span>
    <span class="n">head</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">return</span> <span class="n">new_head</span>
</pre></div>
</div>
</div>
</div>
<section id="explanation">
<h4>Explanation:<a class="headerlink" href="#explanation" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">reverseListIterative(head)</span></code>: This function reverses a linked list iteratively using a loop. Here’s a step-by-step explanation:</p>
<ul class="simple">
<li><p>It takes the <code class="docutils literal notranslate"><span class="pre">head</span></code> of the input linked list as a parameter.</p></li>
<li><p>It initializes two pointers, <code class="docutils literal notranslate"><span class="pre">prev</span></code> and <code class="docutils literal notranslate"><span class="pre">current</span></code>, initially set to <code class="docutils literal notranslate"><span class="pre">None</span></code> and the <code class="docutils literal notranslate"><span class="pre">head</span></code> of the list, respectively.</p></li>
<li><p>It enters a <code class="docutils literal notranslate"><span class="pre">while</span></code> loop that continues until <code class="docutils literal notranslate"><span class="pre">current</span></code> reaches the end of the list (i.e., becomes <code class="docutils literal notranslate"><span class="pre">None</span></code>).</p></li>
<li><p>Inside the loop:</p>
<ul>
<li><p>It stores the <code class="docutils literal notranslate"><span class="pre">next_node</span></code> which is the next node after <code class="docutils literal notranslate"><span class="pre">current</span></code>.</p></li>
<li><p>It updates the <code class="docutils literal notranslate"><span class="pre">next</span></code> pointer of <code class="docutils literal notranslate"><span class="pre">current</span></code> to point to the <code class="docutils literal notranslate"><span class="pre">prev</span></code> node. This effectively reverses the link direction.</p></li>
<li><p>It moves <code class="docutils literal notranslate"><span class="pre">prev</span></code> to <code class="docutils literal notranslate"><span class="pre">current</span></code> and <code class="docutils literal notranslate"><span class="pre">current</span></code> to <code class="docutils literal notranslate"><span class="pre">next_node</span></code>, advancing the pointers one step further in the list.</p></li>
</ul>
</li>
<li><p>Once the loop completes, <code class="docutils literal notranslate"><span class="pre">prev</span></code> will be pointing to the new head of the reversed list (which was the last node of the original list), so it returns <code class="docutils literal notranslate"><span class="pre">prev</span></code>.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">reverseListRecursive(head)</span></code>: This function reverses a linked list recursively. Here’s how it works:</p>
<ul class="simple">
<li><p>It takes the <code class="docutils literal notranslate"><span class="pre">head</span></code> of the input linked list as a parameter.</p></li>
<li><p>The base case is checked: if <code class="docutils literal notranslate"><span class="pre">head</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code> or <code class="docutils literal notranslate"><span class="pre">head.next</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, meaning the list is empty or has only one node, it returns <code class="docutils literal notranslate"><span class="pre">head</span></code> as there’s no need to reverse a list with zero or one element.</p></li>
<li><p>In the recursive case:</p>
<ul>
<li><p>It calls itself with <code class="docutils literal notranslate"><span class="pre">head.next</span></code>, effectively moving down the list until it reaches the end.</p></li>
<li><p>Once it reaches the end, it starts reversing the links:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">head.next.next</span></code> is set to <code class="docutils literal notranslate"><span class="pre">head</span></code>, reversing the link between <code class="docutils literal notranslate"><span class="pre">head</span></code> and the next node.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">head.next</span></code> is set to <code class="docutils literal notranslate"><span class="pre">None</span></code> to avoid cycles.</p></li>
</ul>
</li>
</ul>
</li>
<li><p>Finally, it returns the new head of the reversed list, which will be the last node of the original list.</p></li>
</ul>
</li>
</ol>
<p><strong>In summary,</strong> <code class="docutils literal notranslate"><span class="pre">reverseListIterative</span></code> reverses the linked list by iterating through it and changing the next pointers, while <code class="docutils literal notranslate"><span class="pre">reverseListRecursive</span></code> reverses the linked list by recursively reaching the end and then reversing the links on the way back up the recursion stack. Both functions achieve the same result: reversing the linked list.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Helper function to create a linked list from a list of values</span>
<span class="k">def</span> <span class="nf">createLinkedList</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">values</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="n">head</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">current</span> <span class="o">=</span> <span class="n">head</span>
    <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="n">current</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">next</span>
    <span class="k">return</span> <span class="n">head</span>

<span class="c1"># Helper function to convert a linked list to a list for testing</span>
<span class="k">def</span> <span class="nf">linkedListToList</span><span class="p">(</span><span class="n">head</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">current</span> <span class="o">=</span> <span class="n">head</span>
    <span class="k">while</span> <span class="n">current</span><span class="p">:</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">next</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s explain the two helper functions used in the provided code:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">createLinkedList(values)</span></code>:</p>
<ul class="simple">
<li><p>Purpose: This function is used to create a linked list from a list of values. It takes a list of values as input and returns the head of the linked list.</p></li>
<li><p>How it works:</p>
<ul>
<li><p>It first checks if the input list <code class="docutils literal notranslate"><span class="pre">values</span></code> is empty. If it’s empty, it returns <code class="docutils literal notranslate"><span class="pre">None</span></code> to indicate an empty linked list.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">values</span></code> is not empty, it initializes a <code class="docutils literal notranslate"><span class="pre">head</span></code> node with the value of the first element in <code class="docutils literal notranslate"><span class="pre">values</span></code>.</p></li>
<li><p>It then iterates through the remaining values in <code class="docutils literal notranslate"><span class="pre">values</span></code>, creating new nodes for each value and linking them together to form a linked list.</p></li>
<li><p>Finally, it returns the <code class="docutils literal notranslate"><span class="pre">head</span></code> node of the newly created linked list.</p></li>
</ul>
</li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">linkedListToList(head)</span></code>:</p>
<ul class="simple">
<li><p>Purpose: This function is used to convert a linked list back into a Python list for testing and output purposes.</p></li>
<li><p>How it works:</p>
<ul>
<li><p>It takes the <code class="docutils literal notranslate"><span class="pre">head</span></code> of the linked list as input.</p></li>
<li><p>It initializes an empty list called <code class="docutils literal notranslate"><span class="pre">result</span></code>.</p></li>
<li><p>It then iterates through the linked list, starting from <code class="docutils literal notranslate"><span class="pre">head</span></code>, and appends each node’s <code class="docutils literal notranslate"><span class="pre">val</span></code> (value) to the <code class="docutils literal notranslate"><span class="pre">result</span></code> list.</p></li>
<li><p>This process continues until the end of the linked list is reached.</p></li>
<li><p>Finally, it returns the <code class="docutils literal notranslate"><span class="pre">result</span></code> list, which contains the values from the linked list in the same order.</p></li>
</ul>
</li>
</ul>
</li>
</ol>
<p>These helper functions are used to simplify the process of creating linked lists from lists of values and converting linked lists back into lists, making it easier to work with linked lists in the provided examples and test cases.</p>
</section>
<section id="test-cases">
<h4>Test cases<a class="headerlink" href="#test-cases" title="Permalink to this heading">#</a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 1: Iterative</span>
<span class="n">head1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="n">head1</span> <span class="o">=</span> <span class="n">createLinkedList</span><span class="p">(</span><span class="n">head1</span><span class="p">)</span>
<span class="n">reversed_head1</span> <span class="o">=</span> <span class="n">reverseListIterative</span><span class="p">(</span><span class="n">head1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">linkedListToList</span><span class="p">(</span><span class="n">reversed_head1</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[5, 4, 3, 2, 1]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 2: Recursive</span>
<span class="n">head2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="n">head2</span> <span class="o">=</span> <span class="n">createLinkedList</span><span class="p">(</span><span class="n">head2</span><span class="p">)</span>
<span class="n">reversed_head2</span> <span class="o">=</span> <span class="n">reverseListRecursive</span><span class="p">(</span><span class="n">head2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">linkedListToList</span><span class="p">(</span><span class="n">reversed_head2</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[2, 1]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 3: Empty list</span>
<span class="n">head3</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">head3</span> <span class="o">=</span> <span class="n">createLinkedList</span><span class="p">(</span><span class="n">head3</span><span class="p">)</span>
<span class="n">reversed_head3</span> <span class="o">=</span> <span class="n">reverseListIterative</span><span class="p">(</span><span class="n">head3</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">linkedListToList</span><span class="p">(</span><span class="n">reversed_head3</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[]
</pre></div>
</div>
</div>
</div>
<p>Let’s analyze the time and space complexity of the two functions:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">reverseListIterative(head)</span></code>:</p>
<ul class="simple">
<li><p>Time Complexity: <span class="math notranslate nohighlight">\(O(n)\)</span></p>
<ul>
<li><p>The iterative function visits each node in the linked list exactly once in a single pass, where “<span class="math notranslate nohighlight">\(n\)</span>” is the number of nodes in the list. Therefore, the time complexity is linear in the number of nodes.</p></li>
</ul>
</li>
<li><p>Space Complexity: <span class="math notranslate nohighlight">\(O(1)\)</span></p>
<ul>
<li><p>This function uses a constant amount of extra space for the <code class="docutils literal notranslate"><span class="pre">prev</span></code>, <code class="docutils literal notranslate"><span class="pre">current</span></code>, and <code class="docutils literal notranslate"><span class="pre">next_node</span></code> pointers. Regardless of the size of the input list, the amount of additional memory used remains the same, so the space complexity is constant.</p></li>
</ul>
</li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">reverseListRecursive(head)</span></code>:</p>
<ul class="simple">
<li><p>Time Complexity: <span class="math notranslate nohighlight">\(O(n)\)</span></p>
<ul>
<li><p>The recursive function also visits each node in the linked list exactly once. It recursively traverses the list from the head to the tail, reversing the links on the way back. Therefore, like the iterative approach, the time complexity is <span class="math notranslate nohighlight">\(O(n)\)</span>, where “<span class="math notranslate nohighlight">\(n\)</span>” is the number of nodes.</p></li>
</ul>
</li>
<li><p>Space Complexity: <span class="math notranslate nohighlight">\(O(n)\)</span></p>
<ul>
<li><p>The recursive function uses space on the call stack for each recursive call. In the worst case, when the list has “<span class="math notranslate nohighlight">\(n\)</span>” nodes, it will create “<span class="math notranslate nohighlight">\(n\)</span>” recursive function calls on the stack, resulting in a space complexity of <span class="math notranslate nohighlight">\(O(n)\)</span>. This is because each function call stores information about its state, including the <code class="docutils literal notranslate"><span class="pre">head</span></code> pointer, until it reaches the base case and starts returning.</p></li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>In summary:</strong></p>
<ul class="simple">
<li><p>The time complexity of both functions is <span class="math notranslate nohighlight">\(O(n)\)</span> because they both visit each node once.</p></li>
<li><p>The space complexity of <code class="docutils literal notranslate"><span class="pre">reverseListIterative</span></code> is <span class="math notranslate nohighlight">\(O(1)\)</span> because it uses a constant amount of extra space.</p></li>
<li><p>The space complexity of <code class="docutils literal notranslate"><span class="pre">reverseListRecursive</span></code> is <span class="math notranslate nohighlight">\(O(n)\)</span> due to the recursive function calls and the associated call stack space.</p></li>
</ul>
<p>Both functions are efficient in terms of time complexity, but <code class="docutils literal notranslate"><span class="pre">reverseListIterative</span></code> is more memory-efficient because it uses a constant amount of additional space, while <code class="docutils literal notranslate"><span class="pre">reverseListRecursive</span></code> uses space on the call stack proportional to the number of nodes in the list.</p>
</section>
<section id="challenging-exercises">
<h4>Challenging Exercises:<a class="headerlink" href="#challenging-exercises" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p><strong>K-Group Reverse:</strong> Modify the reverseListIterative function to reverse the linked list in groups of <span class="math notranslate nohighlight">\(K\)</span> elements. For example, if the input linked list is [1, 2, 3, 4, 5, 6], and <span class="math notranslate nohighlight">\(K\)</span> is 3, the output should be [3, 2, 1, 6, 5, 4].</p></li>
<li><p><strong>Rotate Linked List:</strong> Write a function to rotate a linked list to the right by <span class="math notranslate nohighlight">\(K\)</span> places. For example, if the input is [1, 2, 3, 4, 5] and <span class="math notranslate nohighlight">\(K\)</span> is 2, the output should be [4, 5, 1, 2, 3].</p></li>
</ol>
</section>
</section>
<span id="document-06. Linked List/21. Merge Two Sorted Lists"></span><section class="tex2jax_ignore mathjax_ignore" id="merge-two-sorted-lists">
<h3>21. Merge Two Sorted Lists<a class="headerlink" href="#merge-two-sorted-lists" title="Permalink to this heading">#</a></h3>
<p><strong>Difficulty:</strong> Easy</p>
<p><strong>Link to Problem:</strong> <a class="reference external" href="https://leetcode.com/problems/merge-two-sorted-lists/">To see the Merge Two Sorted Lists problem on LeetCode, click here!</a></p>
<hr class="docutils" />
<p>You are given the heads of two sorted linked lists <code class="docutils literal notranslate"><span class="pre">list1</span></code> and <code class="docutils literal notranslate"><span class="pre">list2</span></code>.</p>
<p>Merge the two lists into one <strong>sorted</strong> list. The list should be made by splicing together the nodes of the first two lists.</p>
<p><em>Return the head of the merged linked list.</em></p>
<p><strong>Constraints:</strong></p>
<ul class="simple">
<li><p>The number of nodes in both lists is in the range <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">50]</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-100</span> <span class="pre">&lt;=</span> <span class="pre">Node.val</span> <span class="pre">&lt;=</span> <span class="pre">100</span></code></p></li>
<li><p>Both <code class="docutils literal notranslate"><span class="pre">list1</span></code> and <code class="docutils literal notranslate"><span class="pre">list2</span></code> are sorted in non-decreasing order.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">next</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="nb">next</span>

<span class="k">def</span> <span class="nf">mergeTwoLists</span><span class="p">(</span><span class="n">list1</span><span class="p">,</span> <span class="n">list2</span><span class="p">):</span>
    <span class="c1"># Create a dummy node to simplify the code.</span>
    <span class="n">dummy</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">()</span>
    <span class="n">current</span> <span class="o">=</span> <span class="n">dummy</span>

    <span class="k">while</span> <span class="n">list1</span> <span class="ow">and</span> <span class="n">list2</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">list1</span><span class="o">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">list2</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
            <span class="n">current</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">list1</span>
            <span class="n">list1</span> <span class="o">=</span> <span class="n">list1</span><span class="o">.</span><span class="n">next</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">current</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">list2</span>
            <span class="n">list2</span> <span class="o">=</span> <span class="n">list2</span><span class="o">.</span><span class="n">next</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">next</span>

    <span class="c1"># Append the remaining elements from either list.</span>
    <span class="k">if</span> <span class="n">list1</span><span class="p">:</span>
        <span class="n">current</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">list1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">current</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">list2</span>

    <span class="k">return</span> <span class="n">dummy</span><span class="o">.</span><span class="n">next</span>
</pre></div>
</div>
</div>
</div>
<section id="explanation">
<h4>Explanation:<a class="headerlink" href="#explanation" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p>We define a class <code class="docutils literal notranslate"><span class="pre">ListNode</span></code> to represent the nodes of a singly-linked list. Each node has a <code class="docutils literal notranslate"><span class="pre">val</span></code> attribute to store the value of the node and a <code class="docutils literal notranslate"><span class="pre">next</span></code> attribute to point to the next node in the list.</p></li>
<li><p>We define the <code class="docutils literal notranslate"><span class="pre">mergeTwoLists</span></code> function that takes two linked list heads, <code class="docutils literal notranslate"><span class="pre">list1</span></code> and <code class="docutils literal notranslate"><span class="pre">list2</span></code>, as input.</p></li>
<li><p>We create a <code class="docutils literal notranslate"><span class="pre">dummy</span></code> node at the beginning of the merged list. The <code class="docutils literal notranslate"><span class="pre">dummy</span></code> node simplifies the code by serving as a placeholder, and its <code class="docutils literal notranslate"><span class="pre">next</span></code> attribute will point to the actual merged list.</p></li>
<li><p>We initialize a <code class="docutils literal notranslate"><span class="pre">current</span></code> pointer to point to the <code class="docutils literal notranslate"><span class="pre">dummy</span></code> node initially. This <code class="docutils literal notranslate"><span class="pre">current</span></code> pointer helps us traverse and build the merged list.</p></li>
<li><p>We enter a <code class="docutils literal notranslate"><span class="pre">while</span></code> loop that continues until either <code class="docutils literal notranslate"><span class="pre">list1</span></code> or <code class="docutils literal notranslate"><span class="pre">list2</span></code> becomes empty. Inside the loop, we compare the values of the nodes at the current positions of <code class="docutils literal notranslate"><span class="pre">list1</span></code> and <code class="docutils literal notranslate"><span class="pre">list2</span></code>.</p></li>
<li><p>If the <code class="docutils literal notranslate"><span class="pre">val</span></code> of the node in <code class="docutils literal notranslate"><span class="pre">list1</span></code> is smaller than the <code class="docutils literal notranslate"><span class="pre">val</span></code> of the node in <code class="docutils literal notranslate"><span class="pre">list2</span></code>, we attach the node from <code class="docutils literal notranslate"><span class="pre">list1</span></code> to the merged list by updating the <code class="docutils literal notranslate"><span class="pre">next</span></code> attribute of the <code class="docutils literal notranslate"><span class="pre">current</span></code> node to point to the node in <code class="docutils literal notranslate"><span class="pre">list1</span></code>. We then move the <code class="docutils literal notranslate"><span class="pre">list1</span></code> pointer to the next node.</p></li>
<li><p>If the <code class="docutils literal notranslate"><span class="pre">val</span></code> of the node in <code class="docutils literal notranslate"><span class="pre">list2</span></code> is smaller than or equal to the <code class="docutils literal notranslate"><span class="pre">val</span></code> of the node in <code class="docutils literal notranslate"><span class="pre">list1</span></code>, we attach the node from <code class="docutils literal notranslate"><span class="pre">list2</span></code> to the merged list in a similar manner. We move the <code class="docutils literal notranslate"><span class="pre">list2</span></code> pointer to the next node.</p></li>
<li><p>After attaching a node to the merged list, we move the <code class="docutils literal notranslate"><span class="pre">current</span></code> pointer to the newly added node. This step is essential for keeping track of the end of the merged list.</p></li>
<li><p>The loop continues until either <code class="docutils literal notranslate"><span class="pre">list1</span></code> or <code class="docutils literal notranslate"><span class="pre">list2</span></code> becomes empty.</p></li>
<li><p>Once the loop exits, we check if there are any remaining elements in <code class="docutils literal notranslate"><span class="pre">list1</span></code> or <code class="docutils literal notranslate"><span class="pre">list2</span></code>. If <code class="docutils literal notranslate"><span class="pre">list1</span></code> is not empty, we attach the remaining elements of <code class="docutils literal notranslate"><span class="pre">list1</span></code> to the merged list. If <code class="docutils literal notranslate"><span class="pre">list2</span></code> is not empty, we attach the remaining elements of <code class="docutils literal notranslate"><span class="pre">list2</span></code>.</p></li>
<li><p>Finally, we return the <code class="docutils literal notranslate"><span class="pre">next</span></code> attribute of the <code class="docutils literal notranslate"><span class="pre">dummy</span></code> node as the head of the merged list, which represents the sorted merged list.</p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Helper function to print the linked list</span>
<span class="k">def</span> <span class="nf">printLinkedList</span><span class="p">(</span><span class="n">head</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">head</span><span class="p">:</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">head</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="n">next</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s explain the helper functions:
<strong>printLinkedList Function</strong>:</p>
<ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">printLinkedList</span></code> function takes the <code class="docutils literal notranslate"><span class="pre">head</span></code> of a linked list as input and returns a list of values representing the nodes in the linked list.</p></li>
<li><p>Inside the function, a <code class="docutils literal notranslate"><span class="pre">result</span></code> list is initialized to store the values of the linked list nodes.</p></li>
<li><p>The function then iterates through the linked list starting from the <code class="docutils literal notranslate"><span class="pre">head</span></code> node and appends the <code class="docutils literal notranslate"><span class="pre">val</span></code> attribute of each node to the <code class="docutils literal notranslate"><span class="pre">result</span></code> list.</p></li>
<li><p>As it iterates through the list, it moves to the next node using the <code class="docutils literal notranslate"><span class="pre">next</span></code> attribute of each node.</p></li>
<li><p>Finally, the function returns the <code class="docutils literal notranslate"><span class="pre">result</span></code> list containing the values of the linked list nodes in the order they appear in the linked list.</p></li>
</ul>
<p>This function is useful for debugging and displaying the contents of a linked list. It allows you to easily convert a linked list into a regular Python list for visualization and testing purposes.</p>
</section>
<section id="test-cases">
<h4>Test cases<a class="headerlink" href="#test-cases" title="Permalink to this heading">#</a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 1:</span>
<span class="c1"># Input: list1 = [1,2,4], list2 = [1,3,4]</span>
<span class="n">list1</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">4</span><span class="p">)))</span>
<span class="n">list2</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">4</span><span class="p">)))</span>
<span class="n">merged_list</span> <span class="o">=</span> <span class="n">mergeTwoLists</span><span class="p">(</span><span class="n">list1</span><span class="p">,</span> <span class="n">list2</span><span class="p">)</span>
<span class="n">printLinkedList</span><span class="p">(</span><span class="n">merged_list</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[1, 1, 2, 3, 4, 4]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 2:</span>
<span class="c1"># Input: list1 = [], list2 = []</span>
<span class="n">list1</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">list2</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">merged_list</span> <span class="o">=</span> <span class="n">mergeTwoLists</span><span class="p">(</span><span class="n">list1</span><span class="p">,</span> <span class="n">list2</span><span class="p">)</span>
<span class="n">printLinkedList</span><span class="p">(</span><span class="n">merged_list</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 3:</span>
<span class="c1"># list1 = [], list2 = [0]</span>
<span class="n">list1</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">list2</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">merged_list</span> <span class="o">=</span> <span class="n">mergeTwoLists</span><span class="p">(</span><span class="n">list1</span><span class="p">,</span> <span class="n">list2</span><span class="p">)</span>
<span class="n">printLinkedList</span><span class="p">(</span><span class="n">merged_list</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[0]
</pre></div>
</div>
</div>
</div>
<p>Let’s analyze the time and space complexity of the <code class="docutils literal notranslate"><span class="pre">mergeTwoLists</span></code> function.</p>
<p><strong>Time Complexity:</strong></p>
<p>The time complexity of this function is <span class="math notranslate nohighlight">\(O(N + M\)</span>), where <span class="math notranslate nohighlight">\(N\)</span> and <span class="math notranslate nohighlight">\(M\)</span> are the lengths of <code class="docutils literal notranslate"><span class="pre">list1</span></code> and <code class="docutils literal notranslate"><span class="pre">list2</span></code>, respectively. Here’s why:</p>
<ol class="arabic simple">
<li><p>In the worst case, we need to traverse both <code class="docutils literal notranslate"><span class="pre">list1</span></code> and <code class="docutils literal notranslate"><span class="pre">list2</span></code> completely. This involves iterating through all the nodes in both lists once.</p></li>
<li><p>The while loop runs until either <code class="docutils literal notranslate"><span class="pre">list1</span></code> or <code class="docutils literal notranslate"><span class="pre">list2</span></code> becomes empty. The number of iterations depends on the total number of nodes in both lists, which is N + M in the worst case.</p></li>
<li><p>Inside the loop, we perform constant-time operations for each iteration, such as comparisons and updating pointers.</p></li>
</ol>
<p>Therefore, the dominant factor in the time complexity is the combined length of both input lists, resulting in a linear time complexity of <span class="math notranslate nohighlight">\(O(N + M)\)</span>.</p>
<p><strong>Space Complexity:</strong></p>
<p>The space complexity of this function is <span class="math notranslate nohighlight">\(O(1)\)</span>, which means it uses a constant amount of extra space regardless of the input sizes. Here’s why:</p>
<ol class="arabic simple">
<li><p>We create a few extra pointers (<code class="docutils literal notranslate"><span class="pre">dummy</span></code>, <code class="docutils literal notranslate"><span class="pre">current</span></code>) and temporary variables (<code class="docutils literal notranslate"><span class="pre">val</span></code>) to manage the merging process. These consume a fixed amount of memory, regardless of the input sizes. The number of these extra variables is independent of the lengths of <code class="docutils literal notranslate"><span class="pre">list1</span></code> and <code class="docutils literal notranslate"><span class="pre">list2</span></code>.</p></li>
<li><p>We do not create a new data structure or allocate memory for the merged list. Instead, we rearrange the existing nodes from <code class="docutils literal notranslate"><span class="pre">list1</span></code> and <code class="docutils literal notranslate"><span class="pre">list2</span></code> to form the merged list. This operation does not consume additional memory proportional to the input sizes.</p></li>
</ol>
<p><strong>In summary</strong>, the <code class="docutils literal notranslate"><span class="pre">mergeTwoLists</span></code> function has a time complexity of <span class="math notranslate nohighlight">\(O(N + M)\)</span> and a space complexity of <span class="math notranslate nohighlight">\(O(1)\)</span>, making it an efficient solution for merging two sorted linked lists.</p>
</section>
<section id="challenging-exercises">
<h4>Challenging Exercises:<a class="headerlink" href="#challenging-exercises" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p><strong>Merge K Sorted Lists:</strong> Extend the problem to merge <span class="math notranslate nohighlight">\(K\)</span> sorted linked lists instead of just two. You need to efficiently merge <span class="math notranslate nohighlight">\(K\)</span> lists into one sorted list.</p></li>
<li><p><strong>Merge Lists in a Zigzag Pattern:</strong> Merge two sorted lists in a zigzag pattern. For example, given [1, 2, 4] and [1, 3, 5], the merged list should be [1, 1, 2, 3, 4, 5].</p></li>
</ol>
</section>
</section>
<span id="document-06. Linked List/23. Merge k Sorted Lists"></span><section class="tex2jax_ignore mathjax_ignore" id="merge-k-sorted-lists">
<h3>23. Merge k Sorted Lists<a class="headerlink" href="#merge-k-sorted-lists" title="Permalink to this heading">#</a></h3>
<p><strong>Difficulty:</strong> Hard</p>
<p><strong>Link to Problem:</strong> <a class="reference external" href="https://leetcode.com/problems/merge-k-sorted-lists/">To see the Merge k Sorted Lists problem on LeetCode, click here!</a></p>
<hr class="docutils" />
<p>You are given an array of <span class="math notranslate nohighlight">\(k\)</span> linked-lists lists, each linked-list is sorted in ascending order.</p>
<p>Merge all the linked-lists into one sorted linked-list and return it.</p>
<p><strong>Constraints:</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">==</span> <span class="pre">lists.length</span></code></p></li>
<li><p>0 &lt;= k &lt;= <span class="math notranslate nohighlight">\(10^4\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">lists[i].length</span> <span class="pre">&lt;=</span> <span class="pre">500</span></code></p></li>
<li><p><span class="math notranslate nohighlight">\(-10^4\)</span> &lt;= lists[i][j] &lt;= <span class="math notranslate nohighlight">\(10^4\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lists[i]</span></code> is sorted in ascending order.</p></li>
<li><p>The sum of <code class="docutils literal notranslate"><span class="pre">lists[i].length</span></code> will not exceed <span class="math notranslate nohighlight">\(10^4\)</span>.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Definition for singly-linked list.</span>
<span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
     <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">next</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="nb">next</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">mergeKLists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lists</span><span class="p">:</span> <span class="p">[[</span><span class="n">ListNode</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">ListNode</span><span class="p">:</span>
        <span class="c1"># Check if the input list of linked lists is empty</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">lists</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">lists</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Loop until there is only one merged list left</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">lists</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">mergedLists</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># Merge pairs of lists</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lists</span><span class="p">),</span> <span class="mi">2</span><span class="p">):</span>
                <span class="n">l1</span> <span class="o">=</span> <span class="n">lists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">l2</span> <span class="o">=</span> <span class="n">lists</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">lists</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
                <span class="n">mergedLists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mergeList</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">))</span>

            <span class="c1"># Update the list of lists with merged results</span>
            <span class="n">lists</span> <span class="o">=</span> <span class="n">mergedLists</span>
        
        <span class="c1"># Return the final merged list</span>
        <span class="k">return</span> <span class="n">lists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">mergeList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">):</span>
        <span class="c1"># Create a dummy node to simplify merging</span>
        <span class="n">dummy</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">()</span>
        <span class="n">tail</span> <span class="o">=</span> <span class="n">dummy</span>

        <span class="c1"># Merge the two sorted lists</span>
        <span class="k">while</span> <span class="n">l1</span> <span class="ow">and</span> <span class="n">l2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">l1</span><span class="o">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">l2</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
                <span class="n">tail</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">l1</span>
                <span class="n">l1</span> <span class="o">=</span> <span class="n">l1</span><span class="o">.</span><span class="n">next</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tail</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">l2</span>
                <span class="n">l2</span> <span class="o">=</span> <span class="n">l2</span><span class="o">.</span><span class="n">next</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="n">tail</span><span class="o">.</span><span class="n">next</span>

        <span class="c1"># Append any remaining elements from l1 or l2 (if any)</span>
        <span class="k">if</span> <span class="n">l1</span><span class="p">:</span>
            <span class="n">tail</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">l1</span>
        <span class="k">if</span> <span class="n">l2</span><span class="p">:</span>
            <span class="n">tail</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">l2</span>

        <span class="c1"># Return the merged result starting from the next of the dummy node</span>
        <span class="k">return</span> <span class="n">dummy</span><span class="o">.</span><span class="n">next</span>
</pre></div>
</div>
</div>
</div>
<section id="explanation">
<h4>Explanation:<a class="headerlink" href="#explanation" title="Permalink to this heading">#</a></h4>
<p>The provided code defines a Python class <code class="docutils literal notranslate"><span class="pre">Solution</span></code> with two methods for merging k sorted linked lists:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mergeKLists(self,</span> <span class="pre">lists:</span> <span class="pre">List[ListNode])</span> <span class="pre">-&gt;</span> <span class="pre">ListNode</span></code>: This method takes a list of k sorted linked lists as input and returns a single merged sorted linked list. It uses a divide-and-conquer approach to repeatedly merge pairs of lists until only one merged list remains.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mergeList(self,</span> <span class="pre">l1,</span> <span class="pre">l2)</span></code>: This method takes two sorted linked lists, <code class="docutils literal notranslate"><span class="pre">l1</span></code> and <code class="docutils literal notranslate"><span class="pre">l2</span></code>, as input and merges them into a single sorted linked list. It uses a dummy node to simplify the merging process.</p></li>
</ol>
<p>Here’s a high-level overview of how the code works:</p>
<ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">mergeKLists</span></code> method checks if the input list of linked lists is empty or contains no lists. If there are no lists, it returns <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p></li>
<li><p>Inside a <code class="docutils literal notranslate"><span class="pre">while</span></code> loop, the code repeatedly merges pairs of linked lists until only one merged list remains in the <code class="docutils literal notranslate"><span class="pre">lists</span></code> array. It does this by iterating through the input lists in pairs and calling the <code class="docutils literal notranslate"><span class="pre">mergeList</span></code> method to merge each pair.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">mergeList</span></code> method takes two sorted linked lists, <code class="docutils literal notranslate"><span class="pre">l1</span></code> and <code class="docutils literal notranslate"><span class="pre">l2</span></code>, and merges them into a single sorted linked list. It uses a dummy node (<code class="docutils literal notranslate"><span class="pre">dummy</span></code>) and a <code class="docutils literal notranslate"><span class="pre">tail</span></code> pointer to keep track of the merged list while comparing and merging elements from <code class="docutils literal notranslate"><span class="pre">l1</span></code> and <code class="docutils literal notranslate"><span class="pre">l2</span></code>.</p></li>
<li><p>After merging all pairs of lists and updating the <code class="docutils literal notranslate"><span class="pre">lists</span></code> array with the merged results, the loop continues until only one merged list remains in the <code class="docutils literal notranslate"><span class="pre">lists</span></code> array.</p></li>
<li><p>Finally, the <code class="docutils literal notranslate"><span class="pre">mergeKLists</span></code> method returns the merged list.</p></li>
</ul>
<p>Overall, this code efficiently merges k sorted linked lists using a divide-and-conquer strategy, resulting in a single merged sorted linked list as the output.</p>
</section>
<section id="test-cases">
<h4>Test cases<a class="headerlink" href="#test-cases" title="Permalink to this heading">#</a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">### Example 1</span>
<span class="c1"># Input: lists = [[1,4,5],[1,3,4],[2,6]]</span>

<span class="n">lists1</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">ListNode</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">5</span><span class="p">))),</span>
    <span class="n">ListNode</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">4</span><span class="p">))),</span>
    <span class="n">ListNode</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">6</span><span class="p">))</span>
<span class="p">]</span>
<span class="n">solution</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">()</span>
<span class="n">result1</span> <span class="o">=</span> <span class="n">solution</span><span class="o">.</span><span class="n">mergeKLists</span><span class="p">(</span><span class="n">lists1</span><span class="p">)</span>

<span class="c1"># Print the result</span>
<span class="k">if</span> <span class="n">result1</span><span class="p">:</span>
    <span class="n">current</span> <span class="o">=</span> <span class="n">result1</span>
    <span class="k">while</span> <span class="n">current</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">current</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; -&gt; &quot;</span><span class="p">)</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">next</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;None&quot;</span><span class="p">)</span>  <span class="c1"># Print &quot;None&quot; for input with a single None element</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">### Example 2</span>
<span class="c1"># Input: lists = []</span>

<span class="n">lists2</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">solution</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">()</span>
<span class="n">result2</span> <span class="o">=</span> <span class="n">solution</span><span class="o">.</span><span class="n">mergeKLists</span><span class="p">(</span><span class="n">lists2</span><span class="p">)</span>

<span class="c1"># Print the result</span>
<span class="k">if</span> <span class="n">result2</span><span class="p">:</span>
    <span class="n">current</span> <span class="o">=</span> <span class="n">result2</span>
    <span class="k">while</span> <span class="n">current</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">current</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; -&gt; &quot;</span><span class="p">)</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">next</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;None&quot;</span><span class="p">)</span>  <span class="c1"># Print &quot;None&quot; for input with a single None element</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>None
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">### Example 3</span>
<span class="c1"># Input: lists = [[]]</span>

<span class="n">lists3</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
<span class="n">solution</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">()</span>
<span class="n">result3</span> <span class="o">=</span> <span class="n">solution</span><span class="o">.</span><span class="n">mergeKLists</span><span class="p">(</span><span class="n">lists3</span><span class="p">)</span>

<span class="c1"># Print the result</span>
<span class="k">if</span> <span class="n">result3</span><span class="p">:</span>
    <span class="n">current</span> <span class="o">=</span> <span class="n">result3</span>
    <span class="k">while</span> <span class="n">current</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">current</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; -&gt; &quot;</span><span class="p">)</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">next</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;None&quot;</span><span class="p">)</span>  <span class="c1"># Print &quot;None&quot; for input with a single None element</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>None
</pre></div>
</div>
</div>
</div>
<p>Let’s analyze the time and space complexity of the provided code:</p>
<p><strong>Time Complexity:</strong></p>
<ol class="arabic">
<li><p><strong>Heap Initialization:</strong> The code does not use a heap. Instead, it uses a divide-and-conquer approach. The initial check for empty input lists takes <span class="math notranslate nohighlight">\(O(1)\)</span> time.</p></li>
<li><p><strong>Merging:</strong> The merging operation is performed in a divide-and-conquer fashion. In each iteration of the <code class="docutils literal notranslate"><span class="pre">while</span></code> loop, we merge pairs of linked lists, and the number of comparisons made is proportional to the total number of nodes across all the linked lists (<span class="math notranslate nohighlight">\(n\)</span>). In each merge step, we effectively process each node once. The number of iterations required to reduce k lists to 1 is <span class="math notranslate nohighlight">\(O(log\ k)\)</span>.</p>
<p>Therefore, the overall time complexity of the code is <span class="math notranslate nohighlight">\(O(n * log\ k)\)</span>, where n is the total number of nodes across all lists, and <span class="math notranslate nohighlight">\(k\)</span> is the number of linked lists.</p>
</li>
</ol>
<p><strong>Space Complexity:</strong></p>
<ol class="arabic">
<li><p><strong>Heap Space:</strong> The code doesn’t use a heap data structure, so there’s no additional space complexity due to a heap.</p></li>
<li><p><strong>Merged Lists:</strong> In the <code class="docutils literal notranslate"><span class="pre">mergeList</span></code> method, we create a new merged list. However, this list is not stored in memory for all lists; it’s replaced with each merged pair. The space used for these merged lists is proportional to the size of the largest merged list, which is <span class="math notranslate nohighlight">\(O(n)\)</span> in the worst case.</p></li>
<li><p><strong>Additional Variables:</strong> The code uses a few additional variables, such as <code class="docutils literal notranslate"><span class="pre">dummy</span></code> and <code class="docutils literal notranslate"><span class="pre">tail</span></code>, but these occupy a constant amount of space and don’t depend on the input size.</p>
<p>Therefore, the overall space complexity of the code is <span class="math notranslate nohighlight">\(O(n)\)</span>, where n is the total number of nodes across all lists.</p>
</li>
</ol>
<p>In summary, the code’s time complexity is <span class="math notranslate nohighlight">\(O(n * log(k))\)</span>, and its space complexity is <span class="math notranslate nohighlight">\(O(n)\)</span>. This code efficiently merges <span class="math notranslate nohighlight">\(k\)</span> sorted linked lists using a divide-and-conquer approach with a relatively low space overhead.</p>
</section>
</section>
</div>
</section>
<span id="document-07. Trees/README"></span><section class="tex2jax_ignore mathjax_ignore" id="trees-problems-blind-75-leetcode">
<h2>Trees Problems - Blind 75 LeetCode<a class="headerlink" href="#trees-problems-blind-75-leetcode" title="Permalink to this heading">#</a></h2>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Problem Name</p></th>
<th class="head"><p>Difficulty</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/invert-binary-tree/">226. Invert Binary Tree</a></p></td>
<td><p>Easy</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/maximum-depth-of-binary-tree/">104. Maximum Depth of Binary Tree</a></p></td>
<td><p>Easy</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/same-tree/">100. Same Tree</a></p></td>
<td><p>Easy</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/subtree-of-another-tree/">572. Subtree of Another Tree</a></p></td>
<td><p>Easy</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. Lowest Common Ancestor of a Binary Search Tree</a></p></td>
<td><p>Easy</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/binary-tree-level-order-traversal/">102. Binary Tree Level Order Traversal</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/validate-binary-search-tree/">98. Validate Binary Search Tree</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/">230. Kth Smallest Element In a BST</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. Construct Binary Tree From Preorder And Inorder Traversal</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/binary-tree-maximum-path-sum/">124. Binary Tree Maximum Path Sum</a></p></td>
<td><p>Hard</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/">297. Serialize And Deserialize Binary Tree</a></p></td>
<td><p>Hard</p></td>
</tr>
</tbody>
</table>
<section id="contribute">
<h3>Contribute<a class="headerlink" href="#contribute" title="Permalink to this heading">#</a></h3>
<p>If you have a better solution or want to add more problems to the collection, feel free to contribute. You can create a pull request or open an issue to discuss additions or improvements.</p>
</section>
<section id="resources">
<h3>Resources<a class="headerlink" href="#resources" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p><a class="reference external" href="https://leetcode.com/">LeetCode</a>: The official LeetCode website.</p></li>
<li><p><a class="reference external" href="https://leetcode.com/discuss/">LeetCode Discuss</a>: LeetCode’s discussion forum for each problem. You can find helpful hints and discussions here.</p></li>
</ul>
<p>Happy coding!</p>
</section>
<div class="toctree-wrapper compound">
<span id="document-07. Trees/100. Same Tree"></span><section class="tex2jax_ignore mathjax_ignore" id="same-tree">
<h3>100: Same Tree<a class="headerlink" href="#same-tree" title="Permalink to this heading">#</a></h3>
<p><strong>Difficulty:</strong> Easy</p>
<p><strong>Link to Problem:</strong> <a class="reference external" href="https://leetcode.com/problems/same-tree/">To see the Same Tree problem on LeetCode, click here!</a></p>
<hr class="docutils" />
<p>Given the roots of two binary trees <code class="docutils literal notranslate"><span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">q</span></code>, write a function to check if they are the same or not.</p>
<p>Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.</p>
<p><strong>Constraints</strong></p>
<ol class="arabic simple">
<li><p>The number of nodes in both trees is in the range <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">100]</span></code>.</p></li>
<li><p><span class="math notranslate nohighlight">\(-10^4\)</span> &lt;= Node.val &lt;= <span class="math notranslate nohighlight">\(10^4\)</span></p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Definition for a binary tree node.</span>
<span class="k">class</span> <span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Initialize a TreeNode with a value (val), left child, and right child.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

<span class="k">def</span> <span class="nf">isSameTree</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
    <span class="c1"># Base case: If both p and q are None, the trees are the same.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">p</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">q</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    
    <span class="c1"># Base case: If either p or q is None (but not both), the trees are different.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">p</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">q</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    
    <span class="c1"># Check if the values of the current nodes (p.val and q.val) are equal.</span>
    <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">val</span> <span class="o">!=</span> <span class="n">q</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    
    <span class="c1"># Recursively check the left and right subtrees of p and q.</span>
    <span class="c1"># If both subtrees are the same, the entire trees are the same.</span>
    <span class="k">return</span> <span class="n">isSameTree</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">left</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isSameTree</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>In this code, we define a <code class="docutils literal notranslate"><span class="pre">TreeNode</span></code> class to represent binary tree nodes and a <code class="docutils literal notranslate"><span class="pre">isSameTree</span></code> function to check if two binary trees are the same. The function uses recursive traversal to compare the trees’ structures and values.</p>
<ol class="arabic simple">
<li><p>We start by defining a <code class="docutils literal notranslate"><span class="pre">TreeNode</span></code> class, which represents a node in a binary tree. Each node has a <code class="docutils literal notranslate"><span class="pre">val</span></code> (the node’s value), a <code class="docutils literal notranslate"><span class="pre">left</span></code> child, and a right child. This class will help us create and work with binary trees.</p></li>
<li><p>Next, we define the <code class="docutils literal notranslate"><span class="pre">isSameTree</span></code> function, which checks if two binary trees (<code class="docutils literal notranslate"><span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">q</span></code>) are the same.</p>
<ul class="simple">
<li><p>The base case for the recursion is when both <code class="docutils literal notranslate"><span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">q</span></code> are <code class="docutils literal notranslate"><span class="pre">None</span></code>. In this case, they are considered the same, so we return <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p></li>
<li><p>If either <code class="docutils literal notranslate"><span class="pre">p</span></code> or <code class="docutils literal notranslate"><span class="pre">q</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code> (but not both), they cannot be the same, so we return <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
<li><p>If the values of the current nodes <code class="docutils literal notranslate"><span class="pre">p.val</span></code> and <code class="docutils literal notranslate"><span class="pre">q.val</span></code> are not equal, we return <code class="docutils literal notranslate"><span class="pre">False</span></code> because the trees cannot be the same.</p></li>
<li><p>Finally, we recursively check the left and right subtrees of <code class="docutils literal notranslate"><span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">q</span></code> to see if they are the same.</p></li>
</ul>
</li>
</ol>
<section id="test-cases">
<h4>Test cases<a class="headerlink" href="#test-cases" title="Permalink to this heading">#</a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">### Example 1</span>

<span class="c1">#Input: `p = [1,2,3]`, `q = [1,2,3]`</span>

<span class="n">p1</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="n">q1</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">isSameTree</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">q1</span><span class="p">))</span> 
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">### Example 2</span>

<span class="c1">#Input: `p = [1,2]`, `q = [1,null,2]`</span>

<span class="n">p2</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
<span class="n">q2</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">isSameTree</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span> <span class="n">q2</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>False
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">### Example 3</span>

<span class="c1">#Input: p = [1,2,1], q = [1,1,2]</span>

<span class="n">p3</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="n">q3</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">isSameTree</span><span class="p">(</span><span class="n">p3</span><span class="p">,</span> <span class="n">q3</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>False
</pre></div>
</div>
</div>
</div>
</section>
<section id="time-complexity">
<h4>Time Complexity<a class="headerlink" href="#time-complexity" title="Permalink to this heading">#</a></h4>
<p>The time complexity of the <code class="docutils literal notranslate"><span class="pre">isSameTree</span></code> function can be analyzed as follows:</p>
<p>In the worst case, the function needs to visit every node in both trees once to determine if they are the same.
Since each node is visited exactly once, the time complexity is <span class="math notranslate nohighlight">\(O(n)\)</span>, where <span class="math notranslate nohighlight">\(n\)</span> is the total number of nodes in the input trees.</p>
</section>
<section id="space-complexity">
<h4>Space Complexity<a class="headerlink" href="#space-complexity" title="Permalink to this heading">#</a></h4>
<p>The space complexity of the <code class="docutils literal notranslate"><span class="pre">isSameTree</span></code> function can be analyzed as follows:</p>
<p>The space used by the function’s call stack during recursion is proportional to the maximum depth of the binary trees.
In the worst case, when the trees are completely unbalanced (all nodes form a single branch), the maximum depth will be <span class="math notranslate nohighlight">\(n\)</span>, where <span class="math notranslate nohighlight">\(n\)</span> is the total number of nodes in the input trees.
Therefore, the space complexity is <span class="math notranslate nohighlight">\(O(n)\)</span> due to the recursive call stack.
In addition to the call stack, there is a small constant amount of space used for variables and comparisons within each recursive call, but this space is not significant in terms of the overall space complexity.</p>
</section>
<section id="in-summary">
<h4>In summary:<a class="headerlink" href="#in-summary" title="Permalink to this heading">#</a></h4>
<ul class="simple">
<li><p><strong>Time Complexity:</strong> <span class="math notranslate nohighlight">\(O(n)\)</span> where <span class="math notranslate nohighlight">\(n\)</span> is the total number of nodes in the input trees.</p></li>
<li><p><strong>Space Complexity:</strong> <span class="math notranslate nohighlight">\(O(n)\)</span> due to the recursive call stack.</p></li>
</ul>
</section>
</section>
<span id="document-07. Trees/102. Binary Tree Level Order Traversal"></span><section class="tex2jax_ignore mathjax_ignore" id="binary-tree-level-order-traversal">
<h3>102. Binary Tree Level Order Traversal<a class="headerlink" href="#binary-tree-level-order-traversal" title="Permalink to this heading">#</a></h3>
<p><strong>Difficulty:</strong> Medium</p>
<p><strong>Link to Problem:</strong> <a class="reference external" href="https://leetcode.com/problems/binary-tree-level-order-traversal/">To see the Binary Tree Level Order Traversal problem on LeetCode, click here!</a></p>
<hr class="docutils" />
<p>Given the <code class="docutils literal notranslate"><span class="pre">root</span></code> of a binary tree, return <em>the level order traversal of its nodes’ values</em>. (i.e., from left to right, level by level).</p>
<p><strong>Constraints:</strong></p>
<ul class="simple">
<li><p>The number of nodes in the tree is in the range <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">2000]</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-1000</span> <span class="pre">&lt;=</span> <span class="pre">Node.val</span> <span class="pre">&lt;=</span> <span class="pre">1000</span></code></p></li>
</ul>
<section id="solution">
<h4>Solution:<a class="headerlink" href="#solution" title="Permalink to this heading">#</a></h4>
<p>Here’s a Python function to solve this problem:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

<span class="k">def</span> <span class="nf">levelOrder</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="c1"># Check if the tree is empty, if so, return an empty list.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="c1"># Initialize an empty list to store the result.</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c1"># Initialize a queue with the root node to perform BFS.</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="p">]</span>

    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="c1"># Initialize an empty list to store the values of nodes at the current level.</span>
        <span class="n">level_values</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="c1"># Get the number of nodes at the current level.</span>
        <span class="n">level_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>

        <span class="c1"># Iterate through the nodes at the current level.</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">level_size</span><span class="p">):</span>
            <span class="c1"># Dequeue the front node from the queue.</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            
            <span class="c1"># Append the value of the current node to the level_values list.</span>
            <span class="n">level_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>

            <span class="c1"># Enqueue the left and right children of the current node if they exist.</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
                <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
                <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>

        <span class="c1"># Append the level_values list (values at the current level) to the result list.</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">level_values</span><span class="p">)</span>

    <span class="c1"># Return the final result, which is a list of lists representing level order traversal.</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="explanation">
<h4>Explanation:<a class="headerlink" href="#explanation" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p>We define a <code class="docutils literal notranslate"><span class="pre">TreeNode</span></code> class that represents a node in the binary tree. Each <code class="docutils literal notranslate"><span class="pre">TreeNode</span></code> object has a value (<code class="docutils literal notranslate"><span class="pre">val</span></code>) and two child nodes: <code class="docutils literal notranslate"><span class="pre">left</span></code> and <code class="docutils literal notranslate"><span class="pre">right</span></code>.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">levelOrder</span></code> function takes the root of the binary tree as its input and returns the level order traversal of the tree as a list of lists.</p></li>
<li><p>We start by checking if the input <code class="docutils literal notranslate"><span class="pre">root</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, which indicates an empty tree. If the tree is empty, we return an empty list because there are no nodes to traverse.</p></li>
<li><p>We initialize an empty list called <code class="docutils literal notranslate"><span class="pre">result</span></code> to store the final result, which will be a list of lists containing node values at each level.</p></li>
<li><p>We initialize a queue called <code class="docutils literal notranslate"><span class="pre">queue</span></code> with the root node. This queue will be used for breadth-first traversal of the tree.</p></li>
<li><p>We enter a while loop that continues until the <code class="docutils literal notranslate"><span class="pre">queue</span></code> is empty. Inside the loop, we perform the following steps:</p>
<ul class="simple">
<li><p>We initialize an empty list called <code class="docutils literal notranslate"><span class="pre">level_values</span></code> to store the values of nodes at the current level.</p></li>
<li><p>We determine the number of nodes at the current level by getting the length of the <code class="docutils literal notranslate"><span class="pre">queue</span></code>. This is done to process nodes level by level.</p></li>
<li><p>We iterate through the nodes at the current level using a for loop. For each node in the current level:</p>
<ul>
<li><p>We dequeue (remove) the front node from the <code class="docutils literal notranslate"><span class="pre">queue</span></code>.</p></li>
<li><p>We append the value of the dequeued node to the <code class="docutils literal notranslate"><span class="pre">level_values</span></code> list, effectively collecting the values of nodes at the current level.</p></li>
<li><p>If the dequeued node has a left child, we enqueue the left child to the <code class="docutils literal notranslate"><span class="pre">queue</span></code>.</p></li>
<li><p>If the dequeued node has a right child, we enqueue the right child to the <code class="docutils literal notranslate"><span class="pre">queue</span></code>.</p></li>
</ul>
</li>
<li><p>After processing all nodes at the current level, we append the <code class="docutils literal notranslate"><span class="pre">level_values</span></code> list to the <code class="docutils literal notranslate"><span class="pre">result</span></code> list. This represents the values at the current level.</p></li>
</ul>
</li>
<li><p>The loop continues until all levels have been traversed, and the <code class="docutils literal notranslate"><span class="pre">queue</span></code> becomes empty.</p></li>
<li><p>Finally, we return the <code class="docutils literal notranslate"><span class="pre">result</span></code> list, which contains lists of node values at each level, representing the level order traversal of the binary tree.</p></li>
</ol>
<p>The code effectively performs a breadth-first traversal of the binary tree, processing nodes level by level, and constructs the result list that represents the level order traversal.</p>
</section>
<section id="test-cases">
<h4>Test cases<a class="headerlink" href="#test-cases" title="Permalink to this heading">#</a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 1: </span>

<span class="c1"># Construct the tree</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
<span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>
<span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">levelOrder</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[3], [9, 20], [15, 7]]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 2:</span>

<span class="c1"># Using the same tree as before</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">levelOrder</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[1]]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 3:</span>
<span class="c1"># Creating a new tree for this example</span>
<span class="n">root</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">levelOrder</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[]
</pre></div>
</div>
</div>
</div>
</section>
<section id="time-and-space-complexity-analysis">
<h4>Time and Space Complexity Analysis<a class="headerlink" href="#time-and-space-complexity-analysis" title="Permalink to this heading">#</a></h4>
<p>Let’s analyze the time and space complexity of the <code class="docutils literal notranslate"><span class="pre">levelOrder</span></code> function:</p>
<p><strong>Time Complexity:</strong></p>
<p>The time complexity of this function is O(N), where N is the number of nodes in the binary tree. This is because we visit each node exactly once during the breadth-first traversal.</p>
<p>In the worst case, we have to enqueue and dequeue all nodes in the binary tree, which is proportional to the number of nodes (N). In each level, we process all nodes in that level, and since there are a total of log(N) levels in a balanced binary tree, the time complexity can also be approximated as O(N) for unbalanced trees.</p>
<p><strong>Space Complexity:</strong></p>
<p>The space complexity of this function is O(N), where N is the number of nodes in the binary tree. Here’s how the space complexity breaks down:</p>
<ol class="arabic simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">result</span></code> list stores the level order traversal, and in the worst case, it contains N/2 levels (for a completely unbalanced binary tree). So, the space used by <code class="docutils literal notranslate"><span class="pre">result</span></code> is O(N).</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">queue</span></code> data structure is used for BFS traversal. In the worst case, it can store all nodes at the last level of the tree. In a balanced binary tree, the maximum number of nodes at any level is 2^(log(N)), which is still O(N). In the case of an unbalanced tree, it can be even worse. So, the space used by <code class="docutils literal notranslate"><span class="pre">queue</span></code> is O(N).</p></li>
</ol>
<p>Overall, the dominant factor in terms of space complexity is the <code class="docutils literal notranslate"><span class="pre">queue</span></code>, and the space complexity is O(N).</p>
<p>In summary, the function’s time complexity is O(N), and its space complexity is also O(N). It is an efficient and optimal solution for performing a level order traversal of a binary tree.</p>
</section>
<section id="challenging-exercises">
<h4>Challenging Exercises:<a class="headerlink" href="#challenging-exercises" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p><strong>Reverse Level Order Traversal:</strong> Modify the <code class="docutils literal notranslate"><span class="pre">levelOrder</span></code> function to return the level order traversal in reverse order (from bottom to top). For example, if the input tree is <code class="docutils literal notranslate"><span class="pre">[3,</span> <span class="pre">9,</span> <span class="pre">20,</span> <span class="pre">null,</span> <span class="pre">null,</span> <span class="pre">15,</span> <span class="pre">7]</span></code>, the output should be <code class="docutils literal notranslate"><span class="pre">[[15,</span> <span class="pre">7],</span> <span class="pre">[9,</span> <span class="pre">20],</span> <span class="pre">[3]]</span></code>.</p></li>
<li><p><strong>Zigzag Level Order Traversal:</strong> Write a function that performs a level order traversal of a binary tree in a zigzag pattern. In a zigzag traversal, the nodes at even levels are traversed from left to right, and nodes at odd levels are traversed from right to left. For example, if the input tree is <code class="docutils literal notranslate"><span class="pre">[3,</span> <span class="pre">9,</span> <span class="pre">20,</span> <span class="pre">null,</span> <span class="pre">null,</span> <span class="pre">15,</span> <span class="pre">7]</span></code>, the output should be <code class="docutils literal notranslate"><span class="pre">[[3],</span> <span class="pre">[20,</span> <span class="pre">9],</span> <span class="pre">[15,</span> <span class="pre">7]]</span></code>.</p></li>
</ol>
</section>
</section>
<span id="document-07. Trees/104. Maximum Depth of Binary Tree"></span><section class="tex2jax_ignore mathjax_ignore" id="maximum-depth-of-binary-tree">
<h3>104. Maximum Depth of Binary Tree<a class="headerlink" href="#maximum-depth-of-binary-tree" title="Permalink to this heading">#</a></h3>
<p><strong>Difficulty:</strong> Easy</p>
<p><strong>Link to Problem:</strong> <a class="reference external" href="https://leetcode.com/problems/invert-binary-tree/">To see the Invert Binary Tree problem on LeetCode, click here!</a></p>
<hr class="docutils" />
<p>Given the <code class="docutils literal notranslate"><span class="pre">root</span></code> of a binary tree, return its maximum depth.</p>
<p>A binary tree’s <strong>maximum depth</strong> is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<p><strong>Constraints:</strong></p>
<ul class="simple">
<li><p>The number of nodes in the tree is in the range <span class="math notranslate nohighlight">\([0, 10^4]\)</span>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-100</span> <span class="pre">&lt;=</span> <span class="pre">Node.val</span> <span class="pre">&lt;=</span> <span class="pre">100</span></code></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Definition for a binary tree node.</span>
<span class="k">class</span> <span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

<span class="k">def</span> <span class="nf">maxDepth</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="c1"># Base case: If the root is None, the depth is 0.</span>
    <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    
    <span class="c1"># Recursively calculate the maximum depth of the left and right subtrees.</span>
    <span class="n">left_depth</span> <span class="o">=</span> <span class="n">maxDepth</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
    <span class="n">right_depth</span> <span class="o">=</span> <span class="n">maxDepth</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
    
    <span class="c1"># Return the maximum depth of the tree by adding 1 to the maximum depth of the subtrees.</span>
    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">left_depth</span><span class="p">,</span> <span class="n">right_depth</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>
</div>
</div>
<section id="explanation">
<h4>Explanation:<a class="headerlink" href="#explanation" title="Permalink to this heading">#</a></h4>
<p>Let’s go through the code step by step to understand how it works:</p>
<ol class="arabic simple">
<li><p>We start by defining a <code class="docutils literal notranslate"><span class="pre">TreeNode</span></code> class to represent the nodes of the binary tree. Each node has three attributes:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">val</span></code>: the value stored in the node.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">left</span></code>: a reference to the left child node.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">right</span></code>: a reference to the right child node.</p></li>
</ul>
</li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">maxDepth</span></code> function is the main function that calculates the maximum depth of the binary tree. It takes a single argument, <code class="docutils literal notranslate"><span class="pre">root</span></code>, which is the root node of the binary tree.</p></li>
<li><p>In the <code class="docutils literal notranslate"><span class="pre">maxDepth</span></code> function, we have a base case:</p>
<ul class="simple">
<li><p>If the <code class="docutils literal notranslate"><span class="pre">root</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, it means we have reached the end of a branch of the tree (a leaf node or an empty subtree). In this case, the depth is 0 because there are no nodes to count.</p></li>
</ul>
</li>
<li><p>If the <code class="docutils literal notranslate"><span class="pre">root</span></code> is not <code class="docutils literal notranslate"><span class="pre">None</span></code>, we recursively calculate the maximum depth of the left and right subtrees:</p>
<ul class="simple">
<li><p>We call <code class="docutils literal notranslate"><span class="pre">maxDepth</span></code> on the <code class="docutils literal notranslate"><span class="pre">root.left</span></code> to calculate the maximum depth of the left subtree and store it in the variable <code class="docutils literal notranslate"><span class="pre">left_depth</span></code>.</p></li>
<li><p>We call <code class="docutils literal notranslate"><span class="pre">maxDepth</span></code> on the <code class="docutils literal notranslate"><span class="pre">root.right</span></code> to calculate the maximum depth of the right subtree and store it in the variable <code class="docutils literal notranslate"><span class="pre">right_depth</span></code>.</p></li>
</ul>
</li>
<li><p>Finally, we return the maximum depth of the tree by taking the maximum of <code class="docutils literal notranslate"><span class="pre">left_depth</span></code> and <code class="docutils literal notranslate"><span class="pre">right_depth</span></code> and adding 1 to it. This is because we are counting the current level as well.</p></li>
</ol>
</section>
<section id="test-cases">
<h4>Test cases<a class="headerlink" href="#test-cases" title="Permalink to this heading">#</a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">### Example 1</span>
<span class="c1"># Input: root = [3,9,20,null,null,15,7]</span>

<span class="n">root</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
<span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>
<span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">maxDepth</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>3
</pre></div>
</div>
</div>
</div>
<p>In this example, we create a binary tree based on the given input <code class="docutils literal notranslate"><span class="pre">[3,9,20,null,null,15,7]</span></code> and calculate its maximum depth, which is <code class="docutils literal notranslate"><span class="pre">3</span></code>. The tree structure is as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="mi">3</span>
   <span class="o">/</span> \
  <span class="mi">9</span>  <span class="mi">20</span>
    <span class="o">/</span>  \
   <span class="mi">15</span>   <span class="mi">7</span>
</pre></div>
</div>
<p>So, the maximum depth is the length of the longest path from the root to a leaf node, which is 3 in this case.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">### Example 2</span>
<span class="c1"># Input: root = [1,null,2]</span>

<span class="n">root</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># Calculate the maximum depth of the tree and print the result</span>
<span class="nb">print</span><span class="p">(</span><span class="n">maxDepth</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2
</pre></div>
</div>
</div>
</div>
<p>Let’s analyze the time and space complexity of the provided code:</p>
<p><strong>Time Complexity:</strong></p>
<ul class="simple">
<li><p>The time complexity of the <code class="docutils literal notranslate"><span class="pre">maxDepth</span></code> function is <span class="math notranslate nohighlight">\(O(N)\)</span>, where <span class="math notranslate nohighlight">\(N\)</span> is the number of nodes in the binary tree.</p></li>
<li><p>This is because in the worst case, the function visits every node exactly once in a depth-first manner.</p></li>
<li><p>The recursion explores all nodes of the tree, so the time complexity is linear with respect to the number of nodes.</p></li>
</ul>
<p><strong>Space Complexity:</strong></p>
<ul class="simple">
<li><p>The space complexity of the <code class="docutils literal notranslate"><span class="pre">maxDepth</span></code> function is <span class="math notranslate nohighlight">\(O(H)\)</span>, where H is the height of the binary tree.</p></li>
<li><p>In the worst case, if the binary tree is completely unbalanced (skewed), the recursion stack can go as deep as the height of the tree.</p></li>
<li><p>In the best case, if the binary tree is perfectly balanced, the height is <span class="math notranslate nohighlight">\(O(log\ N)\)</span>, where <span class="math notranslate nohighlight">\(N\)</span> is the number of nodes.</p></li>
<li><p>Therefore, the space complexity can vary from <span class="math notranslate nohighlight">\(O(log\ N)\)</span> to <span class="math notranslate nohighlight">\(O(N)\)</span> depending on the shape of the tree.</p></li>
<li><p>In addition to the recursion stack, there is a small constant amount of space used for variables and function call overhead.</p></li>
</ul>
<p><strong>In summary:</strong></p>
<ul class="simple">
<li><p>The time complexity of the code is <span class="math notranslate nohighlight">\(O(N)\)</span> as it visits each node once.</p></li>
<li><p>The space complexity is <span class="math notranslate nohighlight">\(O(H)\)</span>, where H is the height of the tree, which can vary from <span class="math notranslate nohighlight">\(O(log\ N)\)</span> to <span class="math notranslate nohighlight">\(O(N)\)</span> depending on the tree’s shape.</p></li>
</ul>
</section>
</section>
<span id="document-07. Trees/105. Construct Binary Tree from Preorder and Inorder Traversal"></span><section class="tex2jax_ignore mathjax_ignore" id="construct-binary-tree-from-preorder-and-inorder-traversal">
<h3>105. Construct Binary Tree from Preorder and Inorder Traversal<a class="headerlink" href="#construct-binary-tree-from-preorder-and-inorder-traversal" title="Permalink to this heading">#</a></h3>
<p><strong>Difficulty:</strong> Medium</p>
<p><strong>Link to Problem:</strong> <a class="reference external" href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">To see the Construct Binary Tree from Preorder and Inorder Traversal problem on LeetCode, click here!</a></p>
<hr class="docutils" />
<p>Given two integer arrays <code class="docutils literal notranslate"><span class="pre">preorder</span></code> and <code class="docutils literal notranslate"><span class="pre">inorder</span></code> where <code class="docutils literal notranslate"><span class="pre">preorder</span></code> is the preorder traversal of a binary tree and <code class="docutils literal notranslate"><span class="pre">inorder</span></code> is the inorder traversal of the same tree, construct and return <em>the binary tree.</em></p>
<p><strong>Constraints:</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">&lt;=</span> <span class="pre">preorder.length</span> <span class="pre">&lt;=</span> <span class="pre">3000</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">inorder.length</span> <span class="pre">==</span> <span class="pre">preorder.length</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-3000</span> <span class="pre">&lt;=</span> <span class="pre">preorder[i],</span> <span class="pre">inorder[i]</span> <span class="pre">&lt;=</span> <span class="pre">3000</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">preorder</span></code> and <code class="docutils literal notranslate"><span class="pre">inorder</span></code> consist of <strong>unique</strong> values.</p></li>
<li><p>Each value of <code class="docutils literal notranslate"><span class="pre">inorder</span></code> also appears in <code class="docutils literal notranslate"><span class="pre">preorder</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">preorder</span></code> is <strong>guaranteed</strong> to be the preorder traversal of the tree.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">inorder</span></code> is <strong>guaranteed</strong> to be the inorder traversal of the tree.</p></li>
</ul>
<section id="solution">
<h4>Solution:<a class="headerlink" href="#solution" title="Permalink to this heading">#</a></h4>
<p>Here’s a Python function to solve this problem:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

<span class="k">def</span> <span class="nf">buildTree</span><span class="p">(</span><span class="n">preorder</span><span class="p">,</span> <span class="n">inorder</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">preorder</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># The first element in the preorder traversal is the root of the current subtree</span>
    <span class="n">root_val</span> <span class="o">=</span> <span class="n">preorder</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">root</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">root_val</span><span class="p">)</span>

    <span class="c1"># Find the index of the root value in the inorder traversal</span>
    <span class="n">root_idx_inorder</span> <span class="o">=</span> <span class="n">inorder</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">root_val</span><span class="p">)</span>

    <span class="c1"># Recursively build left and right subtrees</span>
    <span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">buildTree</span><span class="p">(</span><span class="n">preorder</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">1</span> <span class="o">+</span> <span class="n">root_idx_inorder</span><span class="p">],</span> <span class="n">inorder</span><span class="p">[:</span><span class="n">root_idx_inorder</span><span class="p">])</span>
    <span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">buildTree</span><span class="p">(</span><span class="n">preorder</span><span class="p">[</span><span class="mi">1</span> <span class="o">+</span> <span class="n">root_idx_inorder</span><span class="p">:],</span> <span class="n">inorder</span><span class="p">[</span><span class="n">root_idx_inorder</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:])</span>

    <span class="k">return</span> <span class="n">root</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="explanation">
<h4>Explanation:<a class="headerlink" href="#explanation" title="Permalink to this heading">#</a></h4>
<ol class="arabic">
<li><p><code class="docutils literal notranslate"><span class="pre">class</span> <span class="pre">TreeNode:</span></code>: This is a class definition for a binary tree node. It has three attributes:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">val</span></code>: The value of the node.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">left</span></code>: A reference to the left child node.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">right</span></code>: A reference to the right child node.</p></li>
</ul>
<p>This class is used to create instances of binary tree nodes, which will be used to build the binary tree.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">def</span> <span class="pre">buildTree(preorder,</span> <span class="pre">inorder):</span></code>: This is the main function that constructs a binary tree from its preorder and inorder traversals.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">preorder</span></code>: A list representing the preorder traversal of the binary tree.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">inorder</span></code>: A list representing the inorder traversal of the binary tree.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">not</span> <span class="pre">preorder:</span> <span class="pre">return</span> <span class="pre">None</span></code>: This line checks if the <code class="docutils literal notranslate"><span class="pre">preorder</span></code> list is empty. If it is, it means there are no nodes to construct, so the function returns <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">root_val</span> <span class="pre">=</span> <span class="pre">preorder[0]</span></code>: The value of the root node is extracted from the first element of the <code class="docutils literal notranslate"><span class="pre">preorder</span></code> list.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">root</span> <span class="pre">=</span> <span class="pre">TreeNode(root_val)</span></code>: A new <code class="docutils literal notranslate"><span class="pre">TreeNode</span></code> object is created with the <code class="docutils literal notranslate"><span class="pre">root_val</span></code> as its value. This represents the root of the current subtree.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">root_idx_inorder</span> <span class="pre">=</span> <span class="pre">inorder.index(root_val)</span></code>: The index of the <code class="docutils literal notranslate"><span class="pre">root_val</span></code> in the <code class="docutils literal notranslate"><span class="pre">inorder</span></code> list is found. This index indicates the position of the root node in the inorder traversal.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">root.left</span></code>: The left subtree is constructed recursively by calling the <code class="docutils literal notranslate"><span class="pre">buildTree</span></code> function with the appropriate sublists of <code class="docutils literal notranslate"><span class="pre">preorder</span></code> and <code class="docutils literal notranslate"><span class="pre">inorder</span></code>. The left subtree’s preorder and inorder traversals are the slices of <code class="docutils literal notranslate"><span class="pre">preorder</span></code> and <code class="docutils literal notranslate"><span class="pre">inorder</span></code> lists up to the <code class="docutils literal notranslate"><span class="pre">root_idx_inorder</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">root.right</span></code>: The right subtree is constructed recursively by calling the <code class="docutils literal notranslate"><span class="pre">buildTree</span></code> function with the appropriate sublists of <code class="docutils literal notranslate"><span class="pre">preorder</span></code> and <code class="docutils literal notranslate"><span class="pre">inorder</span></code>. The right subtree’s preorder and inorder traversals are the slices of <code class="docutils literal notranslate"><span class="pre">preorder</span></code> and <code class="docutils literal notranslate"><span class="pre">inorder</span></code> lists starting from <code class="docutils literal notranslate"><span class="pre">root_idx_inorder</span> <span class="pre">+</span> <span class="pre">1</span></code>.</p></li>
<li><p>Finally, the function returns the <code class="docutils literal notranslate"><span class="pre">root</span></code> of the subtree it just constructed.</p></li>
</ol>
<p>The recursive approach used here divides the problem of constructing the entire binary tree into smaller subproblems, starting with the root node and then recursively building the left and right subtrees until the entire tree is constructed.</p>
</section>
<section id="helper-function">
<h4>Helper Function<a class="headerlink" href="#helper-function" title="Permalink to this heading">#</a></h4>
<p>Here is a helper function to represent the binary tree elements.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">treeToList</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="c1"># Initialize an empty list to store the elements of the binary tree</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c1"># Initialize a queue for level-order traversal starting with the root</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="p">]</span>

    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="c1"># Pop the front node from the queue</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        
        <span class="c1"># If the node is not None (i.e., a valid node), add its value to the result list</span>
        <span class="k">if</span> <span class="n">node</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
            
            <span class="c1"># Add the left and right children of the node to the queue</span>
            <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
            <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If the node is None, add None to the result to represent an empty node</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

    <span class="c1"># Remove any trailing None values from the result list</span>
    <span class="k">while</span> <span class="n">result</span> <span class="ow">and</span> <span class="n">result</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">result</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

    <span class="c1"># Return the resulting list representing the binary tree elements</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="id1">
<h4>Explanation:<a class="headerlink" href="#id1" title="Permalink to this heading">#</a></h4>
<p>Let’s break down the <code class="docutils literal notranslate"><span class="pre">treeToList</span></code> helper function step by step:</p>
<ol class="arabic">
<li><p><code class="docutils literal notranslate"><span class="pre">def</span> <span class="pre">treeToList(root):</span></code>: This function takes the root of a binary tree as input and converts it into a list.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">result</span> <span class="pre">=</span> <span class="pre">[]</span></code>: Initialize an empty list called <code class="docutils literal notranslate"><span class="pre">result</span></code> to store the elements of the binary tree in list format.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">queue</span> <span class="pre">=</span> <span class="pre">[root]</span></code>: Initialize a queue data structure for a level-order traversal, starting with the root node.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">while</span> <span class="pre">queue:</span></code>: This starts a loop that continues until the queue is empty, indicating that all nodes have been processed.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">node</span> <span class="pre">=</span> <span class="pre">queue.pop(0)</span></code>: Dequeue the first node from the queue, effectively processing it.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">node:</span></code>: Check if the <code class="docutils literal notranslate"><span class="pre">node</span></code> is not None, which means it’s a valid node in the binary tree.</p>
<p>a. <code class="docutils literal notranslate"><span class="pre">result.append(node.val)</span></code>: If the node is valid, append its value (<code class="docutils literal notranslate"><span class="pre">node.val</span></code>) to the <code class="docutils literal notranslate"><span class="pre">result</span></code> list. This represents the value of the current node in the binary tree.</p>
<p>b. <code class="docutils literal notranslate"><span class="pre">queue.append(node.left)</span></code>: Enqueue the left child of the current node if it exists. This adds the left child to the queue for processing in the next iteration.</p>
<p>c. <code class="docutils literal notranslate"><span class="pre">queue.append(node.right)</span></code>: Enqueue the right child of the current node if it exists. This adds the right child to the queue for processing in the next iteration.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">else:</span></code>: If the <code class="docutils literal notranslate"><span class="pre">node</span></code> is None, it represents an empty node in the binary tree.</p>
<p>a. <code class="docutils literal notranslate"><span class="pre">result.append(None)</span></code>: Append <code class="docutils literal notranslate"><span class="pre">None</span></code> to the <code class="docutils literal notranslate"><span class="pre">result</span></code> list to indicate an empty node.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">while</span> <span class="pre">result</span> <span class="pre">and</span> <span class="pre">result[-1]</span> <span class="pre">is</span> <span class="pre">None:</span></code>: After the traversal is complete, there might be trailing <code class="docutils literal notranslate"><span class="pre">None</span></code> values in the <code class="docutils literal notranslate"><span class="pre">result</span></code> list. This loop removes any such trailing <code class="docutils literal notranslate"><span class="pre">None</span></code> values to ensure a clean representation of the tree’s elements.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">result</span></code>: Return the <code class="docutils literal notranslate"><span class="pre">result</span></code> list, which now contains the elements of the binary tree in a format where <code class="docutils literal notranslate"><span class="pre">None</span></code> represents empty nodes and the order of elements reflects a level-order traversal of the tree.</p></li>
</ol>
<p>In summary, the <code class="docutils literal notranslate"><span class="pre">treeToList</span></code> function performs a level-order traversal of the binary tree using a queue, constructing a list where each element corresponds to a node’s value or represents an empty node with <code class="docutils literal notranslate"><span class="pre">None</span></code>. This list represents the binary tree’s elements in a structured format.</p>
</section>
<section id="test-cases">
<h4>Test cases<a class="headerlink" href="#test-cases" title="Permalink to this heading">#</a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 1: </span>

<span class="c1"># Example usage:</span>
<span class="n">preorder</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>
<span class="n">inorder</span> <span class="o">=</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">buildTree</span><span class="p">(</span><span class="n">preorder</span><span class="p">,</span> <span class="n">inorder</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">treeToList</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[3, 9, 20, None, None, 15, 7]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 2:</span>

<span class="n">preorder</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="n">inorder</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">buildTree</span><span class="p">(</span><span class="n">preorder</span><span class="p">,</span> <span class="n">inorder</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">treeToList</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[-1]
</pre></div>
</div>
</div>
</div>
</section>
<section id="time-and-space-complexity-analysis">
<h4>Time and Space Complexity Analysis<a class="headerlink" href="#time-and-space-complexity-analysis" title="Permalink to this heading">#</a></h4>
<p>Let’s analyze the time and space complexity of the <code class="docutils literal notranslate"><span class="pre">buildTree</span></code> function:</p>
<p><strong>Time Complexity:</strong>
The time complexity of the <code class="docutils literal notranslate"><span class="pre">buildTree</span></code> function can be analyzed in terms of the number of nodes in the binary tree. Let’s assume there are <code class="docutils literal notranslate"><span class="pre">n</span></code> nodes in the binary tree.</p>
<ol class="arabic simple">
<li><p>Finding the root value in the <code class="docutils literal notranslate"><span class="pre">preorder</span></code> traversal takes O(1) time as it’s just extracting the first element from the list.</p></li>
<li><p>Finding the index of the root value in the <code class="docutils literal notranslate"><span class="pre">inorder</span></code> traversal using <code class="docutils literal notranslate"><span class="pre">inorder.index(root_val)</span></code> takes O(n) time in the worst case because in the worst case, it might have to search through all <code class="docutils literal notranslate"><span class="pre">n</span></code> elements in the <code class="docutils literal notranslate"><span class="pre">inorder</span></code> list to find the index.</p></li>
<li><p>The recursive calls to <code class="docutils literal notranslate"><span class="pre">buildTree</span></code> for the left and right subtrees are made once for each node in the tree. Therefore, the recursive calls have a combined time complexity of O(n) as they process each node once.</p></li>
</ol>
<p>The total time complexity of the <code class="docutils literal notranslate"><span class="pre">buildTree</span></code> function is O(n) due to the recursive calls and finding the root’s index in the <code class="docutils literal notranslate"><span class="pre">inorder</span></code> list.</p>
<p><strong>Space Complexity:</strong>
The space complexity is determined by the space used by the function’s call stack during recursion and any additional data structures used.</p>
<ol class="arabic simple">
<li><p>The space used by the function call stack during recursion depends on the height of the binary tree. In the worst case, where the tree is highly unbalanced (e.g., a skewed tree), the space complexity for the call stack is O(n) as it can go as deep as the number of nodes in the tree.</p></li>
<li><p>Additionally, the function creates TreeNode objects for each node in the binary tree. Therefore, the space complexity for these objects is also O(n).</p></li>
</ol>
<p>Overall, the space complexity of the <code class="docutils literal notranslate"><span class="pre">buildTree</span></code> function is O(n) due to the space used by the call stack and the TreeNode objects.</p>
<p>In summary, the time complexity of <code class="docutils literal notranslate"><span class="pre">buildTree</span></code> is O(n), and the space complexity is O(n), where ‘n’ is the number of nodes in the binary tree.</p>
</section>
<section id="challenging-exercises">
<h4>Challenging Exercises:<a class="headerlink" href="#challenging-exercises" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p><strong>Construct Binary Tree from Postorder and Inorder Traversal:</strong>
Modify the problem to construct a binary tree from its postorder and inorder traversals. Implement a function similar to <code class="docutils literal notranslate"><span class="pre">buildTree</span></code> but for postorder and inorder traversals.</p></li>
<li><p><strong>Reconstruct Binary Tree with Duplicate Values:</strong>
Extend the problem to handle binary trees with duplicate values. Ensure that your solution correctly handles scenarios where there are duplicate values in the preorder and inorder traversals.</p></li>
</ol>
</section>
</section>
<span id="document-07. Trees/124. Binary Tree Maximum Path Sum"></span><section class="tex2jax_ignore mathjax_ignore" id="binary-tree-maximum-path-sum">
<h3>124. Binary Tree Maximum Path Sum<a class="headerlink" href="#binary-tree-maximum-path-sum" title="Permalink to this heading">#</a></h3>
<p><strong>Difficulty:</strong> Hard</p>
<p><strong>Link to Problem:</strong> <a class="reference external" href="https://leetcode.com/problems/binary-tree-maximum-path-sum/">To see the Binary Tree Maximum Path Sum problem on LeetCode, click here!</a></p>
<hr class="docutils" />
<p>A <strong>path</strong> in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence <strong>at most once</strong>. Note that the path does not need to pass through the root.</p>
<p>The <strong>path sum</strong> of a path is the sum of the node’s values in the path.</p>
<p>Given the <code class="docutils literal notranslate"><span class="pre">root</span></code> of a binary tree, return <em>the maximum <strong>path sum</strong> of any <strong>non-empty</strong> path</em>.</p>
<p><strong>Constraints:</strong></p>
<ul class="simple">
<li><p>The number of nodes in the tree is in the range <span class="math notranslate nohighlight">\([1, 3*10^4]\)</span>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-1000</span> <span class="pre">&lt;=</span> <span class="pre">Node.val</span> <span class="pre">&lt;=</span> <span class="pre">1000</span></code></p></li>
</ul>
<section id="probelm-explanation">
<h4>Probelm Explanation:<a class="headerlink" href="#probelm-explanation" title="Permalink to this heading">#</a></h4>
<p>The problem is to find the maximum path sum in a binary tree. A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. The path sum of a path is the sum of the node values in that path.</p>
<p>In this problem, you are given the root of a binary tree, and you need to find the maximum path sum among all possible paths in the tree. Note that the path does not need to start at the root node or end at a leaf node; it can start and end at any nodes in the tree.</p>
<p>To find the maximum path sum, you need to consider both left and right subtrees of each node while traversing the tree. At each node, you have two choices:</p>
<ol class="arabic simple">
<li><p>Include the current node in the path: In this case, you add the value of the current node to the sum and continue exploring both the left and right subtrees for possible extensions of the path.</p></li>
<li><p>Start a new path from the current node: In this case, you do not include the current node in the path sum, and you choose either the left subtree or the right subtree to start a new path.</p></li>
</ol>
<p>To solve this problem, you can use a recursive approach to traverse the binary tree. For each node, you calculate the maximum path sum that can pass through that node (option 1) and also return the maximum path sum that can be extended from that node (option 2). You keep track of the global maximum path sum encountered during the traversal.</p>
<p>Ultimately, the maximum path sum among all paths in the tree will be the maximum of the global maximum path sum and the maximum path sum calculated for each node.</p>
<p>The constraints for this problem include:</p>
<ul class="simple">
<li><p>The number of nodes in the tree is in the range <span class="math notranslate nohighlight">\([1, 3 * 10^4]\)</span>.</p></li>
<li><p>Node values are in the range [-1000, 1000].</p></li>
</ul>
<p>By considering all possible paths through the tree, the algorithm aims to find the most significant sum of node values in any path in the binary tree.</p>
</section>
<section id="solution">
<h4>Solution:<a class="headerlink" href="#solution" title="Permalink to this heading">#</a></h4>
<p>Here’s a Python function to implement this algorithm:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">maxPathSum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">max_path_sum_helper</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
            
            <span class="c1"># Recursively calculate the maximum path sum for left and right subtrees</span>
            <span class="n">left_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_path_sum_helper</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">))</span>
            <span class="n">right_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_path_sum_helper</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">))</span>
            
            <span class="c1"># Update the global maximum path sum</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_sum</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_sum</span><span class="p">,</span> <span class="n">left_max</span> <span class="o">+</span> <span class="n">right_max</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
            
            <span class="c1"># Return the maximum path sum starting from the current node</span>
            <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">left_max</span><span class="p">,</span> <span class="n">right_max</span><span class="p">)</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="n">val</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">max_sum</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;-inf&#39;</span><span class="p">)</span>  <span class="c1"># Initialize the global maximum to negative infinity</span>
        <span class="n">max_path_sum_helper</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>  <span class="c1"># Start the recursive traversal from the root</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_sum</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="explanation">
<h4>Explanation:<a class="headerlink" href="#explanation" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p>The code starts by defining a <code class="docutils literal notranslate"><span class="pre">TreeNode</span></code> class to represent nodes in the binary tree. Each <code class="docutils literal notranslate"><span class="pre">TreeNode</span></code> has a <code class="docutils literal notranslate"><span class="pre">val</span></code> attribute representing its value, a <code class="docutils literal notranslate"><span class="pre">left</span></code> attribute pointing to the left child, and a <code class="docutils literal notranslate"><span class="pre">right</span></code> attribute pointing to the right child.</p></li>
<li><p>Next, a <code class="docutils literal notranslate"><span class="pre">Solution</span></code> class is defined to contain the <code class="docutils literal notranslate"><span class="pre">maxPathSum</span></code> method, which will be used to find the maximum path sum in the binary tree.</p></li>
<li><p>Within the <code class="docutils literal notranslate"><span class="pre">maxPathSum</span></code> method, a helper function called <code class="docutils literal notranslate"><span class="pre">max_path_sum_helper</span></code> is defined. This recursive function takes a single argument, <code class="docutils literal notranslate"><span class="pre">node</span></code>, which is the current node being considered during traversal.</p></li>
<li><p>Inside the <code class="docutils literal notranslate"><span class="pre">max_path_sum_helper</span></code> function:</p>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">node</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code> (i.e., the current node is a null node), it returns 0. This is the base case of the recursion.</p></li>
<li><p>It calculates the maximum path sum starting from the left subtree (<code class="docutils literal notranslate"><span class="pre">left_max</span></code>) and the right subtree (<code class="docutils literal notranslate"><span class="pre">right_max</span></code>). Importantly, it uses <code class="docutils literal notranslate"><span class="pre">max(0,</span> <span class="pre">...)</span></code> to ensure that negative values (which would make the path sum smaller) are not considered. If a subtree’s path sum is negative, it’s better to not include it in the path.</p></li>
<li><p>The code then updates the global maximum path sum (<code class="docutils literal notranslate"><span class="pre">self.max_sum</span></code>) by checking if the sum of <code class="docutils literal notranslate"><span class="pre">left_max</span></code>, <code class="docutils literal notranslate"><span class="pre">right_max</span></code>, and the current node’s value is greater than the current maximum.</p></li>
<li><p>Finally, it returns the maximum path sum starting from the current node, which is the maximum of <code class="docutils literal notranslate"><span class="pre">left_max</span></code> and <code class="docutils literal notranslate"><span class="pre">right_max</span></code> plus the current node’s value.</p></li>
</ul>
</li>
<li><p>Before calling the <code class="docutils literal notranslate"><span class="pre">max_path_sum_helper</span></code> function, the <code class="docutils literal notranslate"><span class="pre">max_sum</span></code> attribute of the <code class="docutils literal notranslate"><span class="pre">Solution</span></code> class is initialized to negative infinity (<code class="docutils literal notranslate"><span class="pre">float('-inf')</span></code>). This is done to ensure that any valid path sum encountered during traversal will be greater than the initial value of <code class="docutils literal notranslate"><span class="pre">max_sum</span></code>.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">max_path_sum_helper</span></code> function is called with the root of the binary tree, effectively starting the traversal from the root node.</p></li>
<li><p>Once the traversal is complete, the method returns the value of <code class="docutils literal notranslate"><span class="pre">self.max_sum</span></code>, which contains the maximum path sum found in the binary tree.</p></li>
<li><p>Example usage at the bottom of the code demonstrates how to create binary trees and use the <code class="docutils literal notranslate"><span class="pre">maxPathSum</span></code> method to find the maximum path sum for two different tree structures.</p></li>
</ol>
<p>In summary, the code uses a recursive approach to explore all possible paths in the binary tree, ensuring that negative path sums are not considered. It keeps track of the maximum path sum encountered and returns that maximum value as the result.</p>
</section>
<section id="test-cases">
<h4>Test cases:<a class="headerlink" href="#test-cases" title="Permalink to this heading">#</a></h4>
<p>Here’s how you can use this solution:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 1: </span>

<span class="c1"># Example usage:</span>
<span class="n">root1</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">root1</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">root1</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">solution</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">solution</span><span class="o">.</span><span class="n">maxPathSum</span><span class="p">(</span><span class="n">root1</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>6
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 2:</span>

<span class="n">root2</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">)</span>
<span class="n">root2</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
<span class="n">root2</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="n">root2</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>
<span class="n">root2</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">solution</span><span class="o">.</span><span class="n">maxPathSum</span><span class="p">(</span><span class="n">root2</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>42
</pre></div>
</div>
</div>
</div>
</section>
<section id="time-and-space-complexity-analysis">
<h4>Time and Space Complexity Analysis<a class="headerlink" href="#time-and-space-complexity-analysis" title="Permalink to this heading">#</a></h4>
<p>Let’s analyze the time and space complexity of the given code:</p>
<p>Time Complexity:</p>
<ul class="simple">
<li><p>The code uses a recursive depth-first traversal to explore each node in the binary tree exactly once.</p></li>
<li><p>During the traversal, for each node, we perform constant time operations, such as updating the <code class="docutils literal notranslate"><span class="pre">max_sum</span></code> variable and calculating the maximum path sum starting from that node.</p></li>
<li><p>Therefore, the time complexity of the code is O(N), where N is the number of nodes in the binary tree.</p></li>
</ul>
<p>Space Complexity:</p>
<ul class="simple">
<li><p>The space complexity of the code is determined by the space used in the call stack during the recursive traversal.</p></li>
<li><p>In the worst case, the depth of the call stack can be equal to the height of the binary tree. In an unbalanced tree, this could be O(N), but in a balanced binary tree, the height is O(log N).</p></li>
<li><p>Additionally, the code uses a constant amount of space for variables like <code class="docutils literal notranslate"><span class="pre">left_max</span></code>, <code class="docutils literal notranslate"><span class="pre">right_max</span></code>, and <code class="docutils literal notranslate"><span class="pre">max_sum</span></code>.</p></li>
<li><p>Therefore, the overall space complexity is O(H), where H is the height of the binary tree. In the worst case, it’s O(N), and in the best case (a balanced binary tree), it’s O(log N).</p></li>
</ul>
<p>In summary:</p>
<ul class="simple">
<li><p>Time Complexity: O(N)</p></li>
<li><p>Space Complexity: O(H), where H is the height of the binary tree, ranging from O(log N) to O(N) depending on the tree’s balance.</p></li>
</ul>
</section>
<section id="challenging-exercises">
<h4>Challenging Exercises:<a class="headerlink" href="#challenging-exercises" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p><strong>Print the Maximum Path:</strong>
Modify the code to not only find the maximum path sum but also print the nodes involved in the maximum path. You can print the nodes in the correct order from the root to the leaf.</p></li>
<li><p><strong>Path Sum Count:</strong>
Instead of finding the maximum path sum, find the count of unique paths that sum to a given target value. Each path can start and end anywhere in the tree.</p></li>
</ol>
</section>
</section>
<span id="document-07. Trees/199. Binary Tree Right Side View"></span><section class="tex2jax_ignore mathjax_ignore" id="binary-tree-right-side-view">
<h3>199. Binary Tree Right Side View<a class="headerlink" href="#binary-tree-right-side-view" title="Permalink to this heading">#</a></h3>
<p><strong>Difficulty:</strong> Medium</p>
<p><strong>Link to Problem:</strong> <a class="reference external" href="https://leetcode.com/problems/binary-tree-right-side-view/">To see the Binary Tree Right Side View problem on LeetCode, click here!</a></p>
<hr class="docutils" />
<p>Given the <code class="docutils literal notranslate"><span class="pre">root</span></code> of a binary tree, imagine yourself standing on the <strong>right side</strong> of it, return <em>the values of the nodes you can see ordered from top to bottom</em>.</p>
<p><strong>Constraints:</strong></p>
<ul class="simple">
<li><p>The number of nodes in the tree is in the range <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">2000]</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-100</span> <span class="pre">&lt;=</span> <span class="pre">Node.val</span> <span class="pre">&lt;=</span> <span class="pre">100</span></code></p></li>
</ul>
<section id="solution">
<h4>Solution:<a class="headerlink" href="#solution" title="Permalink to this heading">#</a></h4>
<p>Here’s a Python function to solve this problem:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

<span class="k">def</span> <span class="nf">rightSideView</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>  <span class="c1"># If the tree is empty, return an empty list.</span>

    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Initialize a list to store the right side view values.</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="p">]</span>  <span class="c1"># Initialize a queue for level-order traversal with the root node.</span>

    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="c1"># Get the number of nodes at the current level.</span>
        <span class="n">level_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>

        <span class="c1"># Traverse all nodes at the current level and add the rightmost node to the result.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">level_size</span><span class="p">):</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># Dequeue the first node from the queue.</span>

            <span class="c1"># If it&#39;s the rightmost node at this level, add its value to the result.</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">level_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>

            <span class="c1"># Add the children of the current node to the queue.</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
                <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
                <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span>  <span class="c1"># Return the list of right side view values.</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="explanation">
<h4>Explanation:<a class="headerlink" href="#explanation" title="Permalink to this heading">#</a></h4>
<ol class="arabic">
<li><p>We start with a binary tree represented using a TreeNode class. Each node has a value (<code class="docutils literal notranslate"><span class="pre">val</span></code>) and can have a left child (<code class="docutils literal notranslate"><span class="pre">left</span></code>) and a right child (<code class="docutils literal notranslate"><span class="pre">right</span></code>).</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">rightSideView</span></code> function takes the root node of the binary tree as input and returns a list of values representing the nodes you can see when standing on the right side of the tree.</p></li>
<li><p>We check if the <code class="docutils literal notranslate"><span class="pre">root</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, which means the tree is empty. If it’s empty, we return an empty list because there are no nodes to see.</p></li>
<li><p>We initialize an empty list called <code class="docutils literal notranslate"><span class="pre">result</span></code> to store the right side view values.</p></li>
<li><p>We initialize a queue called <code class="docutils literal notranslate"><span class="pre">queue</span></code> with the root node. This queue is used for a level-order traversal of the tree.</p></li>
<li><p>We enter a while loop that continues until the <code class="docutils literal notranslate"><span class="pre">queue</span></code> is empty. Inside this loop, we perform the following steps for each level of the tree:</p>
<p>a. We determine the number of nodes at the current level by getting the length of the <code class="docutils literal notranslate"><span class="pre">queue</span></code>. This is important for processing nodes at the same level together.</p>
<p>b. We then iterate through the nodes at the current level using a for loop. For each node in the level, we dequeue it from the <code class="docutils literal notranslate"><span class="pre">queue</span></code> using <code class="docutils literal notranslate"><span class="pre">queue.pop(0)</span></code>.</p>
<p>c. If the node we dequeue is the rightmost node at the current level (determined by <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">==</span> <span class="pre">level_size</span> <span class="pre">-</span> <span class="pre">1</span></code>), we add its <code class="docutils literal notranslate"><span class="pre">val</span></code> to the <code class="docutils literal notranslate"><span class="pre">result</span></code> list. This is because, when standing on the right side of the tree, you can see the rightmost node at each level.</p>
<p>d. We enqueue the left and right children of the current node (if they exist) to the <code class="docutils literal notranslate"><span class="pre">queue</span></code>. This ensures that we process the next level in the subsequent iterations of the while loop.</p>
</li>
<li><p>After processing all levels of the tree, the <code class="docutils literal notranslate"><span class="pre">result</span></code> list contains the values of the rightmost nodes in each level, ordered from top to bottom.</p></li>
<li><p>Finally, we return the <code class="docutils literal notranslate"><span class="pre">result</span></code> list as the output of the function, which represents the right side view of the binary tree.</p></li>
</ol>
<p>The code effectively performs a level-order traversal of the binary tree while keeping track of the rightmost nodes at each level and adding them to the result list. This ensures that we obtain the correct order of nodes visible from the right side of the tree.</p>
</section>
<section id="test-cases">
<h4>Test cases<a class="headerlink" href="#test-cases" title="Permalink to this heading">#</a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 1: </span>

<span class="c1"># Construct the tree</span>
<span class="n">root1</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">root1</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">root1</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">root1</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">root1</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">rightSideView</span><span class="p">(</span><span class="n">root1</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[1, 3, 4]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 2:</span>

<span class="n">root2</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">root2</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">rightSideView</span><span class="p">(</span><span class="n">root2</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[1, 3]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 3:</span>
<span class="c1"># Creating a new tree for this example</span>
<span class="n">root</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">rightSideView</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[]
</pre></div>
</div>
</div>
</div>
</section>
<section id="time-and-space-complexity-analysis">
<h4>Time and Space Complexity Analysis<a class="headerlink" href="#time-and-space-complexity-analysis" title="Permalink to this heading">#</a></h4>
<p>Let’s analyze the time and space complexity of the given code:</p>
<p><strong>Time Complexity:</strong></p>
<p>The time complexity of the code is O(N), where N is the number of nodes in the binary tree. Here’s why:</p>
<ol class="arabic simple">
<li><p>We perform a level-order traversal of the tree using a queue. In the worst case, we visit all nodes once, which takes O(N) time since we visit each node exactly once.</p></li>
<li><p>For each node, we perform constant-time operations like dequeuing it from the queue, checking if it’s the rightmost node at the current level, and enqueuing its children (if they exist). These operations do not depend on the size of the tree, so they do not contribute to the overall time complexity.</p></li>
</ol>
<p>Therefore, the dominant factor in the time complexity is the level-order traversal, making it O(N).</p>
<p><strong>Space Complexity:</strong></p>
<p>The space complexity of the code is also O(N). Here’s why:</p>
<ol class="arabic simple">
<li><p>We use a queue to perform level-order traversal. In the worst case, the queue can contain all nodes at the maximum width of the tree, which can be up to N/2 nodes for a completely unbalanced tree. Therefore, the space required for the queue is O(N).</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">result</span></code> list stores the values of the rightmost nodes. In the worst case, when the binary tree is a complete binary tree, it can have roughly N/2 rightmost nodes. Therefore, the space required for the <code class="docutils literal notranslate"><span class="pre">result</span></code> list is also O(N).</p></li>
<li><p>Other auxiliary variables like <code class="docutils literal notranslate"><span class="pre">level_size</span></code>, <code class="docutils literal notranslate"><span class="pre">i</span></code>, and <code class="docutils literal notranslate"><span class="pre">node</span></code> require only constant space and do not depend on the size of the tree.</p></li>
</ol>
<p>Combining the space used by the queue and the <code class="docutils literal notranslate"><span class="pre">result</span></code> list, we get a space complexity of O(N).</p>
<p>In summary, the code has a time complexity of O(N) and a space complexity of O(N), where N is the number of nodes in the binary tree. These complexities are efficient and scale linearly with the size of the input tree.</p>
</section>
<section id="challenging-exercises">
<h4>Challenging Exercises:<a class="headerlink" href="#challenging-exercises" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p><strong>Variant with Left Side View</strong>: Modify the code to find and return the values of nodes visible from the left side of the binary tree instead of the right side.</p></li>
<li><p><strong>Zigzag Right Side View</strong>: Extend the code to return the right side view values in a zigzag order. In a zigzag order, you alternate between starting from the rightmost node at level 0, then the leftmost at level 1, rightmost at level 2, and so on.</p></li>
</ol>
</section>
</section>
<span id="document-07. Trees/226. Invert Binary Tree"></span><section class="tex2jax_ignore mathjax_ignore" id="invert-binary-tree">
<h3>226: Invert Binary Tree<a class="headerlink" href="#invert-binary-tree" title="Permalink to this heading">#</a></h3>
<p><strong>Difficulty:</strong> Easy</p>
<p><strong>Link to Problem:</strong> <a class="reference external" href="https://leetcode.com/problems/invert-binary-tree/">To see the Invert Binary Tree problem on LeetCode, click here!</a></p>
<hr class="docutils" />
<p>Given the root of a binary tree, invert the tree, and return its root.</p>
<p><strong>Constraints:</strong></p>
<ul class="simple">
<li><p>The number of nodes in the tree is in the range <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">100]</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-100</span> <span class="pre">&lt;=</span> <span class="pre">Node.val</span> <span class="pre">&lt;=</span> <span class="pre">100</span></code></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Definition for a binary tree node.</span>
<span class="k">class</span> <span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

<span class="k">def</span> <span class="nf">invertTree</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="c1"># Base case: If the root is None or the tree is empty, return None.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Swap the left and right subtrees of the current node.</span>
    <span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span>

    <span class="c1"># Recursively invert the left and right subtrees.</span>
    <span class="n">invertTree</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
    <span class="n">invertTree</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">root</span>
</pre></div>
</div>
</div>
</div>
<section id="explanation">
<h4>Explanation:<a class="headerlink" href="#explanation" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p>We start by defining a TreeNode class, which represents a node in a binary tree. Each node has a value (<code class="docutils literal notranslate"><span class="pre">val</span></code>), a left child (<code class="docutils literal notranslate"><span class="pre">left</span></code>), and a right child (<code class="docutils literal notranslate"><span class="pre">right</span></code>).</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">invertTree</span></code> function is defined to invert the binary tree. It takes the root node of the tree as an argument.</p></li>
<li><p>In the <code class="docutils literal notranslate"><span class="pre">invertTree</span></code> function, we have a base case to handle the scenario when the root is <code class="docutils literal notranslate"><span class="pre">None</span></code> (empty tree). In such cases, we return <code class="docutils literal notranslate"><span class="pre">None</span></code> because there’s nothing to invert.</p></li>
<li><p>For non-empty trees, we swap the left and right subtrees of the current node. This effectively inverts the tree at the current node.</p></li>
<li><p>We then recursively call <code class="docutils literal notranslate"><span class="pre">invertTree</span></code> on the left and right subtrees to invert them.</p></li>
<li><p>Finally, we return the root of the inverted tree.</p></li>
</ol>
</section>
<section id="test-cases">
<h4>Test cases<a class="headerlink" href="#test-cases" title="Permalink to this heading">#</a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">### Example 1</span>
<span class="c1"># Input: root = [4,2,7,1,3,6,9]</span>

<span class="n">root1</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">root1</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">root1</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="n">root1</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">root1</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">root1</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="n">root1</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>

<span class="n">inverted_root1</span> <span class="o">=</span> <span class="n">invertTree</span><span class="p">(</span><span class="n">root1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Inverted Tree (Example 1):&quot;</span><span class="p">,</span> <span class="n">inverted_root1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Inverted Tree (Example 1): &lt;__main__.TreeNode object at 0x7f93e4299a20&gt;
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">### Example 2</span>
<span class="c1"># Input: root = [2,1,3]</span>

<span class="n">root2</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">root2</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">root2</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

<span class="n">inverted_root2</span> <span class="o">=</span> <span class="n">invertTree</span><span class="p">(</span><span class="n">root2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Inverted Tree (Example 2):&quot;</span><span class="p">,</span> <span class="n">inverted_root2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Inverted Tree (Example 2): &lt;__main__.TreeNode object at 0x7f93e4299cf0&gt;
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">### Example 3</span>
<span class="c1"># Input: root = []</span>

<span class="n">root3</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Empty tree</span>

<span class="n">inverted_root3</span> <span class="o">=</span> <span class="n">invertTree</span><span class="p">(</span><span class="n">root3</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Inverted Tree (Example 3):&quot;</span><span class="p">,</span> <span class="n">inverted_root3</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Inverted Tree (Example 3): None
</pre></div>
</div>
</div>
</div>
<p>Let’s discuss the time and space complexity of the provided Python code to invert a binary tree.</p>
<p><strong>Time Complexity:</strong></p>
<p>The time complexity of the <code class="docutils literal notranslate"><span class="pre">invertTree</span></code> function is <span class="math notranslate nohighlight">\(O(n)\)</span>, where <span class="math notranslate nohighlight">\(n\)</span> is the number of nodes in the binary tree. This is because we visit each node exactly once during the traversal of the tree. In the worst case, we have to visit all nodes in the tree.</p>
<p>The reason for this time complexity is the depth-first traversal of the tree, where we recursively process the left and right subtrees of each node.</p>
<p><strong>Space Complexity:</strong></p>
<p>The space complexity of the code is determined by the function call stack during the recursion. In the worst case, the space complexity is <span class="math notranslate nohighlight">\(O(h)\)</span>, where <span class="math notranslate nohighlight">\(h\)</span> is the height of the binary tree.</p>
<p>In a completely unbalanced binary tree (essentially a linked list), the height <span class="math notranslate nohighlight">\(h\)</span> is equal to the number of nodes <span class="math notranslate nohighlight">\(n\)</span>, resulting in a space complexity of <span class="math notranslate nohighlight">\(O(n)\)</span>. This occurs when the tree is skewed to one side.</p>
<p>In a balanced binary tree, such as a full binary tree, the height <span class="math notranslate nohighlight">\(h\)</span> is <span class="math notranslate nohighlight">\(O(log\ n)\)</span>, and the space complexity is <span class="math notranslate nohighlight">\(O(log\ n)\)</span>.</p>
<p>The space complexity depends on how balanced the tree is. In practical scenarios, binary trees are often approximately balanced, so the space complexity is typically closer to <span class="math notranslate nohighlight">\(O(log\ n)\)</span>.</p>
<p><strong>In summary:</strong></p>
<ul class="simple">
<li><p>Time Complexity: <span class="math notranslate nohighlight">\(O(n)\)</span> where <span class="math notranslate nohighlight">\(n\)</span> is the number of nodes.</p></li>
<li><p>Space Complexity: <span class="math notranslate nohighlight">\(O(h)\)</span>, where <span class="math notranslate nohighlight">\(h\)</span> is the height of the binary tree. In the worst case, it can be <span class="math notranslate nohighlight">\(O(n)\)</span>, and in a balanced tree, it is <span class="math notranslate nohighlight">\(O(log\ n)\)</span>.</p></li>
</ul>
<p>Keep in mind that these complexities are based on the recursive implementation provided. Iterative solutions can achieve the same task with <span class="math notranslate nohighlight">\(O(1)\)</span> space complexity, using auxiliary data structures like stacks or queues to mimic the recursion stack.</p>
</section>
</section>
<span id="document-07. Trees/230. Kth Smallest Element in a BST"></span><section class="tex2jax_ignore mathjax_ignore" id="kth-smallest-element-in-a-bst">
<h3>230. Kth Smallest Element in a BST<a class="headerlink" href="#kth-smallest-element-in-a-bst" title="Permalink to this heading">#</a></h3>
<p><strong>Difficulty:</strong> Medium</p>
<p><strong>Link to Problem:</strong> <a class="reference external" href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/">To see the Kth Smallest Element in a BST problem on LeetCode, click here!</a></p>
<hr class="docutils" />
<p>Given the <code class="docutils literal notranslate"><span class="pre">root</span></code> of a binary search tree, and an integer <code class="docutils literal notranslate"><span class="pre">k</span></code>, return <em>the <span class="math notranslate nohighlight">\(k^{th}\)</span> smallest value (<strong>1-indexed</strong>) of all the values of the nodes in the tree.</em></p>
<p><strong>Constraints:</strong></p>
<ul class="simple">
<li><p>The number of nodes in the tree is <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p></li>
<li><p>1 &lt;= <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">&lt;=</span> <span class="pre">n</span></code> &lt;= <span class="math notranslate nohighlight">\(10^4\)</span></p></li>
<li><p>0 &lt;= <code class="docutils literal notranslate"><span class="pre">Node.val</span></code> &lt;= <span class="math notranslate nohighlight">\(10^4\)</span></p></li>
</ul>
<p><strong>Follow up</strong>: If the BST is modified often (i.e., we can do insert and delete operations) and you need to find the kth smallest frequently, how would you optimize?</p>
<section id="solution">
<h4>Solution:<a class="headerlink" href="#solution" title="Permalink to this heading">#</a></h4>
<p>Here’s a Python function to solve this problem:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

<span class="k">def</span> <span class="nf">kthSmallest</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Initialize an empty stack to simulate the traversal</span>
    <span class="k">while</span> <span class="n">root</span> <span class="ow">or</span> <span class="n">stack</span><span class="p">:</span>
        <span class="k">while</span> <span class="n">root</span><span class="p">:</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>  <span class="c1"># Push the current node onto the stack</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span>  <span class="c1"># Move to the left child</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>  <span class="c1"># Pop a node from the stack</span>
        <span class="n">k</span> <span class="o">-=</span> <span class="mi">1</span>  <span class="c1"># Decrement k since we&#39;ve visited a node</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">root</span><span class="o">.</span><span class="n">val</span>  <span class="c1"># If k becomes 0, return the current node&#39;s value as the kth smallest</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span>  <span class="c1"># Move to the right child to continue the traversal</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="explanation">
<h4>Explanation:<a class="headerlink" href="#explanation" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p>We start by defining a <code class="docutils literal notranslate"><span class="pre">TreeNode</span></code> class, which represents a node in the binary search tree (BST). Each node has a value (<code class="docutils literal notranslate"><span class="pre">val</span></code>), a left child (<code class="docutils literal notranslate"><span class="pre">left</span></code>), and a right child (<code class="docutils literal notranslate"><span class="pre">right</span></code>).</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">kthSmallest</span></code> function takes two parameters: <code class="docutils literal notranslate"><span class="pre">root</span></code>, which is the root of the BST, and <code class="docutils literal notranslate"><span class="pre">k</span></code>, which represents the kth smallest element we want to find.</p></li>
<li><p>We initialize an empty stack (<code class="docutils literal notranslate"><span class="pre">stack</span></code>) to simulate the traversal of the BST. The stack will be used to keep track of nodes as we traverse the tree in an iterative manner.</p></li>
<li><p>We enter a while loop that continues until either <code class="docutils literal notranslate"><span class="pre">root</span></code> becomes <code class="docutils literal notranslate"><span class="pre">None</span></code> (indicating we have traversed the entire tree) or the <code class="docutils literal notranslate"><span class="pre">stack</span></code> is empty.</p></li>
<li><p>Within the loop, we start another while loop to traverse as far left as possible in the BST. We repeatedly push nodes onto the <code class="docutils literal notranslate"><span class="pre">stack</span></code> and move to their left children until we reach the leftmost leaf node. This is the smallest node in the BST.</p></li>
<li><p>Once we have reached the leftmost leaf node (the smallest node), we pop nodes from the <code class="docutils literal notranslate"><span class="pre">stack</span></code> one by one. As we pop each node, we decrement <code class="docutils literal notranslate"><span class="pre">k</span></code> by 1 to keep track of the number of nodes we have visited.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">k</span></code> becomes 0 after decrementing, it means we have found the kth smallest element. In this case, we return the <code class="docutils literal notranslate"><span class="pre">val</span></code> of the current node as the result.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">k</span></code> is still greater than 0, it means we haven’t found the kth smallest element yet. In this case, we move to the right child of the current node to continue the traversal, as the kth smallest element, if it exists, will be in the right subtree of the current node.</p></li>
<li><p>The process continues until we find the kth smallest element or traverse the entire tree.</p></li>
<li><p>Finally, we return the kth smallest element found.</p></li>
</ol>
<p>The key idea in this code is to perform an in-order traversal of the BST while keeping track of the kth smallest element. By visiting nodes in ascending order, we can efficiently find the kth smallest element in O(h + k) time, where h is the height of the BST and k is the desired kth element. This approach is both concise and efficient for this problem.</p>
</section>
<section id="test-cases">
<h4>Test cases<a class="headerlink" href="#test-cases" title="Permalink to this heading">#</a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 1: </span>

<span class="c1"># Example usage:</span>
<span class="c1"># Create the tree for the first example: root = [3,1,4,null,2], k = 1</span>
<span class="n">root1</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">root1</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">root1</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">root1</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">k1</span> <span class="o">=</span> <span class="mi">1</span>
<span class="nb">print</span><span class="p">(</span><span class="n">kthSmallest</span><span class="p">(</span><span class="n">root1</span><span class="p">,</span> <span class="n">k1</span><span class="p">))</span> 
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 2:</span>

<span class="c1"># Create the tree for the second example: root = [5,3,6,2,4,null,null,1], k = 3</span>
<span class="n">root2</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">root2</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">root2</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="n">root2</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">root2</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">root2</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">k2</span> <span class="o">=</span> <span class="mi">3</span>
<span class="nb">print</span><span class="p">(</span><span class="n">kthSmallest</span><span class="p">(</span><span class="n">root2</span><span class="p">,</span> <span class="n">k2</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>3
</pre></div>
</div>
</div>
</div>
</section>
<section id="time-and-space-complexity-analysis">
<h4>Time and Space Complexity Analysis<a class="headerlink" href="#time-and-space-complexity-analysis" title="Permalink to this heading">#</a></h4>
<p>Let’s analyze the time and space complexity of the given code:</p>
<p><strong>Time Complexity:</strong></p>
<p>The time complexity of this code is O(h + k), where:</p>
<ul class="simple">
<li><p>h is the height of the binary search tree (BST).</p></li>
<li><p>k is the desired kth smallest element we want to find.</p></li>
</ul>
<ol class="arabic simple">
<li><p>In the worst case, where the BST is highly unbalanced and resembles a linked list, the height (h) of the tree can be equal to the number of nodes (n) in the tree. In this case, the time complexity is O(n + k).</p></li>
<li><p>In the best case, where the BST is perfectly balanced, the height (h) is log(n), where n is the number of nodes in the tree. In this case, the time complexity is O(log(n) + k).</p></li>
</ol>
<p>So, the time complexity can vary from O(log(n) + k) in the best-case scenario to O(n + k) in the worst-case scenario. Typically, for balanced BSTs, the time complexity is closer to O(log(n) + k).</p>
<p><strong>Space Complexity:</strong></p>
<p>The space complexity of this code is O(h) due to the stack used for the iterative in-order traversal, where h is the height of the BST.</p>
<ol class="arabic simple">
<li><p>In the worst case, when the BST is highly unbalanced and resembles a linked list, the height (h) of the tree can be equal to the number of nodes (n) in the tree. In this case, the space complexity is O(n) because the stack can potentially store all n nodes.</p></li>
<li><p>In the best case, when the BST is perfectly balanced, the height (h) is log(n), where n is the number of nodes in the tree. In this case, the space complexity is O(log(n)) because the stack will have at most log(n) nodes.</p></li>
</ol>
<p>So, the space complexity depends on the height of the BST and can vary from O(log(n)) in the best-case scenario to O(n) in the worst-case scenario.</p>
<p>In practical terms, for balanced BSTs or moderately unbalanced BSTs, the space complexity is usually close to O(log(n)), and the code is efficient in terms of space usage.</p>
</section>
<section id="challenging-exercises">
<h4>Challenging Exercises:<a class="headerlink" href="#challenging-exercises" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p><strong>Kth Largest Element</strong>: Modify the code to find the kth largest element in the BST instead of the kth smallest element.</p></li>
<li><p><strong>Kth Smallest Element in Two BSTs</strong>: Given two BSTs, find the kth smallest element when considering both BSTs as a single sorted list. This involves merging the two BSTs while finding the kth element efficiently.</p></li>
</ol>
</section>
</section>
<span id="document-07. Trees/235. Lowest Common Ancestor of a Binary Search Tree"></span><section class="tex2jax_ignore mathjax_ignore" id="lowest-common-ancestor-of-a-binary-search-tree">
<h3>235. Lowest Common Ancestor of a Binary Search Tree<a class="headerlink" href="#lowest-common-ancestor-of-a-binary-search-tree" title="Permalink to this heading">#</a></h3>
<p><strong>Difficulty:</strong> Medium</p>
<p><strong>Link to Problem:</strong> <a class="reference external" href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">To see the Lowest Common Ancestor of a Binary Search Tree problem on LeetCode, click here!</a></p>
<hr class="docutils" />
<p>Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.</p>
<p>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes <code class="docutils literal notranslate"><span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">q</span></code> as the lowest node in <code class="docutils literal notranslate"><span class="pre">T</span></code> that has both <code class="docutils literal notranslate"><span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">q</span></code> as descendants (where we allow <strong>a node to be a descendant of itself</strong>).”</p>
<p><strong>Constraints:</strong></p>
<ul class="simple">
<li><p>The number of nodes in the tree is in the range <span class="math notranslate nohighlight">\([2, 10^5]\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(-10^9\)</span> &lt;= <code class="docutils literal notranslate"><span class="pre">Node.val</span></code> &lt;= <span class="math notranslate nohighlight">\(10^9\)</span></p></li>
<li><p>All <code class="docutils literal notranslate"><span class="pre">Node.val</span></code> are <strong>unique</strong>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">!=</span> <span class="pre">q</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">q</span></code> will exist in the BST.</p></li>
</ul>
<section id="solution">
<h4>Solution:<a class="headerlink" href="#solution" title="Permalink to this heading">#</a></h4>
<p>Here’s a Python function to solve this problem:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

<span class="k">def</span> <span class="nf">lowestCommonAncestor</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
    <span class="c1"># Ensure p is less than q</span>
    <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">q</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
        <span class="n">p</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="p">,</span> <span class="n">p</span>

    <span class="k">while</span> <span class="n">root</span><span class="p">:</span>
        <span class="c1"># If the current node value is greater than both p and q, move left</span>
        <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">q</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span>
        <span class="c1"># If the current node value is less than both p and q, move right</span>
        <span class="k">elif</span> <span class="n">root</span><span class="o">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">p</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span>
        <span class="c1"># If the current node value is between p and q (inclusive), or it matches either p or q, it&#39;s the LCA</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">root</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="explanation">
<h4>Explanation:<a class="headerlink" href="#explanation" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">class</span> <span class="pre">TreeNode:</span></code> defines a simple class for representing nodes in a binary tree. Each <code class="docutils literal notranslate"><span class="pre">TreeNode</span></code> has three attributes:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">val</span></code>: The value of the node.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">left</span></code>: A reference to the left child node.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">right</span></code>: A reference to the right child node.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">def</span> <span class="pre">lowestCommonAncestor(root,</span> <span class="pre">p,</span> <span class="pre">q):</span></code> is a function that takes three arguments:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">root</span></code>: The root node of the BST.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">p</span></code>: A TreeNode representing one of the nodes for which we want to find the LCA.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">q</span></code>: A TreeNode representing the other node for which we want to find the LCA.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">p.val</span> <span class="pre">&gt;</span> <span class="pre">q.val:</span></code> checks if the value of <code class="docutils literal notranslate"><span class="pre">p</span></code> is greater than the value of <code class="docutils literal notranslate"><span class="pre">q</span></code>. In a BST, it’s essential to ensure that <code class="docutils literal notranslate"><span class="pre">p</span></code> represents the smaller value, and <code class="docutils literal notranslate"><span class="pre">q</span></code> represents the larger value. If <code class="docutils literal notranslate"><span class="pre">p</span></code> is greater than <code class="docutils literal notranslate"><span class="pre">q</span></code>, the code swaps their values.</p></li>
<li><p>The main logic is inside the <code class="docutils literal notranslate"><span class="pre">while</span></code> loop, which runs until <code class="docutils literal notranslate"><span class="pre">root</span></code> becomes <code class="docutils literal notranslate"><span class="pre">None</span></code>. It performs the following steps to find the LCA:</p>
<ul class="simple">
<li><p>If the current <code class="docutils literal notranslate"><span class="pre">root</span></code> node’s value is greater than the value of <code class="docutils literal notranslate"><span class="pre">q</span></code>, it means both <code class="docutils literal notranslate"><span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">q</span></code> are on the left subtree of the current node. So, we move to the left child of the current node by setting <code class="docutils literal notranslate"><span class="pre">root</span> <span class="pre">=</span> <span class="pre">root.left</span></code>.</p></li>
<li><p>If the current <code class="docutils literal notranslate"><span class="pre">root</span></code> node’s value is less than the value of <code class="docutils literal notranslate"><span class="pre">p</span></code>, it means both <code class="docutils literal notranslate"><span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">q</span></code> are on the right subtree of the current node. So, we move to the right child of the current node by setting <code class="docutils literal notranslate"><span class="pre">root</span> <span class="pre">=</span> <span class="pre">root.right</span></code>.</p></li>
<li><p>If neither of the above conditions is met, it means the current <code class="docutils literal notranslate"><span class="pre">root</span></code> node’s value is between <code class="docutils literal notranslate"><span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">q</span></code>, or it matches either <code class="docutils literal notranslate"><span class="pre">p</span></code> or <code class="docutils literal notranslate"><span class="pre">q</span></code>. In this case, the current node is the lowest common ancestor (LCA), so we return <code class="docutils literal notranslate"><span class="pre">root</span></code>.</p></li>
</ul>
</li>
</ol>
<p>The algorithm is efficient because it takes advantage of the properties of a BST. It eliminates subtrees that cannot contain the LCA by comparing the values of <code class="docutils literal notranslate"><span class="pre">p</span></code>, <code class="docutils literal notranslate"><span class="pre">q</span></code>, and the current <code class="docutils literal notranslate"><span class="pre">root</span></code> node. Eventually, it reaches the LCA node, and that node is returned as the result.</p>
</section>
<section id="test-cases">
<h4>Test cases<a class="headerlink" href="#test-cases" title="Permalink to this heading">#</a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 1: </span>

<span class="c1"># Construct the tree</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
<span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span>  <span class="c1"># Node 2</span>
<span class="n">q</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span>  <span class="c1"># Node 8</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">lowestCommonAncestor</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>6
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 2:</span>

<span class="c1"># Using the same tree as before</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span>  <span class="c1"># Node 2</span>
<span class="n">q</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">right</span>  <span class="c1"># Node 4</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">lowestCommonAncestor</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">val</span><span class="p">)</span> 
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 3:</span>
<span class="c1"># Creating a new tree for this example</span>
<span class="n">root2</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">root2</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">root2</span>  <span class="c1"># Node 2</span>
<span class="n">q</span> <span class="o">=</span> <span class="n">root2</span><span class="o">.</span><span class="n">left</span>  <span class="c1"># Node 1</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">lowestCommonAncestor</span><span class="p">(</span><span class="n">root2</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2
</pre></div>
</div>
</div>
</div>
</section>
<section id="time-and-space-complexity-analysis">
<h4>Time and Space Complexity Analysis<a class="headerlink" href="#time-and-space-complexity-analysis" title="Permalink to this heading">#</a></h4>
<p>Let’s analyze the time and space complexity of the provided algorithm for finding the lowest common ancestor (LCA) in a Binary Search Tree (BST).</p>
<p><strong>Time Complexity:</strong>
The time complexity of this algorithm is O(h), where “h” is the height of the BST. In the worst case, where the tree is completely unbalanced (essentially a linked list), the height of the tree is O(n), where “n” is the number of nodes in the tree. However, in a well-balanced BST, the height is logarithmic, which is O(log n).</p>
<p>The reason for this time complexity is that the algorithm efficiently narrows down the search space by traversing either left or right subtrees based on the values of the target nodes <code class="docutils literal notranslate"><span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">q</span></code>. It eliminates entire subtrees that cannot contain the LCA, leading to a relatively quick search.</p>
<p><strong>Space Complexity:</strong>
The space complexity of the algorithm is O(1). This is because it uses a constant amount of extra space, regardless of the size of the input BST. The only variables used are <code class="docutils literal notranslate"><span class="pre">root</span></code>, <code class="docutils literal notranslate"><span class="pre">p</span></code>, and <code class="docutils literal notranslate"><span class="pre">q</span></code>, and there are no data structures like stacks or queues used for additional space. The algorithm performs a simple traversal without recursion, so it does not consume extra memory as the tree depth increases.</p>
<p><strong>In summary</strong>, the provided algorithm for finding the LCA in a BST is both time and space-efficient. Its time complexity is O(h), where “h” is the height of the tree, and its space complexity is O(1), making it suitable for practical use even in large BSTs.</p>
<section id="challenging-exercises">
<h5>Challenging Exercises:<a class="headerlink" href="#challenging-exercises" title="Permalink to this heading">#</a></h5>
<ol class="arabic simple">
<li><p><strong>Multiple LCAs:</strong> Extend the algorithm to find all the lowest common ancestors of two given nodes <code class="docutils literal notranslate"><span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">q</span></code> in a BST. In some cases, there can be multiple LCAs.</p></li>
<li><p><strong>LCA with k Nodes:</strong> Given a BST and k nodes, find the lowest common ancestor of these k nodes. This is an extension of the problem where you must find the LCA of more than two nodes.</p></li>
</ol>
</section>
</section>
</section>
<span id="document-07. Trees/297. Serialize and Deserialize Binary Tree"></span><section class="tex2jax_ignore mathjax_ignore" id="serialize-and-deserialize-binary-tree">
<h3>297. Serialize and Deserialize Binary Tree<a class="headerlink" href="#serialize-and-deserialize-binary-tree" title="Permalink to this heading">#</a></h3>
<p><strong>Difficulty:</strong> Hard</p>
<p><strong>Link to Problem:</strong> <a class="reference external" href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/">To see the Serialize and Deserialize Binary Tree problem on LeetCode, click here!</a></p>
<hr class="docutils" />
<p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p>
<p>Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.</p>
<p><strong>Clarification:</strong> The input/output format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.</p>
<p><strong>Constraints:</strong></p>
<ul class="simple">
<li><p>The number of nodes in the tree is in the range <span class="math notranslate nohighlight">\([0, 10^4]\)</span>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-1000</span> <span class="pre">&lt;=</span> <span class="pre">Node.val</span> <span class="pre">&lt;=</span> <span class="pre">1000</span></code></p></li>
</ul>
<section id="probelm-explanation">
<h4>Probelm Explanation:<a class="headerlink" href="#probelm-explanation" title="Permalink to this heading">#</a></h4>
<p>TThe problem is to design an algorithm to serialize and deserialize a binary tree. Serialization is the process of converting a data structure or object into a sequence of characters or bytes so that it can be easily stored in a file, transmitted over a network, or otherwise persisted. Deserialization is the reverse process of converting the serialized data back into the original data structure.</p>
<p>In the context of this problem:</p>
<ol class="arabic simple">
<li><p><strong>Serialization</strong>: You are given a binary tree, and your task is to convert it into a string representation such that you can later recreate the same binary tree from this string. The format of serialization is flexible, but it should allow you to reconstruct the original binary tree accurately.</p></li>
<li><p><strong>Deserialization</strong>: Given a serialized string, you need to reconstruct the binary tree it represents, ensuring that it is identical to the original tree.</p></li>
</ol>
<p>Here are some key points to consider in solving this problem:</p>
<ul class="simple">
<li><p>The input can include any valid binary tree, including trees with nodes having integer values within the range [-1000, 1000].</p></li>
<li><p>You don’t necessarily need to follow a specific format for serialization, but it should be designed in a way that allows unambiguous deserialization.</p></li>
<li><p>The goal is to serialize the tree structure and its values and then deserialize it back into the same structure and values.</p></li>
</ul>
<p>A common approach for serialization is to use a traversal method like preorder traversal, where you visit nodes in the order: root, left subtree, right subtree. This way, you can serialize the tree into a string, and during deserialization, you can reconstruct the tree by parsing the string in the same order.</p>
</section>
<section id="solution">
<h4>Solution:<a class="headerlink" href="#solution" title="Permalink to this heading">#</a></h4>
<p>Here’s a Python function to implement this algorithm:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Definition for a binary tree node.</span>
<span class="k">class</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="kc">None</span>

<span class="k">class</span> <span class="nc">Codec</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
        <span class="n">serialized</span>  <span class="o">=</span> <span class="p">[]</span>

        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
                <span class="c1"># If the node is None, represent it as &quot;Null&quot; in the serialized string</span>
                <span class="n">serialized</span> <span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Null&quot;</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="c1"># Convert the node&#39;s value to a string and add it to the serialized string</span>
            <span class="n">serialized</span> <span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">val</span><span class="p">))</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>

        <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="c1"># Join the serialized values with &quot;,&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">serialized</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">def</span> <span class="nf">dfs</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">vals</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;Null&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="c1"># Convert the value to an integer to create a new node</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">node</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">()</span>
            <span class="n">node</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">node</span>

        <span class="k">return</span> <span class="n">dfs</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="explanation">
<h4>Explanation:<a class="headerlink" href="#explanation" title="Permalink to this heading">#</a></h4>
<p>Here’s a step-by-step explanation of the code:</p>
<ol class="arabic simple">
<li><p><strong>Definition of TreeNode</strong>:</p>
<ul class="simple">
<li><p>The code defines a simple <code class="docutils literal notranslate"><span class="pre">TreeNode</span></code> class that represents a node in a binary tree. Each <code class="docutils literal notranslate"><span class="pre">TreeNode</span></code> has three attributes:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">val</span></code>: The integer value stored in the node.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">left</span></code>: A reference to the left child node (or None if there is no left child).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">right</span></code>: A reference to the right child node (or None if there is no right child).</p></li>
</ul>
</li>
<li><p>This class allows you to create binary tree nodes with integer values and left and right child references.</p></li>
</ul>
</li>
<li><p><strong>Serialization (serialize method)</strong>:</p>
<ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">serialize</span></code> method takes a <code class="docutils literal notranslate"><span class="pre">root</span></code> node as input, which is the root of the binary tree that needs to be serialized.</p></li>
<li><p>It initializes an empty list <code class="docutils literal notranslate"><span class="pre">serialized</span></code> to store the serialized elements.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">dfs</span></code> (depth-first search) function is defined within the <code class="docutils literal notranslate"><span class="pre">serialize</span></code> method to perform a preorder traversal of the binary tree.</p></li>
<li><p>In the <code class="docutils literal notranslate"><span class="pre">dfs</span></code> function:</p>
<ul>
<li><p>If the current <code class="docutils literal notranslate"><span class="pre">node</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code> (i.e., a leaf node or a child of a leaf node), it appends the string “Null” to the <code class="docutils literal notranslate"><span class="pre">serialized</span></code> list to represent the absence of a node.</p></li>
<li><p>If the current <code class="docutils literal notranslate"><span class="pre">node</span></code> is not <code class="docutils literal notranslate"><span class="pre">None</span></code>, it appends the string representation of the <code class="docutils literal notranslate"><span class="pre">node.val</span></code> to the <code class="docutils literal notranslate"><span class="pre">serialized</span></code> list and then recursively calls <code class="docutils literal notranslate"><span class="pre">dfs</span></code> on the left and right children.</p></li>
</ul>
</li>
<li><p>After the <code class="docutils literal notranslate"><span class="pre">dfs</span></code> traversal, the <code class="docutils literal notranslate"><span class="pre">serialized</span></code> list contains the serialized binary tree elements.</p></li>
<li><p>The method returns a string obtained by joining the elements in the <code class="docutils literal notranslate"><span class="pre">serialized</span></code> list with commas.</p></li>
</ul>
</li>
<li><p><strong>Deserialization (deserialize method)</strong>:</p>
<ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">deserialize</span></code> method takes a serialized string <code class="docutils literal notranslate"><span class="pre">data</span></code> as input, which represents a binary tree in the custom format.</p></li>
<li><p>It splits the <code class="docutils literal notranslate"><span class="pre">data</span></code> string by commas to obtain a list of elements called <code class="docutils literal notranslate"><span class="pre">vals</span></code>.</p></li>
<li><p>The method initializes an index <code class="docutils literal notranslate"><span class="pre">self.i</span></code> to 0. This index keeps track of the current position in the <code class="docutils literal notranslate"><span class="pre">vals</span></code> list during deserialization.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">dfs</span></code> function is defined within the <code class="docutils literal notranslate"><span class="pre">deserialize</span></code> method to perform the deserialization process using a recursive approach.</p></li>
<li><p>In the <code class="docutils literal notranslate"><span class="pre">dfs</span></code> function:</p>
<ul>
<li><p>If the current element in <code class="docutils literal notranslate"><span class="pre">vals</span></code> is “Null,” it means there is no node at this position in the binary tree, so it returns <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p></li>
<li><p>If the current element is not “Null,” it converts the element to an integer to create a new <code class="docutils literal notranslate"><span class="pre">TreeNode</span></code> with that value.</p></li>
<li><p>It then recursively calls <code class="docutils literal notranslate"><span class="pre">dfs</span></code> to set the left and right children of the current node.</p></li>
</ul>
</li>
<li><p>The method returns the root node of the reconstructed binary tree.</p></li>
</ul>
</li>
</ol>
<p>Overall, this code demonstrates a way to serialize a binary tree into a string format and then deserialize it back into the original tree structure, allowing for the representation of both the tree structure and the values stored in the nodes.</p>
</section>
<section id="test-cases">
<h4>Test cases:<a class="headerlink" href="#test-cases" title="Permalink to this heading">#</a></h4>
<p>Here’s how you can use this solution:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 1: </span>

<span class="c1"># Example usage:</span>
<span class="c1"># Serialize a binary tree</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>

<span class="n">codec</span> <span class="o">=</span> <span class="n">Codec</span><span class="p">()</span>
<span class="n">serialized_tree</span> <span class="o">=</span> <span class="n">codec</span><span class="o">.</span><span class="n">serialize</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">serialized_tree</span><span class="p">)</span>

<span class="c1"># Deserialize the serialized tree</span>
<span class="n">new_root</span> <span class="o">=</span> <span class="n">codec</span><span class="o">.</span><span class="n">deserialize</span><span class="p">(</span><span class="n">serialized_tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1,2,Null,Null,3,4,Null,Null,5,Null,Null
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 2:</span>

<span class="c1"># Example usage:</span>
<span class="c1"># Serialize a binary tree</span>
<span class="n">root</span> <span class="o">=</span> <span class="kc">None</span>

<span class="n">codec</span> <span class="o">=</span> <span class="n">Codec</span><span class="p">()</span>
<span class="n">serialized_tree</span> <span class="o">=</span> <span class="n">codec</span><span class="o">.</span><span class="n">serialize</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">serialized_tree</span><span class="p">)</span>

<span class="c1"># Deserialize the serialized tree</span>
<span class="n">new_root</span> <span class="o">=</span> <span class="n">codec</span><span class="o">.</span><span class="n">deserialize</span><span class="p">(</span><span class="n">serialized_tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Null
</pre></div>
</div>
</div>
</div>
</section>
<section id="time-and-space-complexity-analysis">
<h4>Time and Space Complexity Analysis<a class="headerlink" href="#time-and-space-complexity-analysis" title="Permalink to this heading">#</a></h4>
<p>Let’s analyze the time and space complexity of the provided code for serializing and deserializing a binary tree:</p>
<ol class="arabic simple">
<li><p><strong>Serialization (serialize method)</strong>:</p>
<ul class="simple">
<li><p>Time Complexity:</p>
<ul>
<li><p>The <code class="docutils literal notranslate"><span class="pre">serialize</span></code> method uses a depth-first traversal (preorder) of the binary tree.</p></li>
<li><p>It visits each node exactly once.</p></li>
<li><p>At each node, it performs constant-time operations (string conversion and list append).</p></li>
<li><p>Therefore, the time complexity for serialization is O(N), where N is the number of nodes in the binary tree.</p></li>
</ul>
</li>
<li><p>Space Complexity:</p>
<ul>
<li><p>The space complexity for serialization includes the space used by the <code class="docutils literal notranslate"><span class="pre">serialized</span></code> list and the recursive call stack.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">serialized</span></code> list stores the serialized elements, and its space is proportional to the number of nodes.</p></li>
<li><p>The recursive call stack depth is determined by the height of the binary tree, and in the worst case (completely unbalanced tree), it can be O(N).</p></li>
<li><p>Therefore, the space complexity for serialization is O(N) due to the list and O(H) due to the recursive call stack, where H is the height of the tree. In most cases, the dominant factor is O(N).</p></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Deserialization (deserialize method)</strong>:</p>
<ul class="simple">
<li><p>Time Complexity:</p>
<ul>
<li><p>The <code class="docutils literal notranslate"><span class="pre">deserialize</span></code> method splits the serialized string into a list of elements, which takes O(N) time.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">dfs</span></code> function is a recursive function that visits each element in the list exactly once.</p></li>
<li><p>At each element, it performs constant-time operations (string comparison, integer conversion, and recursive function calls).</p></li>
<li><p>Therefore, the time complexity for deserialization is O(N).</p></li>
</ul>
</li>
<li><p>Space Complexity:</p>
<ul>
<li><p>The space complexity for deserialization includes the space used by the <code class="docutils literal notranslate"><span class="pre">vals</span></code> list and the recursive call stack.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">vals</span></code> list stores the elements from the serialized string, and its space is proportional to the number of nodes.</p></li>
<li><p>The recursive call stack depth is determined by the height of the binary tree, and in the worst case (completely unbalanced tree), it can be O(N).</p></li>
<li><p>Therefore, the space complexity for deserialization is O(N) due to the list and O(H) due to the recursive call stack, where H is the height of the tree. In most cases, the dominant factor is O(N).</p></li>
</ul>
</li>
</ul>
</li>
</ol>
<p>Overall, the provided code has a time complexity of O(N) for both serialization and deserialization and a space complexity of O(N) in the majority of cases (unless the tree is severely unbalanced, in which case the height H dominates the space complexity). It efficiently serializes and deserializes a binary tree while using a linear amount of memory.</p>
</section>
<section id="challenging-exercises">
<h4>Challenging Exercises:<a class="headerlink" href="#challenging-exercises" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p><strong>Efficient Serialization</strong>:
Optimize the serialization process to minimize the length of the serialized string. Consider using techniques like binary encoding to represent node values more efficiently.</p></li>
<li><p><strong>Custom Serialization Format</strong>:
Modify the serialization and deserialization methods to use a custom format different from the one provided. Ensure that the new format allows for accurate reconstruction of the original binary tree.</p></li>
</ol>
</section>
</section>
<span id="document-07. Trees/572. Subtree of Another Tree"></span><section class="tex2jax_ignore mathjax_ignore" id="subtree-of-another-tree">
<h3>572: Subtree of Another Tree<a class="headerlink" href="#subtree-of-another-tree" title="Permalink to this heading">#</a></h3>
<p><strong>Difficulty:</strong> Easy</p>
<p><strong>Link to Problem:</strong> <a class="reference external" href="https://leetcode.com/problems/subtree-of-another-tree/">To see the Subtree of Another Tree problem on LeetCode, click here!</a></p>
<hr class="docutils" />
<p><strong>Problem Description:</strong></p>
<p>Given the roots of two binary trees <code class="docutils literal notranslate"><span class="pre">root</span></code> and <code class="docutils literal notranslate"><span class="pre">subRoot</span></code>, return <code class="docutils literal notranslate"><span class="pre">True</span></code> if there is a subtree of <code class="docutils literal notranslate"><span class="pre">root</span></code> with the same structure and node values as <code class="docutils literal notranslate"><span class="pre">subRoot</span></code>, and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>A subtree of a binary tree <code class="docutils literal notranslate"><span class="pre">tree</span></code> is a tree that consists of a node in <code class="docutils literal notranslate"><span class="pre">tree</span></code> and all of this node’s descendants. The tree <code class="docutils literal notranslate"><span class="pre">tree</span></code> could also be considered as a subtree of itself.</p>
<p><strong>Constraints:</strong></p>
<ol class="arabic simple">
<li><p>The number of nodes in the <code class="docutils literal notranslate"><span class="pre">root</span></code> tree is in the range <span class="math notranslate nohighlight">\([1, 2000]\)</span>.</p></li>
<li><p>The number of nodes in the <code class="docutils literal notranslate"><span class="pre">subRoot</span></code> tree is in the range <span class="math notranslate nohighlight">\([1, 1000]\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(-10^4\)</span> &lt;= root.val &lt;= <span class="math notranslate nohighlight">\(10^4\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(-10^4\)</span> &lt;= subRoot.val &lt;= <span class="math notranslate nohighlight">\(10^4\)</span></p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Definition for a binary tree node.</span>
<span class="k">class</span> <span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isSubtree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">subRoot</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        
        <span class="c1"># Check if the current subtree is equal to the subRoot</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isSameTree</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">subRoot</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        
        <span class="c1"># Recursively check the left and right subtrees</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">isSubtree</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">subRoot</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">isSubtree</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">subRoot</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">isSameTree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree1</span><span class="p">,</span> <span class="n">tree2</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">tree1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">tree2</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">tree1</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">tree2</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">tree1</span><span class="o">.</span><span class="n">val</span> <span class="o">==</span> <span class="n">tree2</span><span class="o">.</span><span class="n">val</span> <span class="ow">and</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">isSameTree</span><span class="p">(</span><span class="n">tree1</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">tree2</span><span class="o">.</span><span class="n">left</span><span class="p">)</span> <span class="ow">and</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">isSameTree</span><span class="p">(</span><span class="n">tree1</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">tree2</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
        <span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>This code defines a TreeNode class for the binary tree nodes and a Solution class with two methods:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">isSubtree</span></code>: This method checks if there is a subtree of the <code class="docutils literal notranslate"><span class="pre">root</span></code> tree with the same structure and node values as the <code class="docutils literal notranslate"><span class="pre">subRoot</span></code> tree. It uses a helper function <code class="docutils literal notranslate"><span class="pre">isSameTree</span></code> to compare two trees for equality.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">isSameTree</span></code>: This helper method recursively compares two trees to check if they are the same in structure and node values.</p></li>
</ol>
<section id="here-s-a-detailed-explanation-of-the-code">
<h4>Here’s a detailed explanation of the code:<a class="headerlink" href="#here-s-a-detailed-explanation-of-the-code" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p><strong>TreeNode Class:</strong></p></li>
</ol>
<p>The <code class="docutils literal notranslate"><span class="pre">TreeNode</span></code> class is defined to represent nodes in a binary tree. Each node has a <code class="docutils literal notranslate"><span class="pre">val</span></code> (the node’s value) and may have a <code class="docutils literal notranslate"><span class="pre">left</span></code> and <code class="docutils literal notranslate"><span class="pre">right</span></code> child.</p>
<ol class="arabic simple" start="2">
<li><p><strong>Solution Class:</strong></p>
<ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">Solution</span></code> class contains the solution for the problem and defines two important methods:</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">isSubtree(self,</span> <span class="pre">root,</span> <span class="pre">subRoot)</span></code>:</p>
<ul>
<li><p>This method checks whether <code class="docutils literal notranslate"><span class="pre">subRoot</span></code> is a subtree of <code class="docutils literal notranslate"><span class="pre">root</span></code>. It takes two tree nodes, <code class="docutils literal notranslate"><span class="pre">root</span></code> and <code class="docutils literal notranslate"><span class="pre">subRoot</span></code>, as input arguments.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">root</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, it returns <code class="docutils literal notranslate"><span class="pre">False</span></code> because there is no subtree to search.</p></li>
<li><p>It then checks if the current subtree with <code class="docutils literal notranslate"><span class="pre">root</span></code> as its root is equal to <code class="docutils literal notranslate"><span class="pre">subRoot</span></code> using the <code class="docutils literal notranslate"><span class="pre">isSameTree</span></code> method. If they are the same, it returns <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p></li>
<li><p>If the current subtree is not the same as <code class="docutils literal notranslate"><span class="pre">subRoot</span></code>, it recursively checks the left and right subtrees of <code class="docutils literal notranslate"><span class="pre">root</span></code> to see if <code class="docutils literal notranslate"><span class="pre">subRoot</span></code> is a subtree of any of them.</p></li>
<li><p>It returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">subRoot</span></code> is found in either the left or right subtree; otherwise, it returns <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">isSameTree(self,</span> <span class="pre">tree1,</span> <span class="pre">tree2)</span></code>:</p>
<ul>
<li><p>This method checks whether two trees, <code class="docutils literal notranslate"><span class="pre">tree1</span></code> and <code class="docutils literal notranslate"><span class="pre">tree2</span></code>, are the same.</p></li>
<li><p>If both <code class="docutils literal notranslate"><span class="pre">tree1</span></code> and <code class="docutils literal notranslate"><span class="pre">tree2</span></code> are <code class="docutils literal notranslate"><span class="pre">None</span></code>, they are considered the same tree, so it returns <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p></li>
<li><p>If only one of them is <code class="docutils literal notranslate"><span class="pre">None</span></code> (but not both), they are different trees, so it returns <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
<li><p>If both <code class="docutils literal notranslate"><span class="pre">tree1</span></code> and <code class="docutils literal notranslate"><span class="pre">tree2</span></code> have values, it checks if their values are equal and recursively checks if their left and right subtrees are the same.</p></li>
<li><p>It returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if the trees are the same; otherwise, it returns <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
</ul>
</li>
</ul>
</li>
</ol>
<p>The code effectively uses recursion to traverse the binary trees and check for subtree equality. The <code class="docutils literal notranslate"><span class="pre">isSubtree</span></code> method starts the recursive search, and the <code class="docutils literal notranslate"><span class="pre">isSameTree</span></code> method is used to compare individual subtrees. The approach is efficient and avoids unnecessary checks when possible.</p>
<p>This solution allows you to determine if there exists a subtree within the <code class="docutils literal notranslate"><span class="pre">root</span></code> tree that matches the structure and node values of <code class="docutils literal notranslate"><span class="pre">subRoot</span></code>.</p>
</section>
<section id="test-cases">
<h4>Test cases<a class="headerlink" href="#test-cases" title="Permalink to this heading">#</a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#root = [3,4,5,1,2]</span>
<span class="c1">#subRoot = [4,1,2]</span>

<span class="c1"># Example input</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="n">subRoot</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">subRoot</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">subRoot</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># Create an instance of the Solution class</span>
<span class="n">solution</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">()</span>

<span class="c1"># Test the isSubtree method</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">solution</span><span class="o">.</span><span class="n">isSubtree</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">subRoot</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Is subRoot a subtree of root?&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Is subRoot a subtree of root? True
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#root = [3,4,5,1,2,null,null,null,null,0] </span>
<span class="c1">#subRoot = [4,1,2]</span>


<span class="c1"># Example input</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="n">subRoot</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">subRoot</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">subRoot</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># Create an instance of the Solution class</span>
<span class="n">solution</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">()</span>

<span class="c1"># Test the isSubtree method</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">solution</span><span class="o">.</span><span class="n">isSubtree</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">subRoot</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Is subRoot a subtree of root?&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Is subRoot a subtree of root? False
</pre></div>
</div>
</div>
</div>
<p>Let’s analyze the time and space complexity of the provided code for the “Subtree of Another Tree” problem:</p>
<p><strong>Time Complexity</strong></p>
<p>The time complexity of the code primarily depends on the recursive traversal of the binary tree. In both the <code class="docutils literal notranslate"><span class="pre">isSubtree</span></code> and <code class="docutils literal notranslate"><span class="pre">isSameTree</span></code> functions, we visit each node in the binary trees once. Let’s break down the time complexity:</p>
<ol class="arabic simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">isSubtree</span></code> function:</p>
<ul class="simple">
<li><p>In the worst case, we need to visit every node in the <code class="docutils literal notranslate"><span class="pre">root</span></code> tree.</p></li>
<li><p>For each node in the <code class="docutils literal notranslate"><span class="pre">root</span></code> tree, we call the <code class="docutils literal notranslate"><span class="pre">isSameTree</span></code> function, which has its own traversal.</p></li>
<li><p>So, the total time complexity is <span class="math notranslate nohighlight">\(O(n * m)\)</span>, where <span class="math notranslate nohighlight">\(n\)</span> is the number of nodes in the <code class="docutils literal notranslate"><span class="pre">root</span></code> tree, and <span class="math notranslate nohighlight">\(m\)</span> is the number of nodes in the <code class="docutils literal notranslate"><span class="pre">subRoot</span></code> tree.</p></li>
</ul>
</li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">isSameTree</span></code> function:</p>
<ul class="simple">
<li><p>In the worst case, we visit every node in both <code class="docutils literal notranslate"><span class="pre">tree1</span></code> and <code class="docutils literal notranslate"><span class="pre">tree2</span></code>.</p></li>
<li><p>The number of recursive calls made is proportional to the number of nodes in the trees.</p></li>
<li><p>So, the time complexity of this function is <span class="math notranslate nohighlight">\(O(max(n, m))\)</span>, where <span class="math notranslate nohighlight">\(n\)</span> and <span class="math notranslate nohighlight">\(m\)</span> are the numbers of nodes in <code class="docutils literal notranslate"><span class="pre">tree1</span></code> and <code class="docutils literal notranslate"><span class="pre">tree2</span></code>, respectively.</p></li>
</ul>
</li>
</ol>
<p>Overall, the time complexity of the entire code is <span class="math notranslate nohighlight">\(O(n * m)\)</span>, where <span class="math notranslate nohighlight">\(n\)</span> is the number of nodes in the <code class="docutils literal notranslate"><span class="pre">root</span></code> tree, and <span class="math notranslate nohighlight">\(m\)</span> is the number of nodes in the <code class="docutils literal notranslate"><span class="pre">subRoot</span></code> tree. In practice, it may be less than <span class="math notranslate nohighlight">\(O(n * m)\)</span> if a subtree mismatch is detected early during the traversal.</p>
<p><strong>Space Complexity</strong></p>
<p>The space complexity of the code is determined by the function call stack during recursion and the space used by the recursive functions. Let’s analyze the space complexity:</p>
<ol class="arabic simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">isSubtree</span></code> function:</p>
<ul class="simple">
<li><p>It uses the call stack for recursion.</p></li>
<li><p>The maximum depth of the recursion is equal to the height of the <code class="docutils literal notranslate"><span class="pre">root</span></code> tree, which can be <span class="math notranslate nohighlight">\(O(n)\)</span> in the worst case (unbalanced tree).</p></li>
<li><p>Additionally, the function doesn’t use any significant extra space other than the recursion stack.</p></li>
</ul>
</li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">isSameTree</span></code> function:</p>
<ul class="simple">
<li><p>It also uses the call stack for recursion.</p></li>
<li><p>The maximum depth of the recursion is equal to the height of the <code class="docutils literal notranslate"><span class="pre">tree1</span></code> or <code class="docutils literal notranslate"><span class="pre">tree2</span></code>, whichever is greater.</p></li>
<li><p>So, the maximum space used for the call stack is <span class="math notranslate nohighlight">\(O(max(n, m))\)</span>.</p></li>
</ul>
</li>
</ol>
<p>In summary, the space complexity of the code is <span class="math notranslate nohighlight">\(O(max(n, m))\)</span> due to the function call stack. It scales with the maximum height of the trees being compared.</p>
<p>Overall, the code is efficient and works well for trees with moderate sizes. However, it’s important to keep in mind that the worst-case time complexity is <span class="math notranslate nohighlight">\(O(n * m)\)</span>, so for very large trees, the performance may degrade.</p>
</section>
</section>
<span id="document-07. Trees/98. Validate Binary Search Tree"></span><section class="tex2jax_ignore mathjax_ignore" id="validate-binary-search-tree">
<h3>98. Validate Binary Search Tree<a class="headerlink" href="#validate-binary-search-tree" title="Permalink to this heading">#</a></h3>
<p><strong>Difficulty:</strong> Medium</p>
<p><strong>Link to Problem:</strong> <a class="reference external" href="https://leetcode.com/problems/validate-binary-search-tree/">To see the Validate Binary Search Tree problem on LeetCode, click here!</a></p>
<hr class="docutils" />
<p>Given the <code class="docutils literal notranslate"><span class="pre">root</span></code> of a binary tree, <em>determine if it is a valid binary search tree (BST)</em>.</p>
<p>A <strong>valid BST</strong> is defined as follows:</p>
<ul class="simple">
<li><p>The left subtree of a node contains only nodes with keys <strong>less than</strong> the node’s key.</p></li>
<li><p>The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node’s key.</p></li>
<li><p>Both the left and right subtrees must also be binary search trees.</p></li>
</ul>
<p><strong>Constraints:</strong></p>
<ul class="simple">
<li><p>The number of nodes in the tree is in the range <span class="math notranslate nohighlight">\([1, 10^4]\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(-2^{31}\)</span> &lt;= <code class="docutils literal notranslate"><span class="pre">Node.val</span></code> &lt;= <span class="math notranslate nohighlight">\(2^{31} - 1\)</span></p></li>
</ul>
<section id="solution">
<h4>Solution:<a class="headerlink" href="#solution" title="Permalink to this heading">#</a></h4>
<p>Here’s a Python function to solve this problem:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

<span class="k">def</span> <span class="nf">is_valid_BST</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">is_valid</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">min_val</span><span class="p">,</span> <span class="n">max_val</span><span class="p">):</span>
        <span class="c1"># Base case: If the node is None, it&#39;s a valid BST.</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        
        <span class="c1"># Check if the current node&#39;s value is within the valid range.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">min_val</span> <span class="o">&lt;</span> <span class="n">node</span><span class="o">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">max_val</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        
        <span class="c1"># Recursively check the left and right subtrees with updated ranges.</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">is_valid</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">min_val</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">val</span><span class="p">)</span> <span class="ow">and</span>
                <span class="n">is_valid</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">max_val</span><span class="p">))</span>
    
    <span class="c1"># Call the helper function starting with a wide range for root node.</span>
    <span class="k">return</span> <span class="n">is_valid</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;-inf&#39;</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="explanation">
<h4>Explanation:<a class="headerlink" href="#explanation" title="Permalink to this heading">#</a></h4>
<ul class="simple">
<li><p>It defines a <code class="docutils literal notranslate"><span class="pre">TreeNode</span></code> class to represent nodes in the binary tree.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">is_valid_BST</span></code> function takes the root node of the binary tree as input and returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if the tree is a valid BST, and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p></li>
<li><p>Inside the <code class="docutils literal notranslate"><span class="pre">is_valid_BST</span></code> function, there is a helper function called <code class="docutils literal notranslate"><span class="pre">is_valid</span></code> that performs the actual validation using a recursive approach.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">is_valid</span></code> function checks each node in the tree to ensure that it satisfies the properties of a BST:</p>
<ul>
<li><p>The value of the current node must be within a valid range defined by <code class="docutils literal notranslate"><span class="pre">min_val</span></code> and <code class="docutils literal notranslate"><span class="pre">max_val</span></code>.</p></li>
<li><p>The left subtree of the current node should contain values less than the current node’s value.</p></li>
<li><p>The right subtree of the current node should contain values greater than the current node’s value.</p></li>
</ul>
</li>
<li><p>If any of these conditions are violated, the function returns <code class="docutils literal notranslate"><span class="pre">False</span></code>, indicating that the tree is not a valid BST.</p></li>
<li><p>If all nodes satisfy these conditions, the function returns <code class="docutils literal notranslate"><span class="pre">True</span></code>, indicating that the tree is a valid BST.</p></li>
<li><p>The code calls the <code class="docutils literal notranslate"><span class="pre">is_valid</span></code> function with the root node and initial range values of negative infinity to positive infinity to start the validation.</p></li>
<li><p>The time complexity of the code is O(N), where N is the number of nodes in the tree, as it traverses each node once.</p></li>
<li><p>The space complexity depends on the height of the tree. In the average case for a balanced BST, the space complexity is O(log N), but in the worst case (skewed tree), it can be O(N) due to the recursive call stack.</p></li>
</ul>
<p>In summary, this code checks whether a given binary tree is a valid BST by recursively validating each node’s value and its left and right subtrees while maintaining valid value ranges. If all nodes satisfy the BST properties, the tree is considered a valid BST.</p>
</section>
<section id="test-cases">
<h4>Test cases<a class="headerlink" href="#test-cases" title="Permalink to this heading">#</a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 1: </span>

<span class="c1"># Example usage:</span>
<span class="c1"># Create the tree for the first example: [2, 1, 3]</span>
<span class="n">root1</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">root1</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">root1</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">is_valid_BST</span><span class="p">(</span><span class="n">root1</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 2:</span>

<span class="c1"># Create the tree for the second example: [5, 1, 4, None, None, 3, 6]</span>
<span class="n">root2</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">root2</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">root2</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">root2</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">root2</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">is_valid_BST</span><span class="p">(</span><span class="n">root2</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>False
</pre></div>
</div>
</div>
</div>
</section>
<section id="time-and-space-complexity-analysis">
<h4>Time and Space Complexity Analysis<a class="headerlink" href="#time-and-space-complexity-analysis" title="Permalink to this heading">#</a></h4>
<p>Let’s analyze the time and space complexity of the <code class="docutils literal notranslate"><span class="pre">is_valid_BST</span></code> function:</p>
<p><strong>Time Complexity:</strong></p>
<ul class="simple">
<li><p>The time complexity of the function primarily depends on the number of nodes in the binary tree.</p></li>
<li><p>In the worst case, we may have to visit every node in the tree once to validate whether it’s part of a valid BST.</p></li>
<li><p>Since we are performing a depth-first search (DFS) traversal of the tree, the time complexity is O(N), where N is the number of nodes in the tree.</p></li>
</ul>
<p><strong>Space Complexity:</strong></p>
<ul class="simple">
<li><p>The space complexity is determined by the space used by the recursive call stack during the DFS traversal.</p></li>
<li><p>In the worst case, if the tree is completely unbalanced (a skewed tree), the maximum depth of the call stack would be equal to the height of the tree.</p></li>
<li><p>In a balanced BST, the height is approximately log2(N), where N is the number of nodes.</p></li>
<li><p>Therefore, the space complexity of the call stack is O(log N) for a balanced BST.</p></li>
<li><p>In the worst case (skewed tree), the space complexity can be O(N) as the height of the tree can be equal to N.</p></li>
</ul>
<p><strong>Overall:</strong></p>
<ul class="simple">
<li><p>Time Complexity: O(N)</p></li>
<li><p>Space Complexity: O(log N) on average for a balanced BST, and O(N) in the worst case for a skewed tree.</p></li>
</ul>
<p>The space complexity is typically dominated by the recursive call stack, and it varies depending on the shape of the binary tree. In practice, for balanced binary trees, the space complexity is often close to O(log N), which is quite efficient.</p>
</section>
<section id="challenging-exercises">
<h4>Challenging Exercises:<a class="headerlink" href="#challenging-exercises" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p><strong>Complex Constraints</strong>: Modify the problem to have more complex constraints on the tree. For example, consider a binary tree with constraints like “The left subtree of a node contains only nodes with keys less than or equal to the node’s key,” and “The right subtree of a node contains only nodes with keys greater than or equal to the node’s key.” How would you adapt the code to handle these constraints?</p></li>
<li><p><strong>Handling Duplicates</strong>: Modify the code to handle binary search trees that allow duplicate values. In a standard BST, each value is unique, but in this case, multiple nodes can have the same value. The tree should still be considered valid if it follows the BST property.</p></li>
</ol>
</section>
</section>
</div>
</section>
<span id="document-08. Tries/README"></span><section class="tex2jax_ignore mathjax_ignore" id="trie-problems-blind-75-leetcode">
<h2>Trie Problems - Blind 75 LeetCode<a class="headerlink" href="#trie-problems-blind-75-leetcode" title="Permalink to this heading">#</a></h2>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Problem Name</p></th>
<th class="head"><p>Difficulty</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/implement-trie-prefix-tree/">208. Implement Trie Prefix Tree</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/design-add-and-search-words-data-structure/">211. Design Add And Search Words Data Structure</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/word-search-ii/">212. Word Search II</a></p></td>
<td><p>Hard</p></td>
</tr>
</tbody>
</table>
<section id="contribute">
<h3>Contribute<a class="headerlink" href="#contribute" title="Permalink to this heading">#</a></h3>
<p>If you have a better solution or want to add more problems to the collection, feel free to contribute. You can create a pull request or open an issue to discuss additions or improvements.</p>
</section>
<section id="resources">
<h3>Resources<a class="headerlink" href="#resources" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p><a class="reference external" href="https://leetcode.com/">LeetCode</a>: The official LeetCode website.</p></li>
<li><p><a class="reference external" href="https://leetcode.com/discuss/">LeetCode Discuss</a>: LeetCode’s discussion forum for each problem. You can find helpful hints and discussions here.</p></li>
</ul>
<p>Happy coding!</p>
</section>
<div class="toctree-wrapper compound">
<span id="document-08. Tries/208. Implement Trie (Prefix Tree)"></span><section class="tex2jax_ignore mathjax_ignore" id="implement-trie-prefix-tree">
<h3>208. Implement Trie (Prefix Tree)<a class="headerlink" href="#implement-trie-prefix-tree" title="Permalink to this heading">#</a></h3>
<p><strong>Difficulty:</strong> Medium</p>
<p><strong>Link to Problem:</strong> <a class="reference external" href="https://leetcode.com/problems/implement-trie-prefix-tree/">To see the Implement Trie problem on LeetCode, click here!</a></p>
<hr class="docutils" />
<p>A <strong>trie</strong> (pronounced as “try”) or <strong>prefix tree</strong> is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.</p>
<p>Implement the Trie class:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Trie()</span></code> Initializes the trie object.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">insert(String</span> <span class="pre">word)</span></code> Inserts the string <code class="docutils literal notranslate"><span class="pre">word</span></code> into the trie.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">boolean</span> <span class="pre">search(String</span> <span class="pre">word)</span></code> Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if the string <code class="docutils literal notranslate"><span class="pre">word</span></code> is in the trie (i.e., was inserted before), and <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">boolean</span> <span class="pre">startsWith(String</span> <span class="pre">prefix)</span></code> Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if there is a previously inserted string <code class="docutils literal notranslate"><span class="pre">word</span></code> that has the prefix <code class="docutils literal notranslate"><span class="pre">prefix</span></code>, and <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p></li>
</ul>
<p><strong>Constraints:</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">&lt;=</span> <span class="pre">word.length,</span> <span class="pre">prefix.length</span> <span class="pre">&lt;=</span> <span class="pre">2000</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">word</span></code> and <code class="docutils literal notranslate"><span class="pre">prefix</span></code> consist only of lowercase English letters.</p></li>
<li><p>At most <span class="math notranslate nohighlight">\(3 * 10^4\)</span> calls in total will be made to <code class="docutils literal notranslate"><span class="pre">insert</span></code>, <code class="docutils literal notranslate"><span class="pre">search</span></code>, and <code class="docutils literal notranslate"><span class="pre">startsWith</span></code>.</p></li>
</ul>
<section id="probelm-explanation">
<h4>Probelm Explanation:<a class="headerlink" href="#probelm-explanation" title="Permalink to this heading">#</a></h4>
<p>The problem at hand is to implement a data structure known as a Trie (pronounced “try”) or Prefix Tree. A Trie is a tree-like data structure that is used to efficiently store and retrieve a set of strings or words. It’s particularly useful for tasks involving string manipulation, such as autocomplete and spell-checking. The problem statement defines the following operations for implementing the Trie class:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Trie()</span></code>: This is the constructor that initializes the Trie object.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">insert(String</span> <span class="pre">word)</span></code>: This method inserts the given string <code class="docutils literal notranslate"><span class="pre">word</span></code> into the Trie. It effectively adds the characters of the word to the Trie’s structure, creating nodes for each character if they don’t already exist. At the end of the word, a special flag is set to indicate that this node represents the end of a valid word.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">boolean</span> <span class="pre">search(String</span> <span class="pre">word)</span></code>: This method checks if the given string <code class="docutils literal notranslate"><span class="pre">word</span></code> is present in the Trie. It starts from the root of the Trie and traverses the Trie by following the characters in the word. If it successfully traverses the Trie and reaches the end of the word, it returns <code class="docutils literal notranslate"><span class="pre">true</span></code>, indicating that the word exists in the Trie; otherwise, it returns <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">boolean</span> <span class="pre">startsWith(String</span> <span class="pre">prefix)</span></code>: This method checks if there is any previously inserted word in the Trie that has the given <code class="docutils literal notranslate"><span class="pre">prefix</span></code>. It’s similar to the <code class="docutils literal notranslate"><span class="pre">search</span></code> method but does not require that the prefix be a complete word. If there is any word in the Trie that starts with the given prefix, it returns <code class="docutils literal notranslate"><span class="pre">true</span></code>; otherwise, it returns <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p></li>
</ol>
<p>The problem also provides an example scenario where these operations are called, demonstrating the expected output for each operation.</p>
<p>In summary, the goal is to create a data structure (Trie) that efficiently stores a set of strings and provides methods to insert new strings, search for complete words, and check if a given prefix exists in the stored set of strings.</p>
</section>
<section id="solution">
<h4>Solution:<a class="headerlink" href="#solution" title="Permalink to this heading">#</a></h4>
<p>Here’s a Python function to implement this algorithm:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TrieNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">{}</span>           <span class="c1"># A dictionary to store child nodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_end_of_word</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># Indicates if a word ends at this node</span>

<span class="k">class</span> <span class="nc">Trie</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">TrieNode</span><span class="p">()</span>       <span class="c1"># Initialize the Trie with a root node</span>

    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">):</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span>             <span class="c1"># Start from the root</span>
        <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">word</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">char</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">char</span><span class="p">]</span> <span class="o">=</span> <span class="n">TrieNode</span><span class="p">()</span>  <span class="c1"># Create a new node if the character is not present</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">char</span><span class="p">]</span>           <span class="c1"># Move to the child node</span>
        <span class="n">node</span><span class="o">.</span><span class="n">is_end_of_word</span> <span class="o">=</span> <span class="kc">True</span>                <span class="c1"># Mark the end of the inserted word</span>

    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">):</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span>             <span class="c1"># Start from the root</span>
        <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">word</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">char</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>         <span class="c1"># If the character is not found, the word is not in the Trie</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">char</span><span class="p">]</span>  <span class="c1"># Move to the child node</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">is_end_of_word</span>    <span class="c1"># Check if the node represents the end of a valid word</span>

    <span class="k">def</span> <span class="nf">startsWith</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix</span><span class="p">):</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span>             <span class="c1"># Start from the root</span>
        <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">prefix</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">char</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>         <span class="c1"># If the character is not found, no word starts with the prefix</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">char</span><span class="p">]</span>  <span class="c1"># Move to the child node</span>
        <span class="k">return</span> <span class="kc">True</span>                  <span class="c1"># Prefix found in the Trie</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="explanation">
<h4>Explanation:<a class="headerlink" href="#explanation" title="Permalink to this heading">#</a></h4>
<p>Let’s explain how the code works step by step:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">TrieNode</span></code> Class:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">TrieNode</span></code> is a class that represents nodes in the Trie. Each node has two attributes:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">children</span></code>: This is a dictionary that stores child nodes. Each key in the dictionary represents a character, and the corresponding value is the child node for that character.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">is_end_of_word</span></code>: This boolean flag indicates whether the node represents the end of a complete word. Initially, it’s set to <code class="docutils literal notranslate"><span class="pre">False</span></code> for all nodes.</p></li>
</ul>
</li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Trie</span></code> Class:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Trie</span></code> is the main class that implements the Trie data structure. It has the following methods:</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__init__(self)</span></code>: The constructor initializes the Trie object by creating a root node, which serves as the starting point for all Trie operations.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">insert(self,</span> <span class="pre">word)</span></code>: This method inserts a string <code class="docutils literal notranslate"><span class="pre">word</span></code> into the Trie. It starts from the root node and iterates through each character in the word.</p>
<ul>
<li><p>If a character is not present as a child node, it creates a new node for that character.</p></li>
<li><p>It then moves to the child node and continues the process until the entire word is inserted.</p></li>
<li><p>Finally, it sets the <code class="docutils literal notranslate"><span class="pre">is_end_of_word</span></code> flag to <code class="docutils literal notranslate"><span class="pre">True</span></code> for the last node to mark the end of the inserted word.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">search(self,</span> <span class="pre">word)</span></code>: This method checks if a complete word (string) exists in the Trie. It starts from the root node and iterates through each character in the word.</p>
<ul>
<li><p>If a character is not found as a child node, it immediately returns <code class="docutils literal notranslate"><span class="pre">False</span></code> because the word is not in the Trie.</p></li>
<li><p>It continues to move to the child node for each character.</p></li>
<li><p>After reaching the end of the word, it checks if the <code class="docutils literal notranslate"><span class="pre">is_end_of_word</span></code> flag is <code class="docutils literal notranslate"><span class="pre">True</span></code> for the last node to confirm the presence of the word.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">startsWith(self,</span> <span class="pre">prefix)</span></code>: This method checks if there is any previously inserted word in the Trie that starts with a given <code class="docutils literal notranslate"><span class="pre">prefix</span></code>. It follows the same logic as the <code class="docutils literal notranslate"><span class="pre">search</span></code> method but does not require the entire word to be present.</p>
<ul>
<li><p>If the prefix is found in the Trie, it returns <code class="docutils literal notranslate"><span class="pre">True</span></code>; otherwise, it returns <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
</ul>
</li>
</ul>
</li>
<li><p>Example Usage:</p>
<ul class="simple">
<li><p>The code demonstrates how to create a Trie object, insert words (“apple” and “app”), and perform operations on the Trie:</p>
<ul>
<li><p>It inserts the word “apple” into the Trie.</p></li>
<li><p>It checks if “apple” is in the Trie, which returns <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p></li>
<li><p>It checks if “app” is in the Trie, which returns <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
<li><p>It checks if there is any word in the Trie that starts with “app,” which returns <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p></li>
<li><p>It inserts the word “app” into the Trie.</p></li>
<li><p>It checks if “app” is in the Trie again, which now returns <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p></li>
</ul>
</li>
</ul>
</li>
</ol>
<p>In summary, the code efficiently implements a Trie data structure with the ability to insert words, search for complete words, and check for the existence of words with a given prefix. The Trie is organized as a tree of nodes, with each node representing a character in the words being stored.</p>
</section>
<section id="test-cases">
<h4>Test cases:<a class="headerlink" href="#test-cases" title="Permalink to this heading">#</a></h4>
<p>Here’s how you can use this solution:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 1: </span>

<span class="c1"># Example usage:</span>

<span class="n">trie</span> <span class="o">=</span> <span class="n">Trie</span><span class="p">()</span>
<span class="n">trie</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="s2">&quot;apple&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">trie</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;apple&quot;</span><span class="p">))</span>   <span class="c1"># Output: True</span>
<span class="nb">print</span><span class="p">(</span><span class="n">trie</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;app&quot;</span><span class="p">))</span>     <span class="c1"># Output: False</span>
<span class="nb">print</span><span class="p">(</span><span class="n">trie</span><span class="o">.</span><span class="n">startsWith</span><span class="p">(</span><span class="s2">&quot;app&quot;</span><span class="p">))</span> <span class="c1"># Output: True</span>
<span class="n">trie</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="s2">&quot;app&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">trie</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;app&quot;</span><span class="p">))</span>     <span class="c1"># Output: True</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
False
True
True
</pre></div>
</div>
</div>
</div>
</section>
<section id="time-and-space-complexity-analysis">
<h4>Time and Space Complexity Analysis<a class="headerlink" href="#time-and-space-complexity-analysis" title="Permalink to this heading">#</a></h4>
<p>Let’s analyze the time and space complexity of the Trie implementation:</p>
<ol class="arabic">
<li><p>Time Complexity:</p>
<ul class="simple">
<li><p>Insertion (<code class="docutils literal notranslate"><span class="pre">insert</span></code> method): The time complexity of inserting a word into the Trie is O(m), where m is the length of the word. In the worst case, you may need to traverse the entire word to insert it into the Trie.</p></li>
<li><p>Search (<code class="docutils literal notranslate"><span class="pre">search</span></code> method): The time complexity of searching for a word in the Trie is also O(m), where m is the length of the word. In the worst case, you may need to traverse the entire word to determine if it exists in the Trie.</p></li>
<li><p>Starts with (<code class="docutils literal notranslate"><span class="pre">startsWith</span></code> method): The time complexity of checking if a prefix exists in the Trie is O(p), where p is the length of the prefix. In the worst case, you may need to traverse the entire prefix to determine its presence.</p></li>
</ul>
<p>Therefore, for each operation (insertion, search, or starts with), the time complexity is O(m) or O(p), where m is the length of the word being operated on, and p is the length of the prefix.</p>
</li>
<li><p>Space Complexity:</p>
<ul class="simple">
<li><p>The space complexity of the Trie is determined by the number of nodes and characters stored in it. In the worst case, where none of the inserted words share common prefixes, the space complexity is O(N), where N is the total number of characters across all inserted words.</p></li>
<li><p>Each node in the Trie represents a character, and the number of nodes is directly related to the total number of characters.</p></li>
</ul>
<p>In practice, the space complexity can be less than O(N) because common prefixes are shared among words in the Trie, leading to space optimization.</p>
</li>
</ol>
<p>In summary:</p>
<ul class="simple">
<li><p>Time complexity for each operation (insertion, search, starts with) is O(m) or O(p), where m is the length of the word and p is the length of the prefix.</p></li>
<li><p>Space complexity is O(N) in the worst case, where N is the total number of characters across all inserted words. However, space optimization occurs due to common prefix sharing in practice, potentially reducing the actual space used.</p></li>
</ul>
</section>
<section id="challenging-exercises">
<h4>Challenging Exercises:<a class="headerlink" href="#challenging-exercises" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p><strong>Count Prefixes</strong>:
Implement a method to count the number of words in the Trie that have a specific prefix. This exercise requires you to maintain additional data in the Trie nodes to keep track of the count.</p></li>
<li><p><strong>Auto-Complete Suggestions</strong>:
Implement an auto-complete feature using the Trie. Given a prefix, the program should return a list of suggested words based on the words previously inserted into the Trie.</p></li>
</ol>
</section>
</section>
<span id="document-08. Tries/211. Design Add and Search Words Data Structure"></span><section class="tex2jax_ignore mathjax_ignore" id="design-add-and-search-words-data-structure">
<h3>211. Design Add and Search Words Data Structure<a class="headerlink" href="#design-add-and-search-words-data-structure" title="Permalink to this heading">#</a></h3>
<p><strong>Difficulty:</strong> Medium</p>
<p><strong>Link to Problem:</strong> <a class="reference external" href="https://leetcode.com/problems/design-add-and-search-words-data-structure/">To see the Design Add and Search Words Data Structure problem on LeetCode, click here!</a></p>
<hr class="docutils" />
<p>Design a data structure that supports adding new words and finding if a string matches any previously added string.</p>
<p>Implement the <code class="docutils literal notranslate"><span class="pre">WordDictionary</span></code> class:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">WordDictionary()</span></code> Initializes the object.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">addWord(word)</span></code> Adds <code class="docutils literal notranslate"><span class="pre">word</span></code> to the data structure, it can be matched later.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">search(word)</span></code> Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if there is any string in the data structure that matches <code class="docutils literal notranslate"><span class="pre">word</span></code> or <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise. <code class="docutils literal notranslate"><span class="pre">word</span></code> may contain dots <code class="docutils literal notranslate"><span class="pre">'.'</span></code> where dots can be matched with any letter.</p></li>
</ul>
<p><strong>Constraints:</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">&lt;=</span> <span class="pre">word.length</span> <span class="pre">&lt;=</span> <span class="pre">25</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">word</span></code> in <code class="docutils literal notranslate"><span class="pre">addWord</span></code> consists of lowercase English letters.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">word</span></code> in <code class="docutils literal notranslate"><span class="pre">search</span></code> consist of <code class="docutils literal notranslate"><span class="pre">'.'</span></code> or lowercase English letters.</p></li>
<li><p>There will be at most <code class="docutils literal notranslate"><span class="pre">2</span></code> dots in <code class="docutils literal notranslate"><span class="pre">word</span></code> for <code class="docutils literal notranslate"><span class="pre">search</span></code> queries.</p></li>
<li><p>At most <span class="math notranslate nohighlight">\(10^4\)</span> calls will be made to <code class="docutils literal notranslate"><span class="pre">addWord</span></code> and <code class="docutils literal notranslate"><span class="pre">search</span></code>.</p></li>
</ul>
<section id="probelm-explanation">
<h4>Probelm Explanation:<a class="headerlink" href="#probelm-explanation" title="Permalink to this heading">#</a></h4>
<p>The problem is to design a data structure called <code class="docutils literal notranslate"><span class="pre">WordDictionary</span></code> that allows you to add words and search for words efficiently. The key feature of this data structure is that it should support wildcard search, where a dot (‘.’) can match any letter.</p>
<p>Here are the specific requirements and explanations for the problem:</p>
<ol class="arabic simple">
<li><p>Initialize the <code class="docutils literal notranslate"><span class="pre">WordDictionary</span></code> object using the constructor <code class="docutils literal notranslate"><span class="pre">WordDictionary()</span></code>.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">addWord(word)</span></code> method allows you to add a word to the data structure. Once added, you should be able to search for this word later. The words consist of lowercase English letters, and each word has a length between 1 and 25 characters.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">search(word)</span></code> method allows you to search for a word in the data structure. This method returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if there is any string in the data structure that matches the given word or <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise. The word you are searching for may contain dots (‘.’), where each dot can match any letter.</p></li>
<li><p>The wildcard character (‘.’) in the <code class="docutils literal notranslate"><span class="pre">search</span></code> method allows for partial or fuzzy searching. For example, if the word dictionary contains the words “bad,” “dad,” and “mad,” then:</p>
<ul class="simple">
<li><p>Searching for “pad” should return <code class="docutils literal notranslate"><span class="pre">False</span></code> because there is no exact match.</p></li>
<li><p>Searching for “bad” should return <code class="docutils literal notranslate"><span class="pre">True</span></code> because “bad” is in the dictionary.</p></li>
<li><p>Searching for “.ad” should return <code class="docutils literal notranslate"><span class="pre">True</span></code> because it can match “bad,” “dad,” or “mad.”</p></li>
<li><p>Searching for “b..” should return <code class="docutils literal notranslate"><span class="pre">True</span></code> because it can match “bad,” “bed,” “bet,” etc.</p></li>
</ul>
</li>
<li><p>The problem specifies that there will be at most two dots (‘.’) in search queries, and there will be at most 10^4 calls to both <code class="docutils literal notranslate"><span class="pre">addWord</span></code> and <code class="docutils literal notranslate"><span class="pre">search</span></code>.</p></li>
</ol>
<p>In summary, you need to implement the <code class="docutils literal notranslate"><span class="pre">WordDictionary</span></code> class that efficiently supports adding words and searching for words, where the search can include wildcard characters (‘.’) that match any letter.</p>
</section>
<section id="solution">
<h4>Solution:<a class="headerlink" href="#solution" title="Permalink to this heading">#</a></h4>
<p>Here’s a Python function to implement this algorithm:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TrieNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Initialize a TrieNode with children and a flag to indicate the end of a word.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_end_of_word</span> <span class="o">=</span> <span class="kc">False</span>

<span class="k">class</span> <span class="nc">WordDictionary</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Initialize the WordDictionary with a root node.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">TrieNode</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">addWord</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span>
        <span class="c1"># Iterate through the characters in the word.</span>
        <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">word</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">char</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="c1"># Create a new node for the character if it doesn&#39;t exist.</span>
                <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">char</span><span class="p">]</span> <span class="o">=</span> <span class="n">TrieNode</span><span class="p">()</span>
            <span class="c1"># Move to the next node.</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">char</span><span class="p">]</span>
        <span class="c1"># Mark the end of the word by setting the flag to True.</span>
        <span class="n">node</span><span class="o">.</span><span class="n">is_end_of_word</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">search_helper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">TrieNode</span><span class="p">,</span> <span class="n">word</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">word</span><span class="p">:</span>
            <span class="c1"># If there are no characters left in the word, check if we reached the end of a word in the trie.</span>
            <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">is_end_of_word</span>
        
        <span class="n">char</span> <span class="o">=</span> <span class="n">word</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">char</span> <span class="o">==</span> <span class="s1">&#39;.&#39;</span><span class="p">:</span>
            <span class="c1"># If the character is a dot, explore all possible child nodes.</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_helper</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">word</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
                    <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="c1"># If the character is in the children of the current node, move to the next node.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_helper</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">char</span><span class="p">],</span> <span class="n">word</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        
        <span class="c1"># If the character is not found and is not a dot, the word is not in the trie.</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="c1"># Start the search from the root of the trie.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_helper</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="n">word</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="explanation">
<h4>Explanation:<a class="headerlink" href="#explanation" title="Permalink to this heading">#</a></h4>
<p>This code defines a <code class="docutils literal notranslate"><span class="pre">WordDictionary</span></code> class that uses a Trie data structure to efficiently store and search for words. Here’s a step-by-step explanation:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">TrieNode</span></code> class: This class represents nodes in the Trie data structure. Each node has two attributes: <code class="docutils literal notranslate"><span class="pre">children</span></code> (a dictionary to store child nodes) and <code class="docutils literal notranslate"><span class="pre">is_end_of_word</span></code> (a flag to indicate whether the node marks the end of a word).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">WordDictionary</span></code> class: This class initializes with an empty Trie by creating a root node.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">addWord</span></code> method: This method adds a word to the Trie. It iterates through each character in the word and creates Trie nodes as necessary. It sets the <code class="docutils literal notranslate"><span class="pre">is_end_of_word</span></code> flag to <code class="docutils literal notranslate"><span class="pre">True</span></code> for the final character of the word to mark the end of the word.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">search_helper</span></code> method: This is a recursive helper function for searching words in the Trie. It takes a Trie node (<code class="docutils literal notranslate"><span class="pre">node</span></code>) and a word to search (<code class="docutils literal notranslate"><span class="pre">word</span></code>) as input. If there are no characters left in the word (<code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">word</span></code>), it checks if the current node marks the end of a word. If it does, it returns <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p></li>
<li><p>If the first character of the word is a dot (‘.’), the function explores all possible child nodes by iterating through <code class="docutils literal notranslate"><span class="pre">node.children.values()</span></code> and recursively calls <code class="docutils literal notranslate"><span class="pre">search_helper</span></code> for each child with the remaining part of the word (<code class="docutils literal notranslate"><span class="pre">word[1:]</span></code>).</p></li>
<li><p>If the first character of the word is not a dot and is found in the children of the current node, the function recursively moves to the next node by calling <code class="docutils literal notranslate"><span class="pre">search_helper</span></code> on the child node and the remaining part of the word.</p></li>
<li><p>If the character is not found in the children and is not a dot, the word is not in the Trie, so the function returns <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">search</span></code> method: This is the public method for searching words. It initiates the search process by calling <code class="docutils literal notranslate"><span class="pre">search_helper</span></code> starting from the root node of the Trie.</p></li>
</ol>
<p>Overall, this code efficiently implements a Trie-based data structure that allows adding and searching for words, including support for wildcard characters represented by dots (‘.’).</p>
</section>
<section id="test-cases">
<h4>Test cases:<a class="headerlink" href="#test-cases" title="Permalink to this heading">#</a></h4>
<p>Here’s how you can use this solution:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 1: </span>

<span class="c1"># Example usage:</span>

<span class="n">wordDictionary</span> <span class="o">=</span> <span class="n">WordDictionary</span><span class="p">()</span>
<span class="n">wordDictionary</span><span class="o">.</span><span class="n">addWord</span><span class="p">(</span><span class="s2">&quot;bad&quot;</span><span class="p">)</span>
<span class="n">wordDictionary</span><span class="o">.</span><span class="n">addWord</span><span class="p">(</span><span class="s2">&quot;dad&quot;</span><span class="p">)</span>
<span class="n">wordDictionary</span><span class="o">.</span><span class="n">addWord</span><span class="p">(</span><span class="s2">&quot;mad&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">wordDictionary</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;pad&quot;</span><span class="p">))</span>  <span class="c1"># Output: False</span>
<span class="nb">print</span><span class="p">(</span><span class="n">wordDictionary</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;bad&quot;</span><span class="p">))</span>  <span class="c1"># Output: True</span>
<span class="nb">print</span><span class="p">(</span><span class="n">wordDictionary</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;.ad&quot;</span><span class="p">))</span>  <span class="c1"># Output: True</span>
<span class="nb">print</span><span class="p">(</span><span class="n">wordDictionary</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;b..&quot;</span><span class="p">))</span>  <span class="c1"># Output: True</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>False
True
True
True
</pre></div>
</div>
</div>
</div>
</section>
<section id="time-and-space-complexity-analysis">
<h4>Time and Space Complexity Analysis<a class="headerlink" href="#time-and-space-complexity-analysis" title="Permalink to this heading">#</a></h4>
<p>Let’s analyze the time and space complexity of the <code class="docutils literal notranslate"><span class="pre">WordDictionary</span></code> class methods:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">addWord</span></code> Method:</p>
<ul class="simple">
<li><p>Time Complexity: O(L)</p>
<ul>
<li><p>L is the length of the word being added.</p></li>
<li><p>In the worst case, we need to iterate through each character in the word and create nodes in the Trie. This takes O(L) time.</p></li>
</ul>
</li>
<li><p>Space Complexity: O(L)</p>
<ul>
<li><p>The space complexity for storing the word in the Trie is also O(L) because we create nodes for each character in the word.</p></li>
</ul>
</li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">search_helper</span></code> Method (called by <code class="docutils literal notranslate"><span class="pre">search</span></code>):</p>
<ul class="simple">
<li><p>Time Complexity: O(2^M * L)</p>
<ul>
<li><p>M is the maximum number of dots (‘.’) in the search word.</p></li>
<li><p>In the worst case, when there are M dots in the search word, we may explore all possible child nodes at each dot. This results in a branching factor of 26 (for lowercase letters) at each dot.</p></li>
<li><p>So, the time complexity is exponential in the number of dots and linear in the length of the word being searched (L).</p></li>
</ul>
</li>
<li><p>Space Complexity: O(L)</p>
<ul>
<li><p>The space complexity for the recursive call stack is O(L) in the worst case because we may have to recurse to a depth equal to the length of the search word.</p></li>
</ul>
</li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">search</span></code> Method:</p>
<ul class="simple">
<li><p>Time Complexity: O(2^M * L)</p>
<ul>
<li><p>The <code class="docutils literal notranslate"><span class="pre">search</span></code> method calls the <code class="docutils literal notranslate"><span class="pre">search_helper</span></code> method, which has the same time complexity explained above.</p></li>
</ul>
</li>
<li><p>Space Complexity: O(L)</p>
<ul>
<li><p>The space complexity for the recursive call stack is O(L) in the worst case, as explained earlier.</p></li>
</ul>
</li>
</ul>
</li>
</ol>
<p>Overall, the time complexity of the <code class="docutils literal notranslate"><span class="pre">search</span></code> method is mainly affected by the number of dots (‘.’) in the search word. In the worst case, when there are multiple dots and many possibilities to explore at each dot, the time complexity can be exponential. However, for most practical cases, it performs reasonably well.</p>
<p>The space complexity primarily depends on the space required to store the words in the Trie. It is proportional to the total number of characters in all added words and is linear with respect to the length of the words added.</p>
<p>In summary:</p>
<ul class="simple">
<li><p>Time Complexity for <code class="docutils literal notranslate"><span class="pre">addWord</span></code>: O(L)</p></li>
<li><p>Time Complexity for <code class="docutils literal notranslate"><span class="pre">search</span></code>: O(2^M * L)</p></li>
<li><p>Space Complexity: O(L) for storing words in the Trie, O(L) for the recursive call stack during search.</p></li>
</ul>
<p>Note: The space complexity analysis assumes that the dictionary contains a reasonable number of words and does not account for the overhead of Python objects or system-level memory allocation.</p>
</section>
<section id="challenging-exercises">
<h4>Challenging Exercises:<a class="headerlink" href="#challenging-exercises" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p><strong>Dictionary Auto-Completion</strong>: Extend the <code class="docutils literal notranslate"><span class="pre">WordDictionary</span></code> class to provide auto-completion suggestions based on the prefix of a word. Implement a method that returns a list of words that match the given prefix.</p></li>
<li><p><strong>Support Word Deletion</strong>: Extend the <code class="docutils literal notranslate"><span class="pre">WordDictionary</span></code> class to support word deletion. Add a method <code class="docutils literal notranslate"><span class="pre">deleteWord(word)</span></code> that removes a word from the data structure. Ensure that the search operation still works correctly after deletion.</p></li>
</ol>
</section>
</section>
<span id="document-08. Tries/212. Word Search II"></span><section class="tex2jax_ignore mathjax_ignore" id="word-search-ii">
<h3>212. Word Search II<a class="headerlink" href="#word-search-ii" title="Permalink to this heading">#</a></h3>
<p><strong>Difficulty:</strong> Hard</p>
<p><strong>Link to Problem:</strong> <a class="reference external" href="https://leetcode.com/problems/word-search-ii/">To see the Word Search II problem on LeetCode, click here!</a></p>
<hr class="docutils" />
<p>Given an <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">x</span> <span class="pre">n</span></code> <code class="docutils literal notranslate"><span class="pre">board</span></code> of characters and a list of strings <code class="docutils literal notranslate"><span class="pre">words</span></code>, the task is to return <em>all words on the board</em>.</p>
<p>Each word must be constructed from letters of sequentially <strong>adjacent cells</strong>, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.</p>
<p><strong>Constraints:</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">==</span> <span class="pre">board.length</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">==</span> <span class="pre">board[i].length</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">&lt;=</span> <span class="pre">m,</span> <span class="pre">n</span> <span class="pre">&lt;=</span> <span class="pre">12</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">board[i][j]</span></code> is a lowercase English letter.</p></li>
<li><p>1 &lt;= <code class="docutils literal notranslate"><span class="pre">words.length</span></code> &lt;= <span class="math notranslate nohighlight">\(3 * 10^4\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">&lt;=</span> <span class="pre">words[i].length</span> <span class="pre">&lt;=</span> <span class="pre">10</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">words[i]</span></code> consists of lowercase English letters.</p></li>
<li><p>All the strings of <code class="docutils literal notranslate"><span class="pre">words</span></code> are unique.</p></li>
</ul>
<section id="probelm-explanation">
<h4>Probelm Explanation:<a class="headerlink" href="#probelm-explanation" title="Permalink to this heading">#</a></h4>
<p>To solve the “Word Search II” problem, you can use a Trie data structure and perform a depth-first search (DFS) on the board. Here’s a step-by-step approach to solve the problem:</p>
<ol class="arabic simple">
<li><p>Build a Trie from the given list of words:</p>
<ul class="simple">
<li><p>Create a Trie data structure to store all the words from the input list.</p></li>
<li><p>For each word in the input list, insert it into the Trie, character by character. Make sure to mark the end of each word in the Trie.</p></li>
</ul>
</li>
<li><p>Perform DFS on the board:</p>
<ul class="simple">
<li><p>Iterate through each cell (i, j) on the board.</p></li>
<li><p>For each cell, start a DFS traversal from that cell to search for words.</p></li>
<li><p>During the DFS traversal, maintain a current path string.</p></li>
<li><p>At each cell, check if the current path string, concatenated with the character in the cell, matches any word prefix in the Trie. If it does, continue the DFS.</p></li>
<li><p>If the current path string matches a word in the Trie, add it to the result.</p></li>
</ul>
</li>
<li><p>Implement DFS with backtracking:</p>
<ul class="simple">
<li><p>During the DFS traversal, you will explore neighboring cells (horizontally and vertically) if they are within bounds and haven’t been visited before.</p></li>
<li><p>To prevent revisiting the same cell within the same word, mark the cell as visited (e.g., change its character to a special character like ‘#’) before exploring it and restore its original character after the DFS traversal.</p></li>
</ul>
</li>
<li><p>Return the result:</p>
<ul class="simple">
<li><p>After completing the DFS traversal for all cells on the board, you will have collected all the valid words in the result set.</p></li>
<li><p>Convert the result set to a list and return it as the final output.</p></li>
</ul>
</li>
</ol>
<p>This approach efficiently finds all words on the board by utilizing the Trie data structure to prune unnecessary DFS paths and avoiding duplicate visits to the same cell within the same word. It ensures that each word is constructed from letters of sequentially adjacent cells without using the same letter cell more than once in a word.</p>
</section>
<section id="solution">
<h4>Solution:<a class="headerlink" href="#solution" title="Permalink to this heading">#</a></h4>
<p>Here’s a Python function to implement this algorithm:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Define a TrieNode class to represent nodes in the Trie.</span>
<span class="k">class</span> <span class="nc">TrieNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># Dictionary to store child nodes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_end_of_word</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># Flag to mark the end of a word.</span>

<span class="c1"># Main function to find words on the board.</span>
<span class="k">def</span> <span class="nf">findWords</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">words</span><span class="p">):</span>
    <span class="c1"># DFS function to search for words starting from a given cell.</span>
    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="n">char</span> <span class="o">=</span> <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>  <span class="c1"># Get the character at the current cell.</span>
        <span class="n">curr_node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>  <span class="c1"># Find the corresponding Trie node.</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">curr_node</span><span class="p">:</span>
            <span class="k">return</span>  <span class="c1"># If no matching Trie node, stop the search.</span>

        <span class="n">path</span> <span class="o">+=</span> <span class="n">char</span>  <span class="c1"># Add the character to the current path.</span>

        <span class="k">if</span> <span class="n">curr_node</span><span class="o">.</span><span class="n">is_end_of_word</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>  <span class="c1"># If the path matches a word, add it to the result.</span>

        <span class="n">temp</span><span class="p">,</span> <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="s2">&quot;#&quot;</span>  <span class="c1"># Mark the cell as visited.</span>

        <span class="c1"># Explore neighboring cells (up, down, left, right).</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">curr_node</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">curr_node</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">curr_node</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">curr_node</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>

        <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span>  <span class="c1"># Restore the cell&#39;s original character.</span>

    <span class="c1"># Function to build a Trie from the list of words.</span>
    <span class="k">def</span> <span class="nf">buildTrie</span><span class="p">():</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">TrieNode</span><span class="p">()</span>  <span class="c1"># Create a root node.</span>
        <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">words</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">root</span>
            <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">word</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">char</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">char</span><span class="p">]</span> <span class="o">=</span> <span class="n">TrieNode</span><span class="p">()</span>  <span class="c1"># Create a new node if needed.</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">char</span><span class="p">]</span>
            <span class="n">node</span><span class="o">.</span><span class="n">is_end_of_word</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># Mark the end of the word.</span>
        <span class="k">return</span> <span class="n">root</span>

    <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">board</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">board</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># Get the dimensions of the board.</span>
    <span class="n">root</span> <span class="o">=</span> <span class="n">buildTrie</span><span class="p">()</span>  <span class="c1"># Build the Trie from the list of words.</span>
    <span class="n">result</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>  <span class="c1"># Use a set to store unique words found on the board.</span>

    <span class="c1"># Iterate through each cell on the board and start DFS from there.</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>  <span class="c1"># Start DFS from each cell on the board.</span>

    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>  <span class="c1"># Convert the set to a list and return the result.</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="explanation">
<h4>Explanation:<a class="headerlink" href="#explanation" title="Permalink to this heading">#</a></h4>
<p>The code solves the “Word Search II” problem, where you have a grid of characters and a list of words. The goal is to find all words from the list that can be constructed by traversing adjacent cells (horizontally or vertically) in the grid, without using the same cell more than once for a single word.</p>
<p>The code does the following:</p>
<ol class="arabic simple">
<li><p>Defines a <code class="docutils literal notranslate"><span class="pre">TrieNode</span></code> class to represent nodes in a Trie data structure. Each node has children (other characters in the word) and a flag to mark the end of a word.</p></li>
<li><p>Defines the <code class="docutils literal notranslate"><span class="pre">findWords</span></code> function, which takes the grid (<code class="docutils literal notranslate"><span class="pre">board</span></code>) and a list of words (<code class="docutils literal notranslate"><span class="pre">words</span></code>) as input.</p></li>
<li><p>Inside the <code class="docutils literal notranslate"><span class="pre">findWords</span></code> function, there is a <code class="docutils literal notranslate"><span class="pre">dfs</span></code> (depth-first search) function. This function is used to explore the grid starting from a specific cell. It checks if the current path matches any word in the Trie and adds it to the result if found.</p></li>
<li><p>The code also includes a <code class="docutils literal notranslate"><span class="pre">buildTrie</span></code> function that constructs a Trie data structure from the list of words. It iterates through each word, creating nodes for each character in the Trie and marking the end of words.</p></li>
<li><p>The dimensions of the grid are obtained (m x n).</p></li>
<li><p>A Trie is built using the <code class="docutils literal notranslate"><span class="pre">buildTrie</span></code> function.</p></li>
<li><p>A set called <code class="docutils literal notranslate"><span class="pre">result</span></code> is used to store unique words found in the grid.</p></li>
<li><p>The code iterates through each cell on the grid (using nested loops) and starts a DFS search from each cell.</p></li>
<li><p>During the DFS, it explores neighboring cells (up, down, left, right) if they haven’t been visited before and if the current path matches a prefix in the Trie.</p></li>
<li><p>When a word is found during the DFS traversal, it is added to the <code class="docutils literal notranslate"><span class="pre">result</span></code> set.</p></li>
<li><p>The grid cell is marked as visited during the DFS by changing its character to “#”, and it is restored to its original character after the DFS traversal.</p></li>
<li><p>Finally, the set of unique words found is converted to a list and returned as the output.</p></li>
</ol>
<p>The code effectively uses a Trie data structure to optimize the search and ensures that each word is constructed from adjacent cells without reusing the same cell for the same word.</p>
</section>
<section id="test-cases">
<h4>Test cases:<a class="headerlink" href="#test-cases" title="Permalink to this heading">#</a></h4>
<p>Here’s how you can use this solution:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 1: </span>

<span class="n">board1</span> <span class="o">=</span> <span class="p">[[</span><span class="s2">&quot;o&quot;</span><span class="p">,</span><span class="s2">&quot;a&quot;</span><span class="p">,</span><span class="s2">&quot;a&quot;</span><span class="p">,</span><span class="s2">&quot;n&quot;</span><span class="p">],[</span><span class="s2">&quot;e&quot;</span><span class="p">,</span><span class="s2">&quot;t&quot;</span><span class="p">,</span><span class="s2">&quot;a&quot;</span><span class="p">,</span><span class="s2">&quot;e&quot;</span><span class="p">],[</span><span class="s2">&quot;i&quot;</span><span class="p">,</span><span class="s2">&quot;h&quot;</span><span class="p">,</span><span class="s2">&quot;k&quot;</span><span class="p">,</span><span class="s2">&quot;r&quot;</span><span class="p">],[</span><span class="s2">&quot;i&quot;</span><span class="p">,</span><span class="s2">&quot;f&quot;</span><span class="p">,</span><span class="s2">&quot;l&quot;</span><span class="p">,</span><span class="s2">&quot;v&quot;</span><span class="p">]]</span>
<span class="n">words1</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;oath&quot;</span><span class="p">,</span><span class="s2">&quot;pea&quot;</span><span class="p">,</span><span class="s2">&quot;eat&quot;</span><span class="p">,</span><span class="s2">&quot;rain&quot;</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">findWords</span><span class="p">(</span><span class="n">board1</span><span class="p">,</span> <span class="n">words1</span><span class="p">))</span>  <span class="c1"># Output: [&quot;eat&quot;, &quot;oath&quot;]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;eat&#39;, &#39;oath&#39;]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 2</span>

<span class="n">board2</span> <span class="o">=</span> <span class="p">[[</span><span class="s2">&quot;a&quot;</span><span class="p">,</span><span class="s2">&quot;b&quot;</span><span class="p">],[</span><span class="s2">&quot;c&quot;</span><span class="p">,</span><span class="s2">&quot;d&quot;</span><span class="p">]]</span>
<span class="n">words2</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;abcb&quot;</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">findWords</span><span class="p">(</span><span class="n">board2</span><span class="p">,</span> <span class="n">words2</span><span class="p">))</span>  <span class="c1"># Output: []</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[]
</pre></div>
</div>
</div>
</div>
</section>
<section id="time-and-space-complexity-analysis">
<h4>Time and Space Complexity Analysis<a class="headerlink" href="#time-and-space-complexity-analysis" title="Permalink to this heading">#</a></h4>
<p>Let’s analyze the time and space complexity of the provided code:</p>
<p><strong>Time Complexity:</strong></p>
<ol class="arabic simple">
<li><p><strong>Building the Trie (<code class="docutils literal notranslate"><span class="pre">buildTrie</span></code> function):</strong></p>
<ul class="simple">
<li><p>Suppose there are <code class="docutils literal notranslate"><span class="pre">N</span></code> words in the input list, and the average length of a word is <code class="docutils literal notranslate"><span class="pre">L</span></code>.</p></li>
<li><p>Building the Trie takes O(N * L) time, as we iterate through each word and insert each character into the Trie.</p></li>
</ul>
</li>
<li><p><strong>DFS Traversal (<code class="docutils literal notranslate"><span class="pre">dfs</span></code> function):</strong></p>
<ul class="simple">
<li><p>In the worst case, the DFS function explores all possible paths in the grid.</p></li>
<li><p>The maximum number of recursive calls for each cell is 4 (up, down, left, right).</p></li>
<li><p>The maximum depth of the DFS is limited by the length of the longest word in the Trie, which is at most <code class="docutils literal notranslate"><span class="pre">L</span></code>.</p></li>
<li><p>Therefore, the DFS traversal for each cell takes <span class="math notranslate nohighlight">\(O(4^L)\)</span> time.</p></li>
</ul>
</li>
<li><p><strong>Iterating Through the Grid (<code class="docutils literal notranslate"><span class="pre">findWords</span></code> function):</strong></p>
<ul class="simple">
<li><p>In the worst case, we iterate through all <code class="docutils literal notranslate"><span class="pre">m</span></code> rows and <code class="docutils literal notranslate"><span class="pre">n</span></code> columns in the grid.</p></li>
<li><p>For each cell, we start a DFS traversal.</p></li>
<li><p>Therefore, iterating through the entire grid takes <span class="math notranslate nohighlight">\(O(m * n * 4^L)\)</span> time.</p></li>
</ul>
</li>
</ol>
<p>Overall, the time complexity of the code is <span class="math notranslate nohighlight">\(O(N * L + m * n * 4^L)\)</span>.</p>
<p><strong>Space Complexity:</strong></p>
<ol class="arabic simple">
<li><p><strong>Trie Data Structure:</strong></p>
<ul class="simple">
<li><p>The space required to store the Trie depends on the number of unique characters in all the words.</p></li>
<li><p>In the worst case, where all words are unique and have no common prefixes, the space complexity of the Trie is O(N * L).</p></li>
<li><p>In practice, it may be less if there are common prefixes among words.</p></li>
</ul>
</li>
<li><p><strong>DFS Stack (Recursive Calls):</strong></p>
<ul class="simple">
<li><p>The depth of the recursive call stack during DFS is at most <code class="docutils literal notranslate"><span class="pre">L</span></code>, where <code class="docutils literal notranslate"><span class="pre">L</span></code> is the length of the longest word in the Trie.</p></li>
<li><p>Therefore, the space complexity for the recursive call stack is O(L).</p></li>
</ul>
</li>
<li><p><strong>Result Set (<code class="docutils literal notranslate"><span class="pre">result</span></code> set):</strong></p>
<ul class="simple">
<li><p>The space used to store the result set depends on the number of valid words found in the grid.</p></li>
<li><p>In the worst case, when all words are found, the space complexity of the result set is O(N * L).</p></li>
</ul>
</li>
</ol>
<p>Overall, the space complexity of the code is O(N * L) for the Trie and O(L) for the recursive call stack.</p>
<p>In summary, the time complexity is dominated by the DFS traversal and is influenced by the number of words, their lengths, and the size of the grid. The space complexity is mainly determined by the Trie structure and the recursive call stack depth during DFS.</p>
</section>
<section id="challenging-exercises">
<h4>Challenging Exercises:<a class="headerlink" href="#challenging-exercises" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p><strong>Word Search Paths:</strong>
Extend the basic word search exercise to find all possible paths (sequences of cells) that spell out a given word on the board. Return a list of paths if the word can be formed, otherwise an empty list.</p></li>
<li><p><strong>Reverse Word Search:</strong>
Modify the code to search for words in reverse order on the board. Given a 2D grid of characters and a list of words, find all words from the list that can be formed by traversing the board in reverse (right to left, bottom to top, etc.).</p></li>
</ol>
</section>
</section>
</div>
</section>
<span id="document-09. Heap - Priority Queue/README"></span><section class="tex2jax_ignore mathjax_ignore" id="heap-priority-queue-problems-blind-75-leetcode">
<h2>Heap / Priority Queue Problems - Blind 75 LeetCode<a class="headerlink" href="#heap-priority-queue-problems-blind-75-leetcode" title="Permalink to this heading">#</a></h2>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Problem Name</p></th>
<th class="head"><p>Difficulty</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/kth-largest-element-in-a-stream/">703. Kth Largest Element in a Stream</a></p></td>
<td><p>Easy</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/last-stone-weight/">1046. Last Stone Weight</a></p></td>
<td><p>Easy</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/find-median-from-data-stream/">295. Find Median From Data Stream</a></p></td>
<td><p>Hard</p></td>
</tr>
</tbody>
</table>
<section id="contribute">
<h3>Contribute<a class="headerlink" href="#contribute" title="Permalink to this heading">#</a></h3>
<p>If you have a better solution or want to add more problems to the collection, feel free to contribute. You can create a pull request or open an issue to discuss additions or improvements.</p>
</section>
<section id="resources">
<h3>Resources<a class="headerlink" href="#resources" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p><a class="reference external" href="https://leetcode.com/">LeetCode</a>: The official LeetCode website.</p></li>
<li><p><a class="reference external" href="https://leetcode.com/discuss/">LeetCode Discuss</a>: LeetCode’s discussion forum for each problem. You can find helpful hints and discussions here.</p></li>
</ul>
<p>Happy coding!</p>
</section>
<div class="toctree-wrapper compound">
<span id="document-09. Heap - Priority Queue/1046. Last Stone Weight"></span><section class="tex2jax_ignore mathjax_ignore" id="last-stone-weight">
<h3>1046. Last Stone Weight<a class="headerlink" href="#last-stone-weight" title="Permalink to this heading">#</a></h3>
<p><strong>Difficulty:</strong> Easy</p>
<p><strong>Link to Problem:</strong> <a class="reference external" href="https://leetcode.com/problems/last-stone-weight/">To see the Last Stone Weight problem on LeetCode, click here!</a></p>
<hr class="docutils" />
<p>You are given an array of integers <code class="docutils literal notranslate"><span class="pre">stones</span></code> where <code class="docutils literal notranslate"><span class="pre">stones[i]</span></code> is the weight of the <code class="docutils literal notranslate"><span class="pre">i</span></code>th stone.</p>
<p>We are playing a game with the stones. On each turn, you choose the <strong>heaviest two stones</strong> and smash them together. Suppose the heaviest two stones have weights <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> with <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">y</span></code>. The result of this smash is:</p>
<ol class="arabic simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code>, both stones are destroyed.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">!=</span> <span class="pre">y</span></code>, the stone of weight <code class="docutils literal notranslate"><span class="pre">x</span></code> is destroyed, and the stone of weight <code class="docutils literal notranslate"><span class="pre">y</span></code> has new weight <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">-</span> <span class="pre">x</span></code>.</p></li>
</ol>
<p>At the end of the game, there is <strong>at most one</strong> stone left.</p>
<p>Return <em>the weight of the last remaining stone</em>. If there are no stones left, return <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
<p><strong>Constraints:</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">&lt;=</span> <span class="pre">stones.length</span> <span class="pre">&lt;=</span> <span class="pre">30</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">&lt;=</span> <span class="pre">stones[i]</span> <span class="pre">&lt;=</span> <span class="pre">1000</span></code></p></li>
</ul>
<section id="probelm-explanation">
<h4>Probelm Explanation:<a class="headerlink" href="#probelm-explanation" title="Permalink to this heading">#</a></h4>
<p>The “Last Stone Weight” problem involves a game played with a collection of stones, each stone having a certain weight. The goal is to find the weight of the last remaining stone after applying a specific set of rules.</p>
<p>Here’s how the game works:</p>
<ol class="arabic simple">
<li><p>You start with an array of stones, where each stone is represented by its weight. The weights of the stones are given in the input as an array.</p></li>
<li><p>In each turn of the game, you select the two heaviest stones from the remaining stones. If there is only one stone left, you’ve found the answer.</p></li>
<li><p>If there are two stones with weights <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code>, where <code class="docutils literal notranslate"><span class="pre">x</span></code> is less than or equal to <code class="docutils literal notranslate"><span class="pre">y</span></code>, the following happens:</p>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">x</span></code> is equal to <code class="docutils literal notranslate"><span class="pre">y</span></code>, both stones are completely destroyed, and they are removed from the array of stones.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">x</span></code> is not equal to <code class="docutils literal notranslate"><span class="pre">y</span></code>, the stone with weight <code class="docutils literal notranslate"><span class="pre">x</span></code> is destroyed, and the stone with weight <code class="docutils literal notranslate"><span class="pre">y</span></code> now has a new weight of <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">-</span> <span class="pre">x</span></code>. The stone with weight <code class="docutils literal notranslate"><span class="pre">x</span></code> is removed from the array, and the modified stone with weight <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">-</span> <span class="pre">x</span></code> remains in the array.</p></li>
</ul>
</li>
<li><p>The game continues with the modified array of stones until there is at most one stone left.</p></li>
<li><p>The goal is to find the weight of the last remaining stone, or if there are no stones left, return <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p></li>
</ol>
</section>
<section id="solution">
<h4>Solution:<a class="headerlink" href="#solution" title="Permalink to this heading">#</a></h4>
<p>Here’s a Python function to implement this algorithm:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">heapq</span>

<span class="k">def</span> <span class="nf">lastStoneWeight</span><span class="p">(</span><span class="n">stones</span><span class="p">):</span>
    <span class="c1"># Convert the input list to a max heap (negate the values to simulate a max heap)</span>
    <span class="n">max_heap</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">stone</span> <span class="k">for</span> <span class="n">stone</span> <span class="ow">in</span> <span class="n">stones</span><span class="p">]</span>
    <span class="n">heapq</span><span class="o">.</span><span class="n">heapify</span><span class="p">(</span><span class="n">max_heap</span><span class="p">)</span>

    <span class="c1"># Continue as long as there are more than 1 stone in the heap</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">max_heap</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Get the two heaviest stones</span>
        <span class="n">y</span> <span class="o">=</span> <span class="o">-</span><span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">max_heap</span><span class="p">)</span>  <span class="c1"># Get the heaviest stone and negate it back to positive</span>
        <span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">max_heap</span><span class="p">)</span>  <span class="c1"># Get the second heaviest stone and negate it back to positive</span>

        <span class="c1"># Calculate the new stone&#39;s weight after smashing</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">y</span><span class="p">:</span>
            <span class="n">new_stone</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">x</span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">max_heap</span><span class="p">,</span> <span class="o">-</span><span class="n">new_stone</span><span class="p">)</span>  <span class="c1"># Negate the value and push it back to the heap</span>

    <span class="c1"># If there is one stone left, return its weight (negate it back to positive)</span>
    <span class="k">if</span> <span class="n">max_heap</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">max_heap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="explanation">
<h4>Explanation:<a class="headerlink" href="#explanation" title="Permalink to this heading">#</a></h4>
<p>The code defines a Python function called <code class="docutils literal notranslate"><span class="pre">lastStoneWeight</span></code> that takes a list of stone weights as input. It aims to find the weight of the last remaining stone after playing the stone smashing game described in the problem statement.</p>
<p>Here’s a step-by-step explanation of the code:</p>
<ol class="arabic simple">
<li><p>We import the <code class="docutils literal notranslate"><span class="pre">heapq</span></code> library, which allows us to create and manipulate a heap (priority queue).</p></li>
<li><p>Inside the <code class="docutils literal notranslate"><span class="pre">lastStoneWeight</span></code> function:</p>
<ul class="simple">
<li><p>We create a max heap (negating stone weights to simulate a max heap) using the <code class="docutils literal notranslate"><span class="pre">heapq.heapify</span></code> function. This heap will keep track of the heaviest stones.</p></li>
<li><p>We enter a loop that continues as long as there are more than 1 stone in the heap.</p></li>
<li><p>Inside the loop, we:</p>
<ul>
<li><p>Retrieve and negate the heaviest stone (<code class="docutils literal notranslate"><span class="pre">y</span></code>) from the heap.</p></li>
<li><p>Retrieve and negate the second heaviest stone (<code class="docutils literal notranslate"><span class="pre">x</span></code>) from the heap.</p></li>
<li><p>Calculate the new stone’s weight after smashing (<code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">-</span> <span class="pre">x</span></code>), and negate it back to simulate a max heap.</p></li>
<li><p>Add the new stone back to the heap using <code class="docutils literal notranslate"><span class="pre">heapq.heappush</span></code>.</p></li>
</ul>
</li>
</ul>
</li>
<li><p>After the loop, if there is one stone left in the heap, we retrieve and negate it to get its actual weight, and return it as the result.</p></li>
<li><p>If there are no stones left (the heap is empty), we return <code class="docutils literal notranslate"><span class="pre">0</span></code>, indicating that no stones remain.</p></li>
<li><p>Finally, we provide two test cases to demonstrate the function’s usage and correctness.</p></li>
</ol>
<p>In summary, the code efficiently implements the stone smashing game by maintaining a max heap, selecting the heaviest stones in each turn, smashing them, and updating the heap until there is at most one stone left. It then returns the weight of the last remaining stone or 0 if there are no stones left.</p>
</section>
<section id="test-cases">
<h4>Test cases:<a class="headerlink" href="#test-cases" title="Permalink to this heading">#</a></h4>
<p>Here’s how you can use this solution:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 1: </span>

<span class="n">stones1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">lastStoneWeight</span><span class="p">(</span><span class="n">stones1</span><span class="p">))</span>  <span class="c1"># Output: 1</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 2: </span>

<span class="n">stones2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">lastStoneWeight</span><span class="p">(</span><span class="n">stones2</span><span class="p">))</span>  <span class="c1"># Output: 1</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1
</pre></div>
</div>
</div>
</div>
</section>
<section id="time-and-space-complexity-analysis">
<h4>Time and Space Complexity Analysis<a class="headerlink" href="#time-and-space-complexity-analysis" title="Permalink to this heading">#</a></h4>
<p>Let’s analyze the time and space complexity of the provided Python code for the “Last Stone Weight” problem:</p>
<p><strong>Time Complexity:</strong></p>
<ol class="arabic simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">heapq.heapify</span></code> operation to create the max heap from the input stone weights has a time complexity of O(n), where n is the number of stones.</p></li>
<li><p>The loop that continues until there are more than 1 stone in the heap performs the following operations in each iteration:</p>
<ul class="simple">
<li><p>Retrieving and negating the heaviest stone (<code class="docutils literal notranslate"><span class="pre">y</span></code>) from the heap, which takes O(log n) time.</p></li>
<li><p>Retrieving and negating the second heaviest stone (<code class="docutils literal notranslate"><span class="pre">x</span></code>) from the heap, also taking O(log n) time.</p></li>
<li><p>Calculating the new stone’s weight and pushing it back into the heap using <code class="docutils literal notranslate"><span class="pre">heapq.heappush</span></code>, which takes O(log n) time.</p></li>
</ul>
</li>
<li><p>In the worst case, the loop runs until there is only one stone left, which requires approximately (n-1) iterations.</p></li>
</ol>
<p>Overall, the dominant time complexity is O(n) for the initial heap creation, and within the loop, each iteration takes O(log n) time. Therefore, the overall time complexity of the algorithm is O(n log n).</p>
<p><strong>Space Complexity:</strong></p>
<ol class="arabic simple">
<li><p>The space complexity is primarily determined by the space required for the max heap. In the worst case, this heap can contain all the stones, so the space complexity for the heap is O(n).</p></li>
<li><p>The rest of the variables used in the function (e.g., <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>, <code class="docutils literal notranslate"><span class="pre">new_stone</span></code>) require only constant space, so they do not significantly contribute to the space complexity.</p></li>
</ol>
<p>Therefore, the overall space complexity of the algorithm is O(n) due to the space used for the max heap.</p>
<p>In summary:</p>
<ul class="simple">
<li><p>Time Complexity: <span class="math notranslate nohighlight">\(O(n\ log\ n)\)</span></p></li>
<li><p>Space Complexity: <span class="math notranslate nohighlight">\(O(n)\)</span></p></li>
</ul>
<p>The algorithm is efficient enough to handle the problem’s constraints, as the worst-case time and space complexities are both linearithmic in terms of the number of stones.</p>
</section>
<section id="challenging-exercises">
<h4>Challenging Exercises:<a class="headerlink" href="#challenging-exercises" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p><strong>Kth Last Stone Weight</strong>: Modify the problem to find the weight of the Kth last remaining stone, where K is an integer input. Your function should work efficiently for large values of K.</p></li>
<li><p><strong>Multiple Stones Smash</strong>: Modify the problem so that instead of smashing two stones at a time, you can smash up to K stones at each turn, where K is an integer input. Determine the weight of the last remaining stone in this variation.</p></li>
</ol>
</section>
</section>
<span id="document-09. Heap - Priority Queue/295. Find Median from Data Stream"></span><section class="tex2jax_ignore mathjax_ignore" id="find-median-from-data-stream">
<h3>295. Find Median from Data Stream<a class="headerlink" href="#find-median-from-data-stream" title="Permalink to this heading">#</a></h3>
<p><strong>Difficulty:</strong> Hard</p>
<p><strong>Link to Problem:</strong> <a class="reference external" href="https://leetcode.com/problems/find-median-from-data-stream/">To see the Find Median from Data Stream problem on LeetCode, click here!</a></p>
<hr class="docutils" />
<p>The <strong>median</strong> is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.</p>
<p>Implement the MedianFinder class:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">MedianFinder()</span></code> initializes the <code class="docutils literal notranslate"><span class="pre">MedianFinder</span></code> object.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">addNum(int</span> <span class="pre">num)</span></code> adds the integer <code class="docutils literal notranslate"><span class="pre">num</span></code> from the data stream to the data structure.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">double</span> <span class="pre">findMedian()</span></code> returns the median of all elements so far. Answers within <span class="math notranslate nohighlight">\(10^{-5}\)</span> of the actual answer will be accepted.</p></li>
</ul>
<p><strong>Constraints:</strong></p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(-10^{5}\)</span> &lt;= <code class="docutils literal notranslate"><span class="pre">num</span></code> &lt;= <span class="math notranslate nohighlight">\(10^{5}\)</span></p></li>
<li><p>There will be at least one element in the data structure before calling <code class="docutils literal notranslate"><span class="pre">findMedian</span></code>.</p></li>
<li><p>At most <span class="math notranslate nohighlight">\(5 * 10^4\)</span> calls will be made to <code class="docutils literal notranslate"><span class="pre">addNum</span></code> and <code class="docutils literal notranslate"><span class="pre">findMedian</span></code>.</p></li>
</ul>
<p><strong>Follow-up:</strong></p>
<ol class="arabic simple">
<li><p>If all integer numbers from the stream are in the range <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">100]</span></code>, how would you optimize your solution?</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">99%</span></code> of all integer numbers from the stream are in the range <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">100]</span></code>, how would you optimize your solution?</p></li>
</ol>
<section id="probelm-explanation">
<h4>Probelm Explanation:<a class="headerlink" href="#probelm-explanation" title="Permalink to this heading">#</a></h4>
<p>The problem, “Find Median from Data Stream,” deals with efficiently computing the median of a sequence of numbers as they are incrementally provided. The median is the middle value in an ordered list of numbers. When the list has an even number of elements, the median is the average of the two middle values.</p>
<p>Here’s a breakdown of the problem:</p>
<ol class="arabic simple">
<li><p><strong>Initialization</strong>: You are asked to implement a <code class="docutils literal notranslate"><span class="pre">MedianFinder</span></code> class that supports the following operations:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">MedianFinder()</span></code>: Initializes the MedianFinder object.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">addNum(int</span> <span class="pre">num)</span></code>: Adds an integer <code class="docutils literal notranslate"><span class="pre">num</span></code> from the data stream to the data structure.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">findMedian()</span></code>: Returns the median of all elements added to the data structure.</p></li>
</ul>
</li>
<li><p><strong>Median Calculation</strong>: The <code class="docutils literal notranslate"><span class="pre">findMedian</span></code> operation should efficiently compute the median, and the result should have a precision of at least <span class="math notranslate nohighlight">\(10^{-5}\)</span> (i.e., answers within this range will be considered correct).</p></li>
<li><p><strong>Examples</strong>:</p>
<ul class="simple">
<li><p>If you add numbers [1, 2], the median should be 1.5 because (1 + 2) / 2 = 1.5.</p></li>
<li><p>If you add numbers [1, 2, 3], the median should be 2 because it’s the middle value.</p></li>
</ul>
</li>
<li><p><strong>Constraints</strong>:</p>
<ul class="simple">
<li><p>The integers provided in the data stream are in the range from <span class="math notranslate nohighlight">\(-10^5\)</span> to <span class="math notranslate nohighlight">\(10^5\)</span>.</p></li>
<li><p>There will be at least one element in the data structure before calling <code class="docutils literal notranslate"><span class="pre">findMedian</span></code>.</p></li>
<li><p>At most, <span class="math notranslate nohighlight">\(5 * 10^4\)</span> calls will be made to <code class="docutils literal notranslate"><span class="pre">addNum</span></code> and <code class="docutils literal notranslate"><span class="pre">findMedian</span></code>.</p></li>
</ul>
</li>
</ol>
<p>The problem can be solved by using two priority queues (heaps): one max-heap to store the smaller half of the numbers and one min-heap to store the larger half of the numbers. The max-heap ensures that the largest number in the smaller half is at the top, and the min-heap ensures that the smallest number in the larger half is at the top. These heaps are balanced to efficiently find the median when requested.</p>
</section>
<section id="solution">
<h4>Solution:<a class="headerlink" href="#solution" title="Permalink to this heading">#</a></h4>
<p>Here’s a Python function to implement this algorithm:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">heapq</span>

<span class="k">class</span> <span class="nc">MedianFinder</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Initialize two heaps: a max-heap (small_half) for the smaller half of numbers,</span>
        <span class="c1"># and a min-heap (large_half) for the larger half of numbers.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">small_half</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Max-heap for the smaller half of the numbers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">large_half</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Min-heap for the larger half of the numbers</span>

    <span class="k">def</span> <span class="nf">addNum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Add the number to the appropriate heap based on its value</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">small_half</span> <span class="ow">or</span> <span class="n">num</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">small_half</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="c1"># If the number is less than or equal to the current maximum in the smaller half,</span>
            <span class="c1"># add it to the smaller half (max-heap)</span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">small_half</span><span class="p">,</span> <span class="o">-</span><span class="n">num</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Otherwise, add it to the larger half (min-heap)</span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">large_half</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>

        <span class="c1"># Balance the heaps if necessary to ensure the size difference is at most 1</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">small_half</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">large_half</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># If the size of the smaller half is more than one greater than the size of the larger half,</span>
            <span class="c1"># move the maximum from the smaller half to the larger half to balance them.</span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">large_half</span><span class="p">,</span> <span class="o">-</span><span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">small_half</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">large_half</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">small_half</span><span class="p">):</span>
            <span class="c1"># If the size of the larger half is greater than the size of the smaller half,</span>
            <span class="c1"># move the minimum from the larger half to the smaller half to balance them.</span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">small_half</span><span class="p">,</span> <span class="o">-</span><span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">large_half</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">findMedian</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">small_half</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">large_half</span><span class="p">):</span>
            <span class="c1"># If both halves have the same size, there&#39;s an even number of elements,</span>
            <span class="c1"># so the median is the average of the top elements in both heaps.</span>
            <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">small_half</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">large_half</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If the smaller half has more elements, it contains the median (odd number of elements).</span>
            <span class="k">return</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">small_half</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="explanation">
<h4>Explanation:<a class="headerlink" href="#explanation" title="Permalink to this heading">#</a></h4>
<p>The code defines a <code class="docutils literal notranslate"><span class="pre">MedianFinder</span></code> class for efficiently finding the median of a stream of numbers. It uses two heaps: a max-heap (<code class="docutils literal notranslate"><span class="pre">small_half</span></code>) to store the smaller half of the numbers and a min-heap (<code class="docutils literal notranslate"><span class="pre">large_half</span></code>) to store the larger half. Here’s how the code works:</p>
<ol class="arabic simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">__init__</span></code> method initializes the two heaps.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">addNum</span></code> method adds a number to the appropriate heap, ensuring that the heaps remain balanced. It does this by comparing the number to the current maximum in the smaller half and adding it to the appropriate heap. Then, it checks the sizes of the two heaps and rebalances them if necessary.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">findMedian</span></code> method calculates and returns the median. If both halves have the same size (even number of elements), it computes the average of the tops of both heaps. If the smaller half has more elements (odd number of elements), it returns the top of the max-heap, which is the median.</p></li>
</ol>
<p>In summary, this code efficiently maintains two heaps to divide the elements into smaller and larger halves, allowing for quick median retrieval. It offers a time complexity of O(log N) for adding elements and O(1) for finding the median, where N is the total number of elements processed. The space complexity is O(1) as the space used by the two heaps is independent of the input size.</p>
</section>
<section id="test-cases">
<h4>Test cases:<a class="headerlink" href="#test-cases" title="Permalink to this heading">#</a></h4>
<p>Here’s how you can use this solution:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 1: </span>

<span class="c1"># Example usage:</span>
<span class="n">medianFinder</span> <span class="o">=</span> <span class="n">MedianFinder</span><span class="p">()</span>
<span class="n">medianFinder</span><span class="o">.</span><span class="n">addNum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">medianFinder</span><span class="o">.</span><span class="n">addNum</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">medianFinder</span><span class="o">.</span><span class="n">findMedian</span><span class="p">())</span>  <span class="c1"># Output: 1.5</span>
<span class="n">medianFinder</span><span class="o">.</span><span class="n">addNum</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">medianFinder</span><span class="o">.</span><span class="n">findMedian</span><span class="p">())</span>  <span class="c1"># Output: 2.0</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1.5
2
</pre></div>
</div>
</div>
</div>
</section>
<section id="time-and-space-complexity-analysis">
<h4>Time and Space Complexity Analysis<a class="headerlink" href="#time-and-space-complexity-analysis" title="Permalink to this heading">#</a></h4>
<p>Let’s analyze the time and space complexity of the <code class="docutils literal notranslate"><span class="pre">MedianFinder</span></code> class:</p>
<p><strong>Time Complexity:</strong></p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">MedianFinder()</span></code> Initialization: This operation has a time complexity of O(1). It simply initializes the two heaps.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">addNum(int</span> <span class="pre">num)</span></code>: The time complexity for adding a number is O(log N), where N is the total number of elements processed so far. This is because, in the worst case, you might need to perform logarithmic operations on the heaps to maintain their balance.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">findMedian()</span></code>: Finding the median has a time complexity of O(1). It simply involves accessing the tops of the two heaps, which takes constant time.</p></li>
</ol>
<p><strong>Space Complexity:</strong></p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">MedianFinder()</span></code> Initialization: The space complexity for initialization is O(1). It involves creating two empty heaps, which do not depend on the size of the data stream.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">addNum(int</span> <span class="pre">num)</span></code>: The space complexity for adding a number is also O(1). It involves adding the number to one of the two heaps, which do not significantly affect the overall space complexity.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">findMedian()</span></code>: The space complexity for finding the median is O(1). It doesn’t require any additional data structures that grow with the input size.</p></li>
</ol>
<p>In summary, the time complexity of the <code class="docutils literal notranslate"><span class="pre">addNum</span></code> operation is O(log N), and the time complexity of the <code class="docutils literal notranslate"><span class="pre">findMedian</span></code> operation is O(1). The space complexity is O(1) as well, as the space used by the two heaps is independent of the size of the data stream. This solution efficiently maintains and retrieves the median, making it suitable for the given problem constraints.</p>
</section>
<section id="challenging-exercises">
<h4>Challenging Exercises:<a class="headerlink" href="#challenging-exercises" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p><strong>Generalized kth Element</strong>: Extend the <code class="docutils literal notranslate"><span class="pre">MedianFinder</span></code> class to support finding the kth element in the data stream efficiently. This means finding the kth smallest or kth largest element in the stream.</p></li>
<li><p><strong>Sliding Window Median</strong>: Given an array and a sliding window size, find the median within the window as it slides over the array. This is an extension of the problem to a moving window scenario.</p></li>
</ol>
</section>
</section>
<span id="document-09. Heap - Priority Queue/703. Kth Largest Element in a Stream"></span><section class="tex2jax_ignore mathjax_ignore" id="kth-largest-element-in-a-stream">
<h3>703. Kth Largest Element in a Stream<a class="headerlink" href="#kth-largest-element-in-a-stream" title="Permalink to this heading">#</a></h3>
<p><strong>Difficulty:</strong> Easy</p>
<p><strong>Link to Problem:</strong> <a class="reference external" href="https://leetcode.com/problems/kth-largest-element-in-a-stream/">To see the Kth Largest Element in a Stream problem on LeetCode, click here!</a></p>
<hr class="docutils" />
<p>Design a class to find the <code class="docutils literal notranslate"><span class="pre">kth</span></code> largest element in a stream. Note that it is the <code class="docutils literal notranslate"><span class="pre">kth</span></code> largest element in the sorted order, not the <code class="docutils literal notranslate"><span class="pre">kth</span></code> distinct element.</p>
<p>Implement the <code class="docutils literal notranslate"><span class="pre">KthLargest</span></code> class with the following methods:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">KthLargest(int</span> <span class="pre">k,</span> <span class="pre">int[]</span> <span class="pre">nums)</span></code>: Initializes the object with the integer <code class="docutils literal notranslate"><span class="pre">k</span></code> and the stream of integers <code class="docutils literal notranslate"><span class="pre">nums</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">add(int</span> <span class="pre">val)</span></code>: Appends the integer <code class="docutils literal notranslate"><span class="pre">val</span></code> to the stream and returns the element representing the <code class="docutils literal notranslate"><span class="pre">kth</span></code> largest element in the stream.</p></li>
</ul>
<p><strong>Constraints:</strong></p>
<ul class="simple">
<li><p>1 &lt;= <code class="docutils literal notranslate"><span class="pre">k</span></code> &lt;= <span class="math notranslate nohighlight">\(10^4\)</span></p></li>
<li><p>0 &lt;= <code class="docutils literal notranslate"><span class="pre">nums.length</span></code> &lt;= <span class="math notranslate nohighlight">\(10^4\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(-10^4\)</span> &lt;= <code class="docutils literal notranslate"><span class="pre">nums[i]</span></code> &lt;= <span class="math notranslate nohighlight">\(10^4\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(-10^4\)</span> &lt;= <code class="docutils literal notranslate"><span class="pre">val</span></code> &lt;= <span class="math notranslate nohighlight">\(10^4\)</span></p></li>
<li><p>At most <span class="math notranslate nohighlight">\(10^4\)</span> calls will be made to <code class="docutils literal notranslate"><span class="pre">add</span></code>.</p></li>
<li><p>It is guaranteed that there will be at least <code class="docutils literal notranslate"><span class="pre">k</span></code> elements in the array when you search for the <code class="docutils literal notranslate"><span class="pre">kth</span></code> element.</p></li>
</ul>
<section id="probelm-explanation">
<h4>Probelm Explanation:<a class="headerlink" href="#probelm-explanation" title="Permalink to this heading">#</a></h4>
<p>The problem you’re trying to solve is to design a class called <code class="docutils literal notranslate"><span class="pre">KthLargest</span></code> that can efficiently find the kth largest element in a stream of integers. You need to support two main operations:</p>
<p>To solve this problem efficiently, you can use a min-heap data structure. Here’s how the approach works:</p>
<ol class="arabic simple">
<li><p>Initialize a min-heap to store the k largest elements. Initially, it’s empty.</p></li>
<li><p>In the <code class="docutils literal notranslate"><span class="pre">__init__</span></code> method, populate the min-heap with the first <code class="docutils literal notranslate"><span class="pre">k</span></code> elements from <code class="docutils literal notranslate"><span class="pre">nums</span></code>. This ensures that you have the k largest elements seen so far.</p></li>
<li><p>Whenever you add a new element to the stream using the <code class="docutils literal notranslate"><span class="pre">add</span></code> method, follow these steps:</p>
<ul class="simple">
<li><p>Add the new element to the min-heap.</p></li>
<li><p>If the size of the min-heap exceeds <code class="docutils literal notranslate"><span class="pre">k</span></code>, remove the smallest element from the min-heap. This ensures that you always have the k largest elements in the min-heap.</p></li>
<li><p>The smallest element in the min-heap (the root) will always represent the kth largest element in the stream.</p></li>
</ul>
</li>
</ol>
<p>Here’s why this approach works efficiently:</p>
<ul class="simple">
<li><p>By using a min-heap, you can quickly maintain the k largest elements, and finding the smallest element in the heap (the root) takes constant time.</p></li>
<li><p>When you add a new element, the min-heap’s size is kept at most <code class="docutils literal notranslate"><span class="pre">k</span></code>, which ensures that you only track the k largest elements and discard the smaller ones.</p></li>
<li><p>The time complexity for adding an element is O(log k), which is very efficient compared to sorting the entire stream, which would be O(n log n).</p></li>
<li><p>This approach meets the constraints of the problem, including handling large streams and having a low time complexity for both initialization and adding elements.</p></li>
</ul>
<p>In summary, the min-heap approach efficiently tracks the kth largest element in the stream by maintaining a heap of the k largest elements seen so far, updating it as new elements are added. This approach provides a fast and scalable solution to the problem.</p>
</section>
<section id="solution">
<h4>Solution:<a class="headerlink" href="#solution" title="Permalink to this heading">#</a></h4>
<p>Here’s a Python function to implement this algorithm:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">heapq</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>  <span class="c1"># Import the List type from the typing module</span>

<span class="k">class</span> <span class="nc">KthLargest</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="c1"># Initialize the KthLargest object with k and nums.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">=</span> <span class="n">k</span>
        <span class="c1"># Create a min-heap to store the k largest elements.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_heap</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Populate the min-heap with the first k elements from nums.</span>
        <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="c1"># Add val to the min-heap.</span>
        <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_heap</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
        <span class="c1"># If the size of the min-heap exceeds k, remove the smallest element.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_heap</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">:</span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_heap</span><span class="p">)</span>
        <span class="c1"># The root of the min-heap is the kth largest element.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_heap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="explanation">
<h4>Explanation:<a class="headerlink" href="#explanation" title="Permalink to this heading">#</a></h4>
<ul class="simple">
<li><p>We start by importing the necessary modules:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">heapq</span></code>: This module provides functions to create and manipulate heaps.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">List</span></code> from the <code class="docutils literal notranslate"><span class="pre">typing</span></code> module: This is used to specify the type of the <code class="docutils literal notranslate"><span class="pre">nums</span></code> parameter.</p></li>
</ul>
</li>
<li><p>We define the <code class="docutils literal notranslate"><span class="pre">KthLargest</span></code> class:</p>
<ul>
<li><p>The <code class="docutils literal notranslate"><span class="pre">__init__</span></code> method initializes the object with the integer <code class="docutils literal notranslate"><span class="pre">k</span></code> and the list of integers <code class="docutils literal notranslate"><span class="pre">nums</span></code>.</p></li>
<li><p>It also creates an empty min-heap called <code class="docutils literal notranslate"><span class="pre">self.min_heap</span></code> to store the k largest elements.</p></li>
<li><p>It populates the min-heap with the first <code class="docutils literal notranslate"><span class="pre">k</span></code> elements from <code class="docutils literal notranslate"><span class="pre">nums</span></code> by calling the <code class="docutils literal notranslate"><span class="pre">add</span></code> method.</p></li>
</ul>
</li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">add</span></code> method:</p>
<ul>
<li><p>Adds the new integer <code class="docutils literal notranslate"><span class="pre">val</span></code> to the min-heap using <code class="docutils literal notranslate"><span class="pre">heapq.heappush</span></code>. This maintains the min-heap property.</p></li>
<li><p>Checks if the size of the min-heap exceeds <code class="docutils literal notranslate"><span class="pre">k</span></code>. If it does, it removes the smallest element (the k+1th largest) using <code class="docutils literal notranslate"><span class="pre">heapq.heappop</span></code>.</p></li>
<li><p>Finally, it returns the smallest element in the min-heap, which is always the kth largest element.</p></li>
</ul>
</li>
</ul>
<p>Overall, this code implements a class that efficiently finds the kth largest element in a stream of integers by maintaining a min-heap of the k largest elements seen so far.</p>
</section>
<section id="test-cases">
<h4>Test cases:<a class="headerlink" href="#test-cases" title="Permalink to this heading">#</a></h4>
<p>Here’s how you can use this solution:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 1: </span>

<span class="c1"># Example usage:</span>
<span class="n">kthLargest</span> <span class="o">=</span> <span class="n">KthLargest</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">kthLargest</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>  <span class="c1"># Output: 4</span>
<span class="nb">print</span><span class="p">(</span><span class="n">kthLargest</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>  <span class="c1"># Output: 5</span>
<span class="nb">print</span><span class="p">(</span><span class="n">kthLargest</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span> <span class="c1"># Output: 5</span>
<span class="nb">print</span><span class="p">(</span><span class="n">kthLargest</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">9</span><span class="p">))</span>  <span class="c1"># Output: 8</span>
<span class="nb">print</span><span class="p">(</span><span class="n">kthLargest</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>  <span class="c1"># Output: 8</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>4
5
5
8
8
</pre></div>
</div>
</div>
</div>
</section>
<section id="time-and-space-complexity-analysis">
<h4>Time and Space Complexity Analysis<a class="headerlink" href="#time-and-space-complexity-analysis" title="Permalink to this heading">#</a></h4>
<p>Let’s analyze the time and space complexity of the <code class="docutils literal notranslate"><span class="pre">KthLargest</span></code> class using the min-heap approach:</p>
<p><strong>Time Complexity:</strong></p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">__init__</span></code> method:</p>
<ul class="simple">
<li><p>In the <code class="docutils literal notranslate"><span class="pre">__init__</span></code> method, you iterate over the first <code class="docutils literal notranslate"><span class="pre">k</span></code> elements in <code class="docutils literal notranslate"><span class="pre">nums</span></code> and add them to the min-heap. Each <code class="docutils literal notranslate"><span class="pre">heapq.heappush</span></code> operation takes O(log k) time.</p></li>
<li><p>Therefore, the time complexity of the <code class="docutils literal notranslate"><span class="pre">__init__</span></code> method is O(k * log k).</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">add</span></code> method:</p>
<ul class="simple">
<li><p>In the <code class="docutils literal notranslate"><span class="pre">add</span></code> method, you perform the following operations:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">heapq.heappush</span></code>: O(log k) to add the new element to the min-heap.</p></li>
<li><p>If the size of the min-heap exceeds <code class="docutils literal notranslate"><span class="pre">k</span></code>, you perform <code class="docutils literal notranslate"><span class="pre">heapq.heappop</span></code>, which is also O(log k).</p></li>
<li><p>Finally, you return the smallest element from the min-heap, which is O(1) because it’s always the root.</p></li>
</ul>
</li>
<li><p>Overall, the time complexity of the <code class="docutils literal notranslate"><span class="pre">add</span></code> method is O(log k).</p></li>
</ul>
</li>
<li><p>Overall, if you make <code class="docutils literal notranslate"><span class="pre">n</span></code> calls to the <code class="docutils literal notranslate"><span class="pre">add</span></code> method, the total time complexity is O(n * log k), where <code class="docutils literal notranslate"><span class="pre">n</span></code> is the total number of elements added to the stream.</p></li>
</ol>
<p><strong>Space Complexity:</strong></p>
<ol class="arabic simple">
<li><p>The space complexity is determined by the space used to store the min-heap and the instance variables.</p></li>
<li><p>The min-heap stores at most <code class="docutils literal notranslate"><span class="pre">k</span></code> elements at any given time, so its space complexity is O(k).</p></li>
<li><p>The instance variables (such as <code class="docutils literal notranslate"><span class="pre">self.k</span></code> and <code class="docutils literal notranslate"><span class="pre">self.min_heap</span></code>) have constant space requirements.</p></li>
<li><p>Therefore, the overall space complexity of the <code class="docutils literal notranslate"><span class="pre">KthLargest</span></code> class is O(k).</p></li>
</ol>
<p>In summary, the time complexity of the <code class="docutils literal notranslate"><span class="pre">KthLargest</span></code> class is O(n * log k) for <code class="docutils literal notranslate"><span class="pre">n</span></code> add operations, and the space complexity is O(k), where <code class="docutils literal notranslate"><span class="pre">k</span></code> is the parameter passed during initialization. This implementation efficiently maintains the kth largest element in the stream while meeting the problem’s constraints.</p>
</section>
<section id="challenging-exercises">
<h4>Challenging Exercises:<a class="headerlink" href="#challenging-exercises" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p><strong>Dynamic k:</strong> Modify the <code class="docutils literal notranslate"><span class="pre">KthLargest</span></code> class to support dynamic changes in the value of <code class="docutils literal notranslate"><span class="pre">k</span></code>. Implement a method <code class="docutils literal notranslate"><span class="pre">update_k</span></code> that allows changing the value of <code class="docutils literal notranslate"><span class="pre">k</span></code> during the lifetime of the object. Ensure that the object can still correctly find the kth largest element based on the updated value of <code class="docutils literal notranslate"><span class="pre">k</span></code>.</p></li>
<li><p><strong>Implement kth Smallest:</strong> Create a new class called <code class="docutils literal notranslate"><span class="pre">KthSmallest</span></code> that finds the kth smallest element in a stream instead of the kth largest. You may need to modify the data structure used in the implementation.</p></li>
</ol>
</section>
</section>
</div>
</section>
<span id="document-10. Backtracking/README"></span><section class="tex2jax_ignore mathjax_ignore" id="backtracking-problems-blind-75-leetcode">
<h2>Backtracking Problems - Blind 75 LeetCode<a class="headerlink" href="#backtracking-problems-blind-75-leetcode" title="Permalink to this heading">#</a></h2>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Problem Name</p></th>
<th class="head"><p>Difficulty</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/combination-sum/">39. Combination Sum</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/word-search/">79. Word Search</a></p></td>
<td><p>Medium</p></td>
</tr>
</tbody>
</table>
<section id="contribute">
<h3>Contribute<a class="headerlink" href="#contribute" title="Permalink to this heading">#</a></h3>
<p>If you have a better solution or want to add more problems to the collection, feel free to contribute. You can create a pull request or open an issue to discuss additions or improvements.</p>
</section>
<section id="resources">
<h3>Resources<a class="headerlink" href="#resources" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p><a class="reference external" href="https://leetcode.com/">LeetCode</a>: The official LeetCode website.</p></li>
<li><p><a class="reference external" href="https://leetcode.com/discuss/">LeetCode Discuss</a>: LeetCode’s discussion forum for each problem. You can find helpful hints and discussions here.</p></li>
</ul>
<p>Happy coding!</p>
</section>
<div class="toctree-wrapper compound">
<span id="document-10. Backtracking/39. Combination Sum"></span><section class="tex2jax_ignore mathjax_ignore" id="combination-sum">
<h3>39. Combination Sum<a class="headerlink" href="#combination-sum" title="Permalink to this heading">#</a></h3>
<p><strong>Difficulty:</strong> Medium</p>
<p><strong>Link to Problem:</strong> <a class="reference external" href="https://leetcode.com/problems/combination-sum/">To see the Combination Sum problem on LeetCode, click here!</a></p>
<hr class="docutils" />
<p>Given an array of <strong>distinct</strong> integers <code class="docutils literal notranslate"><span class="pre">candidates</span></code> and a target integer <code class="docutils literal notranslate"><span class="pre">target</span></code>, return <em>a list of all <strong>unique combinations</strong> of <code class="docutils literal notranslate"><span class="pre">candidates</span></code> where the chosen numbers sum to the <code class="docutils literal notranslate"><span class="pre">target</span></code></em>. You may return the combinations in <strong>any order</strong>.</p>
<p>The <strong>same</strong> number may be chosen from <code class="docutils literal notranslate"><span class="pre">candidates</span></code> an <strong>unlimited number</strong> of times. Two combinations are unique if the <strong>frequency</strong> of at least one of the chosen numbers is different.</p>
<p>The test cases are generated such that the number of unique combinations that sum up to <code class="docutils literal notranslate"><span class="pre">target</span></code> is less than <code class="docutils literal notranslate"><span class="pre">150</span></code> combinations for the given input.</p>
<p><strong>Constraints:</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">&lt;=</span> <span class="pre">candidates.length</span> <span class="pre">&lt;=</span> <span class="pre">30</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">&lt;=</span> <span class="pre">candidates[i]</span> <span class="pre">&lt;=</span> <span class="pre">40</span></code></p></li>
<li><p>All elements of <code class="docutils literal notranslate"><span class="pre">candidates</span></code> are <strong>distinct</strong>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">&lt;=</span> <span class="pre">target</span> <span class="pre">&lt;=</span> <span class="pre">40</span></code></p></li>
</ul>
<section id="probelm-explanation">
<h4>Probelm Explanation:<a class="headerlink" href="#probelm-explanation" title="Permalink to this heading">#</a></h4>
<p>The problem is to find all unique combinations of numbers from a given array (candidates) such that their sum equals a target number. Here are the details of the problem:</p>
<ul class="simple">
<li><p>You are given an array of distinct integers called “candidates.”</p></li>
<li><p>You are also given a target integer called “target.”</p></li>
</ul>
<p>The goal is to find all unique combinations of numbers from the candidates array where the sum of the selected numbers is equal to the target. You can use the same number from the candidates array an unlimited number of times. A combination is considered unique if it has a different frequency (i.e., a different number of occurrences) of at least one chosen number compared to other combinations.</p>
<p>For example:</p>
<p><strong>Example 1:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Input</span><span class="p">:</span> <span class="n">candidates</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="n">target</span> <span class="o">=</span> <span class="mi">7</span>
<span class="n">Output</span><span class="p">:</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">]]</span>
</pre></div>
</div>
<p>In this example, there are two unique combinations that sum up to the target:</p>
<ul class="simple">
<li><p>2 + 2 + 3 = 7</p></li>
<li><p>7 = 7</p></li>
</ul>
<p><strong>Example 2:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Input</span><span class="p">:</span> <span class="n">candidates</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="n">target</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">Output</span><span class="p">:</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">]]</span>
</pre></div>
</div>
<p>Here, there are three unique combinations that sum up to the target.</p>
<p><strong>Example 3:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Input</span><span class="p">:</span> <span class="n">candidates</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">target</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">Output</span><span class="p">:</span> <span class="p">[]</span>
</pre></div>
</div>
<p>In this case, there are no combinations that can be formed from the candidates to reach the target of 1, so the output is an empty list.</p>
<p>The problem asks you to find and return these combinations in any order.</p>
<p>The constraints for this problem include the length of the candidates array, the values of candidates, and the target value.</p>
</section>
<section id="solution">
<h4>Solution:<a class="headerlink" href="#solution" title="Permalink to this heading">#</a></h4>
<p>Here’s a Python function to implement this algorithm:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">combinationSum</span><span class="p">(</span><span class="n">candidates</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="c1"># Define a recursive DFS function to find combinations</span>
    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">remaining</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="c1"># If the remaining target is 0, we found a valid combination</span>
        <span class="k">if</span> <span class="n">remaining</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="c1"># If the remaining target is negative, this path is invalid</span>
        <span class="k">if</span> <span class="n">remaining</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="c1"># Iterate through candidates starting from &#39;start&#39; to avoid duplicates</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">candidates</span><span class="p">)):</span>
            <span class="c1"># Explore the current candidate by subtracting it from the remaining target</span>
            <span class="c1"># Add the current candidate to the path</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">remaining</span> <span class="o">-</span> <span class="n">candidates</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="p">[</span><span class="n">candidates</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>

    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Initialize an empty list to store the result</span>
    <span class="n">candidates</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>  <span class="c1"># Sort the candidates for deduplication and early stopping</span>
    <span class="n">dfs</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[])</span>  <span class="c1"># Start the DFS from the target value with an empty path</span>
    <span class="k">return</span> <span class="n">result</span>  <span class="c1"># Return the list of unique combinations</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="explanation">
<h4>Explanation:<a class="headerlink" href="#explanation" title="Permalink to this heading">#</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">combinationSum</span></code> function takes an array of distinct integers <code class="docutils literal notranslate"><span class="pre">candidates</span></code> and a target integer <code class="docutils literal notranslate"><span class="pre">target</span></code>. It returns a list of all unique combinations of <code class="docutils literal notranslate"><span class="pre">candidates</span></code> where the chosen numbers sum to the <code class="docutils literal notranslate"><span class="pre">target</span></code>. Each number in the <code class="docutils literal notranslate"><span class="pre">candidates</span></code> array can be used an unlimited number of times.</p>
<p>Here’s an overview of how the code works:</p>
<ol class="arabic simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">combinationSum</span></code> function is defined, and it takes two arguments: <code class="docutils literal notranslate"><span class="pre">candidates</span></code> and <code class="docutils literal notranslate"><span class="pre">target</span></code>.</p></li>
<li><p>Inside the function, there is a nested helper function called <code class="docutils literal notranslate"><span class="pre">backtrack</span></code>. This function is responsible for the actual combination generation using a recursive approach.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">backtrack</span></code> function is called with three arguments: <code class="docutils literal notranslate"><span class="pre">start</span></code>, <code class="docutils literal notranslate"><span class="pre">target</span></code>, and <code class="docutils literal notranslate"><span class="pre">path</span></code>. The <code class="docutils literal notranslate"><span class="pre">start</span></code> variable helps keep track of the current index in the <code class="docutils literal notranslate"><span class="pre">candidates</span></code> array, <code class="docutils literal notranslate"><span class="pre">target</span></code> keeps track of the remaining sum to be achieved, and <code class="docutils literal notranslate"><span class="pre">path</span></code> is a list that stores the current combination.</p></li>
<li><p>Within the <code class="docutils literal notranslate"><span class="pre">backtrack</span></code> function, there are three main conditional statements:</p>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">target</span></code> becomes zero, it means we have found a combination that sums up to the target, so we add <code class="docutils literal notranslate"><span class="pre">path</span></code> to the <code class="docutils literal notranslate"><span class="pre">result</span></code> list.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">target</span></code> becomes negative, it means the current combination doesn’t work, so we return without doing anything.</p></li>
<li><p>Otherwise, we enter a loop that iterates over the <code class="docutils literal notranslate"><span class="pre">candidates</span></code> array, starting from the current index <code class="docutils literal notranslate"><span class="pre">start</span></code>.</p></li>
</ul>
</li>
<li><p>In the loop, the <code class="docutils literal notranslate"><span class="pre">backtrack</span></code> function is called recursively with the updated <code class="docutils literal notranslate"><span class="pre">target</span></code> and <code class="docutils literal notranslate"><span class="pre">path</span></code> after including the current candidate. This process explores different combinations by considering the current candidate or moving to the next candidate.</p></li>
<li><p>After the loop completes, the <code class="docutils literal notranslate"><span class="pre">result</span></code> list contains all unique combinations that sum to the target.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">candidates</span></code> array is sorted to optimize the search. Sorting helps in avoiding unnecessary recursive branches and reduces the number of explored combinations.</p></li>
<li><p>Finally, the <code class="docutils literal notranslate"><span class="pre">backtrack</span></code> function is initially called from the <code class="docutils literal notranslate"><span class="pre">combinationSum</span></code> function with <code class="docutils literal notranslate"><span class="pre">start</span></code> set to 0, <code class="docutils literal notranslate"><span class="pre">target</span></code> set to the original target value, and an empty <code class="docutils literal notranslate"><span class="pre">path</span></code>. The result is returned as a list of unique combinations.</p></li>
</ol>
<p>The code includes a few example cases to demonstrate how the function works with different inputs.</p>
</section>
<section id="test-cases">
<h4>Test cases:<a class="headerlink" href="#test-cases" title="Permalink to this heading">#</a></h4>
<p>Here’s how you can use this solution:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 1: </span>

<span class="c1"># Example 1</span>
<span class="n">candidates1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>
<span class="n">target1</span> <span class="o">=</span> <span class="mi">7</span>
<span class="nb">print</span><span class="p">(</span><span class="n">combinationSum</span><span class="p">(</span><span class="n">candidates1</span><span class="p">,</span> <span class="n">target1</span><span class="p">))</span>  <span class="c1"># Output: [[2, 2, 3], [7]]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[2, 2, 3], [7]]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 2</span>
<span class="n">candidates2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="n">target2</span> <span class="o">=</span> <span class="mi">8</span>
<span class="nb">print</span><span class="p">(</span><span class="n">combinationSum</span><span class="p">(</span><span class="n">candidates2</span><span class="p">,</span> <span class="n">target2</span><span class="p">))</span>  <span class="c1"># Output: [[2, 2, 2, 2], [2, 3, 3], [3, 5]]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[2, 2, 2, 2], [2, 3, 3], [3, 5]]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 3</span>
<span class="n">candidates3</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="n">target3</span> <span class="o">=</span> <span class="mi">1</span>
<span class="nb">print</span><span class="p">(</span><span class="n">combinationSum</span><span class="p">(</span><span class="n">candidates3</span><span class="p">,</span> <span class="n">target3</span><span class="p">))</span>  <span class="c1"># Output: []</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[]
</pre></div>
</div>
</div>
</div>
</section>
<section id="time-and-space-complexity-analysis">
<h4>Time and Space Complexity Analysis<a class="headerlink" href="#time-and-space-complexity-analysis" title="Permalink to this heading">#</a></h4>
<p>Let’s analyze the time and space complexity of the <code class="docutils literal notranslate"><span class="pre">combinationSum</span></code> function.</p>
<p><strong>Time Complexity:</strong>
The time complexity of this function is influenced by the number of recursive calls made by the <code class="docutils literal notranslate"><span class="pre">backtrack</span></code> function and the amount of work done within each call. In the worst case, the function will explore all possible combinations.</p>
<p>The worst-case scenario occurs when we have many combinations to reach the target. The time complexity can be expressed as <span class="math notranslate nohighlight">\(O(2^n)\)</span>, where ‘n’ is the maximum number of recursive calls. In this context, ‘n’ corresponds to the number of elements in the <code class="docutils literal notranslate"><span class="pre">candidates</span></code> list, and it may be up to 30 (as per the constraints). However, the actual number of combinations explored is generally much smaller because we eliminate branches when the target becomes negative, and we skip over candidates that cannot lead to a solution. The sorting step also helps to optimize the search.</p>
<p><strong>Space Complexity:</strong>
The space complexity is determined by the auxiliary space used for storing the results and the stack space for the recursive calls.</p>
<ol class="arabic simple">
<li><p>The space required for the <code class="docutils literal notranslate"><span class="pre">result</span></code> list can be up to <span class="math notranslate nohighlight">\(O(2^n)\)</span> in the worst case because each combination is stored.</p></li>
<li><p>The stack space for the recursive calls can also be up to O(n) in the worst case, where ‘n’ is the number of elements in the <code class="docutils literal notranslate"><span class="pre">candidates</span></code> list.</p></li>
</ol>
<p>Therefore, the overall space complexity of the function is <span class="math notranslate nohighlight">\(O(2^n + n)\)</span>. However, in practice, the space used for the results list is often the dominant factor, and the actual space used may be much smaller than 2^n because not all combinations are explored.</p>
<p>In summary, the time complexity is exponential but typically smaller in practice due to optimization, and the space complexity is influenced by the number of results and the depth of the recursion.</p>
</section>
<section id="challenging-exercises">
<h4>Challenging Exercises:<a class="headerlink" href="#challenging-exercises" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p><strong>Find the Number of Unique Combinations:</strong> Instead of listing all unique combinations, modify the function to return the count of unique combinations that sum to the target.</p></li>
<li><p><strong>Combinations with a Maximum Value:</strong> Add a maximum value constraint for each combination, so they cannot exceed a certain value. Modify the code to find combinations respecting this constraint.</p></li>
</ol>
</section>
</section>
<span id="document-10. Backtracking/79. Word Search"></span><section class="tex2jax_ignore mathjax_ignore" id="word-search">
<h3>79. Word Search<a class="headerlink" href="#word-search" title="Permalink to this heading">#</a></h3>
<p><strong>Difficulty:</strong> Medium</p>
<p><strong>Link to Problem:</strong> <a class="reference external" href="https://leetcode.com/problems/word-search/">To see the Word Search problem on LeetCode, click here!</a></p>
<hr class="docutils" />
<p>Given an <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">x</span> <span class="pre">n</span></code> grid of characters <code class="docutils literal notranslate"><span class="pre">board</span></code> and a string <code class="docutils literal notranslate"><span class="pre">word</span></code>, return <em><code class="docutils literal notranslate"><span class="pre">true</span></code> if <code class="docutils literal notranslate"><span class="pre">word</span></code> exists in the grid.</em></p>
<p>The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>
<p><strong>Constraints:</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">==</span> <span class="pre">board.length</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">=</span> <span class="pre">board[i].length</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">&lt;=</span> <span class="pre">m,</span> <span class="pre">n</span> <span class="pre">&lt;=</span> <span class="pre">6</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">&lt;=</span> <span class="pre">word.length</span> <span class="pre">&lt;=</span> <span class="pre">15</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">board</span></code> and <code class="docutils literal notranslate"><span class="pre">word</span></code> consists of only lowercase and uppercase English letters.</p></li>
</ul>
<p><strong>Follow up:</strong> Could you use search pruning to make your solution faster with a larger <code class="docutils literal notranslate"><span class="pre">board</span></code>?</p>
<section id="probelm-explanation">
<h4>Probelm Explanation:<a class="headerlink" href="#probelm-explanation" title="Permalink to this heading">#</a></h4>
<p>The problem is to determine whether a given word can be constructed from characters in an <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">x</span> <span class="pre">n</span></code> grid of characters. The word can be formed by moving sequentially through horizontally or vertically neighboring cells in the grid, and you cannot use the same cell more than once.</p>
<p>Here are the specifics of the problem:</p>
<ul class="simple">
<li><p>You are given an <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">x</span> <span class="pre">n</span></code> grid, which is a 2D board of characters.</p></li>
<li><p>You are also given a string <code class="docutils literal notranslate"><span class="pre">word</span></code> consisting of lowercase and uppercase English letters.</p></li>
<li><p>Your task is to determine if the word can be found in the grid by moving from one cell to an adjacent cell (horizontally or vertically) and collecting the characters sequentially to form the word.</p></li>
<li><p>You can’t use the same cell more than once when forming the word.</p></li>
<li><p>If it’s possible to form the word in the grid, return <code class="docutils literal notranslate"><span class="pre">True</span></code>; otherwise, return <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
</ul>
<p>For example, consider the following grid and word:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">board</span> <span class="o">=</span> <span class="p">[[</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">],</span>
         <span class="p">[</span><span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;F&quot;</span><span class="p">,</span> <span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="s2">&quot;S&quot;</span><span class="p">],</span>
         <span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="s2">&quot;D&quot;</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">]]</span>         
<span class="n">word</span> <span class="o">=</span> <span class="s2">&quot;ABCCED&quot;</span>
</pre></div>
</div>
<p>In this case, the word “ABCCED” can be formed by moving through the cells (0,0) -&gt; (0,1) -&gt; (0,2) -&gt; (1,2) -&gt; (2,2) -&gt; (2,3) in the grid. Therefore, the function should return <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<p>Conversely, if the word is impossible to construct, such as in the case of the word “ABCB” for the same grid, where there’s no valid path that forms the word, the function should return <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<p>The problem involves searching for a path through the grid that matches the characters in the word while respecting the constraints mentioned. It can be solved using depth-first search (DFS) or backtracking.</p>
</section>
<section id="solution">
<h4>Solution:<a class="headerlink" href="#solution" title="Permalink to this heading">#</a></h4>
<p>Here’s a Python function to implement this algorithm:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">exist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">board</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">word</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
            <span class="c1"># Check if the current position is out of bounds or doesn&#39;t match the character in the word.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">board</span><span class="p">))</span> <span class="ow">or</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">board</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="ow">or</span> <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">word</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
                <span class="k">return</span> <span class="kc">False</span>
            
            <span class="c1"># If we have matched all characters in the word, return True.</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>

            <span class="c1"># Temporarily mark the current cell to prevent revisiting.</span>
            <span class="n">tmp</span><span class="p">,</span> <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="s2">&quot;/&quot;</span>

            <span class="c1"># Explore adjacent cells by making recursive calls in all four directions.</span>
            <span class="n">found</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="n">dfs</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

            <span class="c1"># Restore the original character in the cell.</span>
            <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>

            <span class="k">return</span> <span class="n">found</span>

        <span class="c1"># Iterate through all cells in the board.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">board</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">board</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
                <span class="c1"># Check if the &#39;dfs&#39; function starting from this cell returns True.</span>
                <span class="k">if</span> <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">True</span>

        <span class="c1"># If no match is found after exploring all cells, return False.</span>
        <span class="k">return</span> <span class="kc">False</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="explanation">
<h4>Explanation:<a class="headerlink" href="#explanation" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p>Import the necessary module:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">typing</span> <span class="pre">import</span> <span class="pre">List</span></code>: This line imports the <code class="docutils literal notranslate"><span class="pre">List</span></code> type from the <code class="docutils literal notranslate"><span class="pre">typing</span></code> module, which is used to specify the type of the <code class="docutils literal notranslate"><span class="pre">board</span></code> parameter in the method signature.</p></li>
</ul>
</li>
<li><p>Define the <code class="docutils literal notranslate"><span class="pre">Solution</span></code> class:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">class</span> <span class="pre">Solution:</span></code>: This line defines a class called <code class="docutils literal notranslate"><span class="pre">Solution</span></code> to encapsulate the solution for the word search problem.</p></li>
</ul>
</li>
<li><p>Define the <code class="docutils literal notranslate"><span class="pre">exist</span></code> method:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">def</span> <span class="pre">exist(self,</span> <span class="pre">board:</span> <span class="pre">List[List[str]],</span> <span class="pre">word:</span> <span class="pre">str)</span> <span class="pre">-&gt;</span> <span class="pre">bool:</span></code>: This method is a member of the <code class="docutils literal notranslate"><span class="pre">Solution</span></code> class and takes two parameters: <code class="docutils literal notranslate"><span class="pre">board</span></code>, which is a 2D list of characters, and <code class="docutils literal notranslate"><span class="pre">word</span></code>, which is a string. It returns a boolean value, indicating whether the word exists in the board.</p></li>
</ul>
</li>
<li><p>Implement the inner <code class="docutils literal notranslate"><span class="pre">dfs</span></code> function:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">def</span> <span class="pre">dfs(i,</span> <span class="pre">j,</span> <span class="pre">k):</span></code>: This is a helper function used for depth-first search (DFS). It is called recursively to explore the board and search for the word. It takes three parameters: <code class="docutils literal notranslate"><span class="pre">i</span></code> and <code class="docutils literal notranslate"><span class="pre">j</span></code> representing the current position on the board, and <code class="docutils literal notranslate"><span class="pre">k</span></code> representing the current index in the <code class="docutils literal notranslate"><span class="pre">word</span></code> string.</p></li>
<li><p>Inside <code class="docutils literal notranslate"><span class="pre">dfs</span></code>, it checks if the current position is out of bounds or if the character at the current position on the board does not match the character at the current index in the <code class="docutils literal notranslate"><span class="pre">word</span></code>. If either of these conditions is met, it returns <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">k</span></code> is equal to the length of the <code class="docutils literal notranslate"><span class="pre">word</span></code> minus one, it means we have successfully matched all characters in the <code class="docutils literal notranslate"><span class="pre">word</span></code>, so it returns <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p></li>
<li><p>The function then temporarily replaces the character at the current position with a marker, “/”, to prevent revisiting the same cell. It then explores adjacent cells by making recursive calls in all four directions: up, down, left, and right. If any of these recursive calls return <code class="docutils literal notranslate"><span class="pre">True</span></code>, it propagates the <code class="docutils literal notranslate"><span class="pre">True</span></code> result up the call stack. After the exploration is complete, it restores the original character in the cell.</p></li>
</ul>
</li>
<li><p>Iterate through the board:</p>
<ul class="simple">
<li><p>The outer loop iterates through all cells in the <code class="docutils literal notranslate"><span class="pre">board</span></code> using two nested loops. For each cell, it checks if the <code class="docutils literal notranslate"><span class="pre">dfs</span></code> function starting from that cell (with <code class="docutils literal notranslate"><span class="pre">k</span></code> initially set to 0) returns <code class="docutils literal notranslate"><span class="pre">True</span></code>. If it does, it means the word exists, so the method returns <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p></li>
</ul>
</li>
<li><p>Return <code class="docutils literal notranslate"><span class="pre">False</span></code>:</p>
<ul class="simple">
<li><p>If the loop completes without finding the word in the board, the method returns <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
</ul>
</li>
</ol>
<p>To use this code, you can create an instance of the <code class="docutils literal notranslate"><span class="pre">Solution</span></code> class and call the <code class="docutils literal notranslate"><span class="pre">exist</span></code> method on that instance, passing the <code class="docutils literal notranslate"><span class="pre">board</span></code> and the <code class="docutils literal notranslate"><span class="pre">word</span></code> as arguments to check if the word exists in the board.</p>
</section>
<section id="test-cases">
<h4>Test cases:<a class="headerlink" href="#test-cases" title="Permalink to this heading">#</a></h4>
<p>Here’s how you can use this solution:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 1: </span>

<span class="c1"># Create an instance of the Solution class</span>
<span class="n">solution</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">()</span>

<span class="c1"># Test case 1: Word &quot;ABCCED&quot; can be found in the grid</span>
<span class="n">board1</span> <span class="o">=</span> <span class="p">[[</span><span class="s2">&quot;A&quot;</span><span class="p">,</span><span class="s2">&quot;B&quot;</span><span class="p">,</span><span class="s2">&quot;C&quot;</span><span class="p">,</span><span class="s2">&quot;E&quot;</span><span class="p">],</span>
          <span class="p">[</span><span class="s2">&quot;S&quot;</span><span class="p">,</span><span class="s2">&quot;F&quot;</span><span class="p">,</span><span class="s2">&quot;C&quot;</span><span class="p">,</span><span class="s2">&quot;S&quot;</span><span class="p">],</span>
          <span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">,</span><span class="s2">&quot;D&quot;</span><span class="p">,</span><span class="s2">&quot;E&quot;</span><span class="p">,</span><span class="s2">&quot;E&quot;</span><span class="p">]]</span>
<span class="n">word1</span> <span class="o">=</span> <span class="s2">&quot;ABCCED&quot;</span>
<span class="nb">print</span><span class="p">(</span><span class="n">solution</span><span class="o">.</span><span class="n">exist</span><span class="p">(</span><span class="n">board1</span><span class="p">,</span> <span class="n">word1</span><span class="p">))</span>  <span class="c1"># Expected output: True</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 2</span>

<span class="c1"># Test case 2: Word &quot;SEE&quot; can be found in the grid</span>
<span class="n">word2</span> <span class="o">=</span> <span class="s2">&quot;SEE&quot;</span>
<span class="nb">print</span><span class="p">(</span><span class="n">solution</span><span class="o">.</span><span class="n">exist</span><span class="p">(</span><span class="n">board1</span><span class="p">,</span> <span class="n">word2</span><span class="p">))</span>  <span class="c1"># Expected output: True</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 3</span>

<span class="c1"># Test case 3: Word &quot;ABCB&quot; cannot be found in the grid</span>
<span class="n">word3</span> <span class="o">=</span> <span class="s2">&quot;ABCB&quot;</span>
<span class="nb">print</span><span class="p">(</span><span class="n">solution</span><span class="o">.</span><span class="n">exist</span><span class="p">(</span><span class="n">board1</span><span class="p">,</span> <span class="n">word3</span><span class="p">))</span>  <span class="c1"># Expected output: False</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>False
</pre></div>
</div>
</div>
</div>
</section>
<section id="time-and-space-complexity-analysis">
<h4>Time and Space Complexity Analysis<a class="headerlink" href="#time-and-space-complexity-analysis" title="Permalink to this heading">#</a></h4>
<p>Let’s analyze the time and space complexity of the <code class="docutils literal notranslate"><span class="pre">exist</span></code> method in the given code.</p>
<p><strong>Time Complexity:</strong></p>
<p>The primary work in this code is done by the <code class="docutils literal notranslate"><span class="pre">dfs</span></code> function, which performs a depth-first search through the grid. The time complexity of the <code class="docutils literal notranslate"><span class="pre">dfs</span></code> function is <span class="math notranslate nohighlight">\(O(4^(n))\)</span>, where “n” is the length of the <code class="docutils literal notranslate"><span class="pre">word</span></code>. This is because, in the worst case, the function explores all possible directions (up, down, left, right) for each character in the <code class="docutils literal notranslate"><span class="pre">word</span></code>.</p>
<p>The outer loops iterate through all cells in the <code class="docutils literal notranslate"><span class="pre">board</span></code>, which has dimensions <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">x</span> <span class="pre">n</span></code>. So, the total number of iterations of <code class="docutils literal notranslate"><span class="pre">dfs</span></code> is O(m * n). However, since the <code class="docutils literal notranslate"><span class="pre">dfs</span></code> function has a higher time complexity, the overall time complexity is still dominated by the <code class="docutils literal notranslate"><span class="pre">dfs</span></code> function.</p>
<p>Therefore, the overall time complexity of the <code class="docutils literal notranslate"><span class="pre">exist</span></code> method is <span class="math notranslate nohighlight">\(O(m * n * 4^n)\)</span>, where “m” and “n” are the dimensions of the board, and “n” is the length of the word.</p>
<p><strong>Space Complexity:</strong></p>
<ol class="arabic simple">
<li><p>The primary space usage comes from the recursive calls in the <code class="docutils literal notranslate"><span class="pre">dfs</span></code> function. The depth of the recursion can be at most equal to the length of the <code class="docutils literal notranslate"><span class="pre">word</span></code>, which is O(n).</p></li>
<li><p>Additionally, the <code class="docutils literal notranslate"><span class="pre">tmp</span></code> variable and the recursive calls on the call stack consume a small amount of additional memory.</p></li>
<li><p>The marking of visited cells with the “/” character temporarily modifies the <code class="docutils literal notranslate"><span class="pre">board</span></code> in-place but doesn’t significantly contribute to the space complexity.</p></li>
</ol>
<p>Therefore, the overall space complexity is O(n) due to the recursive call stack.</p>
<p>In summary, the time complexity is <span class="math notranslate nohighlight">\(O(m * n * 4^n)\)</span>, and the space complexity is O(n), where “m” and “n” are the dimensions of the board, and “n” is the length of the word. The time complexity is exponential in the worst case due to the depth-first search through all possible paths in the grid.</p>
</section>
<section id="challenging-exercises">
<h4>Challenging Exercises:<a class="headerlink" href="#challenging-exercises" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p><strong>Optimization Challenge:</strong> Modify the code to find all unique words that can be constructed from the grid. Instead of returning <code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code>, return a list of words found. Ensure that the same cell is not used more than once in constructing each word.</p></li>
<li><p><strong>Board Generation:</strong> Create a function to generate random grids of characters and then use the <code class="docutils literal notranslate"><span class="pre">exist</span></code> method to solve them. Test the efficiency and correctness of your code by generating larger boards and words.</p></li>
</ol>
</section>
</section>
</div>
</section>
<span id="document-11. Graphs/README"></span><section class="tex2jax_ignore mathjax_ignore" id="graphs-problems-blind-75-leetcode">
<h2>Graphs Problems - Blind 75 LeetCode<a class="headerlink" href="#graphs-problems-blind-75-leetcode" title="Permalink to this heading">#</a></h2>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Problem Name</p></th>
<th class="head"><p>Difficulty</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/number-of-islands/">200. Number of Islands</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/clone-graph/">133. Clone Graph</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/pacific-atlantic-water-flow/">417. Pacific Atlantic Water Flow</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/course-schedule/">207. Course Schedule</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/">323. Number of Connected Components In An Undirected Graph</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/graph-valid-tree/">261. Graph Valid Tree</a></p></td>
<td><p>Medium</p></td>
</tr>
</tbody>
</table>
<section id="contribute">
<h3>Contribute<a class="headerlink" href="#contribute" title="Permalink to this heading">#</a></h3>
<p>If you have a better solution or want to add more problems to the collection, feel free to contribute. You can create a pull request or open an issue to discuss additions or improvements.</p>
</section>
<section id="resources">
<h3>Resources<a class="headerlink" href="#resources" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p><a class="reference external" href="https://leetcode.com/">LeetCode</a>: The official LeetCode website.</p></li>
<li><p><a class="reference external" href="https://leetcode.com/discuss/">LeetCode Discuss</a>: LeetCode’s discussion forum for each problem. You can find helpful hints and discussions here.</p></li>
</ul>
<p>Happy coding!</p>
</section>
<div class="toctree-wrapper compound">
<span id="document-11. Graphs/133. Clone Graph"></span><section class="tex2jax_ignore mathjax_ignore" id="clone-graph">
<h3>133. Clone Graph<a class="headerlink" href="#clone-graph" title="Permalink to this heading">#</a></h3>
<p><strong>Difficulty:</strong> Medium</p>
<p><strong>Link to Problem:</strong> <a class="reference external" href="https://leetcode.com/problems/clone-graph/">To see the Clone Graph problem on LeetCode, click here!</a></p>
<hr class="docutils" />
<p>Given a reference of a node in a <strong>connected</strong> undirected graph.</p>
<p>Return a <strong>deep copy</strong> (clone) of the graph.</p>
<p>Each node in the graph contains a value (<code class="docutils literal notranslate"><span class="pre">int</span></code>) and a list (<code class="docutils literal notranslate"><span class="pre">List[Node]</span></code>) of its neighbors.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Node</span> <span class="p">{</span>
    <span class="n">public</span> <span class="nb">int</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">neighbors</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Test case format:</strong></p>
<p>For simplicity, each node’s value is the same as the node’s index (1-indexed). For example, the first node with <code class="docutils literal notranslate"><span class="pre">val</span> <span class="pre">==</span> <span class="pre">1</span></code>, the second node with <code class="docutils literal notranslate"><span class="pre">val</span> <span class="pre">==</span> <span class="pre">2</span></code>, and so on. The graph is represented in the test case using an adjacency list.</p>
<p><strong>An adjacency list</strong> is a collection of unordered <strong>lists</strong> used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.</p>
<p>The given node will always be the first node with <code class="docutils literal notranslate"><span class="pre">val</span> <span class="pre">=</span> <span class="pre">1</span></code>. You must return the <strong>copy of the given node</strong> as a reference to the cloned graph.</p>
<p><strong>Constraints:</strong></p>
<ul class="simple">
<li><p>The number of nodes in the graph is in the range <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">100]</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">&lt;=</span> <span class="pre">Node.val</span> <span class="pre">&lt;=</span> <span class="pre">100</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Node.val</span></code> is unique for each node.</p></li>
<li><p>There are no repeated edges and no self-loops in the graph.</p></li>
<li><p>The Graph is connected and all nodes can be visited starting from the given node.</p></li>
</ul>
<section id="probelm-explanation">
<h4>Probelm Explanation:<a class="headerlink" href="#probelm-explanation" title="Permalink to this heading">#</a></h4>
<p>The problem at hand is to clone a connected undirected graph, which means we need to create a deep copy of the original graph while preserving its structure and relationships between nodes. The graph is represented using adjacency lists, where each node has a value (an integer) and a list of its neighbors.</p>
<p>Here are the key aspects of the problem:</p>
<ol class="arabic simple">
<li><p><strong>Input</strong>: You are given a reference to one of the nodes in the original graph. This reference node serves as the entry point to the graph. The entire graph can be explored starting from this node.</p></li>
<li><p><strong>Output</strong>: The goal is to create a deep copy of the graph and return a reference to the cloned graph. The cloned graph should have the same structure and relationships as the original one but should be a separate instance in memory.</p></li>
<li><p><strong>Graph Structure</strong>: The graph is composed of nodes (vertices) and edges. Nodes have values (integers) and are connected to other nodes through edges (undirected connections). Each node has a list of neighbors, which are other nodes it is connected to.</p></li>
<li><p><strong>Connected Graph</strong>: The problem assumes that the graph is connected, meaning that you can start from the reference node provided and traverse the entire graph by following the edges. This ensures that there are no isolated components in the graph.</p></li>
</ol>
<p>To solve this problem, you typically need to perform a graph traversal (e.g., depth-first search or breadth-first search) to visit all the nodes in the original graph, create corresponding nodes in the clone, and establish the same connections between nodes in the cloned graph as in the original one. To avoid duplication of nodes, you also need to keep track of visited nodes to ensure that the cloning process is efficient and that nodes are not duplicated in the clone.</p>
<p>The problem can be challenging because you need to create a deep copy of the graph while handling cyclic dependencies between nodes and ensuring that the structure and relationships of the original graph are preserved in the clone. The solution requires recursion or a data structure to maintain the mapping between original nodes and their clones to achieve an efficient and accurate cloning process.</p>
</section>
<section id="solution">
<h4>Solution:<a class="headerlink" href="#solution" title="Permalink to this heading">#</a></h4>
<p>Here’s a Python function to implement this algorithm:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Definition for a Node.</span>
<span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">neighbors</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">neighbors</span> <span class="o">=</span> <span class="n">neighbors</span> <span class="k">if</span> <span class="n">neighbors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[]</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">cloneGraph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="s1">&#39;Node&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Node&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">visited</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># Dictionary to keep track of visited nodes</span>

        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">original_node</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">original_node</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">visited</span><span class="p">[</span><span class="n">original_node</span><span class="p">]</span>

            <span class="c1"># Create a copy of the original node</span>
            <span class="n">copy_node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">original_node</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
            <span class="n">visited</span><span class="p">[</span><span class="n">original_node</span><span class="p">]</span> <span class="o">=</span> <span class="n">copy_node</span>

            <span class="c1"># Recursively clone the neighbors of the original node</span>
            <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">original_node</span><span class="o">.</span><span class="n">neighbors</span><span class="p">:</span>
                <span class="n">copy_node</span><span class="o">.</span><span class="n">neighbors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dfs</span><span class="p">(</span><span class="n">neighbor</span><span class="p">))</span>

            <span class="k">return</span> <span class="n">copy_node</span>

        <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="explanation">
<h4>Explanation:<a class="headerlink" href="#explanation" title="Permalink to this heading">#</a></h4>
<p>The given code defines a Python class, <code class="docutils literal notranslate"><span class="pre">Node</span></code>, and a solution class, <code class="docutils literal notranslate"><span class="pre">Solution</span></code>, to clone a connected undirected graph represented by nodes and their neighbors. Here’s an explanation of the code:</p>
<ol class="arabic simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">Node</span></code> class defines a node in the graph. Each node has a value (<code class="docutils literal notranslate"><span class="pre">val</span></code>) which is an integer and a list of neighbors (<code class="docutils literal notranslate"><span class="pre">neighbors</span></code>) that are other nodes in the graph.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">Solution</span></code> class contains the method <code class="docutils literal notranslate"><span class="pre">cloneGraph</span></code>, which takes a reference to the first node of the graph (<code class="docutils literal notranslate"><span class="pre">node</span></code>) as input and returns a deep copy of the entire graph, preserving the structure and relationships between nodes.</p></li>
<li><p>Inside the <code class="docutils literal notranslate"><span class="pre">cloneGraph</span></code> method:</p>
<ul class="simple">
<li><p>It first checks if the input <code class="docutils literal notranslate"><span class="pre">node</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>. If it’s <code class="docutils literal notranslate"><span class="pre">None</span></code>, it means there is no graph to clone, and the method returns <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p></li>
<li><p>It initializes a <code class="docutils literal notranslate"><span class="pre">visited</span></code> dictionary to keep track of visited nodes. This dictionary is used to ensure that each node is cloned only once to avoid duplication.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">dfs</span></code> (depth-first search) function is defined within the <code class="docutils literal notranslate"><span class="pre">cloneGraph</span></code> method. It takes an original node as input and returns its corresponding clone. This function performs the actual cloning of the graph.</p></li>
<li><p>Inside the <code class="docutils literal notranslate"><span class="pre">dfs</span></code> function:</p>
<ul>
<li><p>It checks if the original node has been visited before by looking it up in the <code class="docutils literal notranslate"><span class="pre">visited</span></code> dictionary. If it has been visited, it returns the corresponding clone from the <code class="docutils literal notranslate"><span class="pre">visited</span></code> dictionary.</p></li>
<li><p>If the original node is not visited, it creates a new node, <code class="docutils literal notranslate"><span class="pre">copy_node</span></code>, with the same value as the original node. This is the first step in creating the clone of the original node.</p></li>
<li><p>It then recursively clones the neighbors of the original node by iterating through the <code class="docutils literal notranslate"><span class="pre">neighbors</span></code> list of the original node and appending the corresponding cloned neighbors to the <code class="docutils literal notranslate"><span class="pre">neighbors</span></code> list of the <code class="docutils literal notranslate"><span class="pre">copy_node</span></code>. This step ensures that the relationships between nodes are preserved in the clone.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">copy_node</span></code> is added to the <code class="docutils literal notranslate"><span class="pre">visited</span></code> dictionary with the original node as the key and the clone as the value.</p></li>
<li><p>Finally, the <code class="docutils literal notranslate"><span class="pre">copy_node</span></code> is returned as the result of the DFS for the original node.</p></li>
</ul>
</li>
</ul>
</li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">cloneGraph</span></code> method returns the result of the DFS on the input <code class="docutils literal notranslate"><span class="pre">node</span></code>, which is the clone of the entire graph with its structure and relationships intact.</p></li>
</ol>
<p>In summary, the code uses depth-first search (DFS) to traverse the original graph, creating a clone for each node and its neighbors. It ensures that each node is cloned only once to avoid duplication and returns a reference to the cloned graph.</p>
</section>
<section id="test-cases">
<h4>Test cases:<a class="headerlink" href="#test-cases" title="Permalink to this heading">#</a></h4>
<p>Here’s how you can use this solution:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_adjacency_list</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># Dictionary to keep track of visited nodes</span>

    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">visited</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>

        <span class="n">neighbors</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="o">.</span><span class="n">val</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">neighbors</span><span class="p">]</span>
        <span class="n">visited</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">neighbors</span>

        <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">neighbors</span><span class="p">:</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>

    <span class="n">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">get_node_and_neighbors</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">node</span><span class="o">.</span><span class="n">val</span><span class="p">]</span> <span class="o">+</span> <span class="n">visited</span><span class="p">[</span><span class="n">node</span><span class="p">])</span>

    <span class="n">get_node_and_neighbors</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="c1"># Testing the code with the provided examples</span>
<span class="n">adjList1</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]</span>
<span class="n">solution</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">()</span>

<span class="c1"># Create the graph from adjList</span>
<span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">Node</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">adjList1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">adj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">adjList1</span><span class="p">):</span>
    <span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">neighbors</span> <span class="o">=</span> <span class="p">[</span><span class="n">nodes</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">adj</span><span class="p">]</span>

<span class="c1"># Clone the graph and get its adjacency list</span>
<span class="n">cloned_node1</span> <span class="o">=</span> <span class="n">solution</span><span class="o">.</span><span class="n">cloneGraph</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">cloned_adjList1</span> <span class="o">=</span> <span class="n">get_adjacency_list</span><span class="p">(</span><span class="n">cloned_node1</span><span class="p">)</span>

<span class="c1"># Print the cloned graph as an adjacency list</span>
<span class="nb">print</span><span class="p">(</span><span class="n">cloned_adjList1</span><span class="p">)</span>

<span class="c1"># Output should match adjList1</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[1, 2, 4]]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 2</span>
<span class="c1"># Input: adjList = [[]]</span>

<span class="n">adjList2</span> <span class="o">=</span> <span class="p">[[]]</span>
<span class="n">solution</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">()</span>

<span class="c1"># Create the graph from adjList</span>
<span class="n">node1</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Clone the graph and get its adjacency list</span>
<span class="n">cloned_node1</span> <span class="o">=</span> <span class="n">solution</span><span class="o">.</span><span class="n">cloneGraph</span><span class="p">(</span><span class="n">node1</span><span class="p">)</span>
<span class="n">cloned_adjList2</span> <span class="o">=</span> <span class="n">get_adjacency_list</span><span class="p">(</span><span class="n">cloned_node1</span><span class="p">)</span>

<span class="c1"># Print the cloned graph as an adjacency list</span>
<span class="nb">print</span><span class="p">(</span><span class="n">cloned_adjList2</span><span class="p">)</span>

<span class="c1"># Output should be [[]], which represents an empty graph</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[1]]
</pre></div>
</div>
</div>
</div>
</section>
<section id="time-and-space-complexity-analysis">
<h4>Time and Space Complexity Analysis<a class="headerlink" href="#time-and-space-complexity-analysis" title="Permalink to this heading">#</a></h4>
<p>Let’s analyze the time and space complexity of the provided code for cloning a graph using depth-first search (DFS).</p>
<p>Time Complexity:</p>
<ol class="arabic simple">
<li><p>Creating the graph: The time complexity to create the original graph from <code class="docutils literal notranslate"><span class="pre">adjList</span></code> is O(V + E), where V is the number of vertices (nodes) and E is the number of edges. We iterate through each node and its neighbors in <code class="docutils literal notranslate"><span class="pre">adjList</span></code>.</p></li>
<li><p>Cloning the graph (DFS): The depth-first search (DFS) is used to traverse the original graph and create a clone. The time complexity of DFS is O(V + E), as we visit each node and each edge once.</p></li>
</ol>
<p>Overall, the time complexity is O(V + E) for both creating the original graph and cloning it.</p>
<p>Space Complexity:</p>
<ol class="arabic simple">
<li><p>Storage for the original graph: We need to store the original graph, which includes all nodes and their adjacency lists. In the worst case, this requires O(V + E) space, where V is the number of nodes, and E is the number of edges.</p></li>
<li><p>Storage for the visited dictionary: The <code class="docutils literal notranslate"><span class="pre">visited</span></code> dictionary stores mappings from original nodes to their corresponding clones. In the worst case, this requires O(V) space because each node is visited once.</p></li>
<li><p>Recursive stack for DFS: The space used for the recursive call stack during DFS can be up to O(V) in the worst case, where V is the number of nodes.</p></li>
</ol>
<p>Overall, the space complexity is O(V + E) for storing the original graph, and O(V) for auxiliary data structures, including the <code class="docutils literal notranslate"><span class="pre">visited</span></code> dictionary and the DFS call stack. Therefore, the overall space complexity is O(V + E).</p>
<p>In summary, the time and space complexities of the provided code for cloning a graph are both O(V + E), where V is the number of nodes, and E is the number of edges in the graph.</p>
</section>
<section id="challenging-exercises">
<h4>Challenging Exercises:<a class="headerlink" href="#challenging-exercises" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p><strong>Cyclic Graph</strong>: Design a graph with cycles (nodes connected in a cycle). Test if the code can correctly clone graphs with cycles and doesn’t fall into an infinite loop during traversal.</p></li>
<li><p><strong>Partial Graph Cloning</strong>: Modify the code to clone only a subset of the graph starting from a given reference node, rather than the entire graph. Implement this as an extension to the problem.</p></li>
</ol>
</section>
</section>
<span id="document-11. Graphs/178. Graph Valid Tree"></span><section class="tex2jax_ignore mathjax_ignore" id="graph-valid-tree">
<h3>178. Graph Valid Tree<a class="headerlink" href="#graph-valid-tree" title="Permalink to this heading">#</a></h3>
<p><strong>Difficulty:</strong> Medium</p>
<p><strong>Link to Problem:</strong> <a class="reference external" href="https://www.lintcode.com/problem/178/">To see the Graph Valid Tree problem on LintCode, click here!</a></p>
<hr class="docutils" />
<p>Given <code class="docutils literal notranslate"><span class="pre">n</span></code> nodes labeled from <code class="docutils literal notranslate"><span class="pre">0</span></code> to <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">-</span> <span class="pre">1</span></code> and a list of <code class="docutils literal notranslate"><span class="pre">undirected</span></code> edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.</p>
<p><strong>Constraints:</strong></p>
<ul class="simple">
<li><p>You can assume that no duplicate edges will appear in edges. Since all edges are <code class="docutils literal notranslate"><span class="pre">undirected</span></code>, <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">1]</span></code> is the same as <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">0]</span></code> and thus will not appear together in edges.</p></li>
</ul>
<section id="probelm-explanation">
<h4>Probelm Explanation:<a class="headerlink" href="#probelm-explanation" title="Permalink to this heading">#</a></h4>
<p>The problem is to determine whether a given set of undirected edges can form a valid tree. In this context, a “tree” is a specific type of graph with the following properties:</p>
<ol class="arabic simple">
<li><p>It is a connected graph, meaning there is a path between any pair of nodes in the graph.</p></li>
<li><p>It has no cycles, which means there are no closed loops or circuits in the graph.</p></li>
<li><p>It has exactly <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">-</span> <span class="pre">1</span></code> edges, where <code class="docutils literal notranslate"><span class="pre">n</span></code> is the number of nodes in the tree.</p></li>
</ol>
<p>The problem is typically given with two pieces of information:</p>
<ol class="arabic simple">
<li><p>The number of nodes (<code class="docutils literal notranslate"><span class="pre">n</span></code>), which are usually labeled from 0 to <code class="docutils literal notranslate"><span class="pre">n-1</span></code>.</p></li>
<li><p>A list of undirected edges, where each edge is represented as a pair of nodes.</p></li>
</ol>
<p>The task is to write a function or algorithm to determine whether the provided set of edges can be arranged to form a valid tree based on the properties mentioned above.</p>
<p>To solve this problem, you need to check the following conditions:</p>
<ol class="arabic simple">
<li><p>There should be exactly <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">-</span> <span class="pre">1</span></code> edges to ensure that the graph is connected and tree-like.</p></li>
<li><p>There should be no cycles in the graph. If there are any cycles, the set of edges cannot form a tree.</p></li>
<li><p>The graph should be connected, which means you can reach any node from any other node through a series of edges.</p></li>
</ol>
<p>The solution typically involves using graph traversal algorithms like Depth-First Search (DFS) or Breadth-First Search (BFS) to explore the graph and check these conditions. If all conditions are met, the given edges form a valid tree; otherwise, they do not.</p>
</section>
<section id="solution">
<h4>Solution:<a class="headerlink" href="#solution" title="Permalink to this heading">#</a></h4>
<p>Here’s a Python function to implement this algorithm:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">validTree</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">edges</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>  <span class="c1"># A tree with n nodes must have n-1 edges.</span>

    <span class="c1"># Create an adjacency list to represent the graph.</span>
    <span class="n">adj_list</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)}</span>
    <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
        <span class="n">adj_list</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="n">adj_list</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

    <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="c1"># Define a recursive DFS function.</span>
    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>  <span class="c1"># If we encounter a visited node, there&#39;s a cycle.</span>
        <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">adj_list</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">neighbor</span> <span class="o">!=</span> <span class="n">parent</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">dfs</span><span class="p">(</span><span class="n">neighbor</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="kc">True</span>

    <span class="c1"># Start DFS from any node (e.g., node 0).</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>  <span class="c1"># If there&#39;s a cycle, it&#39;s not a valid tree.</span>

    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">visited</span><span class="p">)</span> <span class="o">==</span> <span class="n">n</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="explanation">
<h4>Explanation:<a class="headerlink" href="#explanation" title="Permalink to this heading">#</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">validTree</span></code> function checks if a given set of undirected edges forms a valid tree. A valid tree must satisfy these conditions:</p>
<ol class="arabic simple">
<li><p>It has exactly <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">-</span> <span class="pre">1</span></code> edges, where <code class="docutils literal notranslate"><span class="pre">n</span></code> is the number of nodes.</p></li>
<li><p>There are no cycles in the graph.</p></li>
<li><p>The graph is connected, meaning all nodes are reachable from any starting node.</p></li>
</ol>
<p>The code accomplishes this as follows:</p>
<ul class="simple">
<li><p>It first checks if the number of edges is equal to <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">-</span> <span class="pre">1</span></code>. If not, it immediately returns <code class="docutils literal notranslate"><span class="pre">False</span></code> since a tree with <code class="docutils literal notranslate"><span class="pre">n</span></code> nodes must have <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">-</span> <span class="pre">1</span></code> edges to be connected.</p></li>
<li><p>It then constructs an adjacency list (<code class="docutils literal notranslate"><span class="pre">adj_list</span></code>) to represent the graph efficiently. This data structure stores the neighbors of each node.</p></li>
<li><p>The code uses a <code class="docutils literal notranslate"><span class="pre">visited</span></code> set to keep track of nodes visited during depth-first search (DFS).</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">dfs</span></code> function is a recursive function that checks for cycles in the graph. It does this by visiting nodes and marking them as visited. If it encounters a node that has already been visited (indicating a cycle), it returns <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
<li><p>The DFS function explores the neighbors of each node, avoiding revisiting the parent node to prevent cycles.</p></li>
<li><p>After the DFS is complete, the code checks if the number of visited nodes is equal to <code class="docutils literal notranslate"><span class="pre">n</span></code>, ensuring the graph is connected.</p></li>
<li><p>Finally, if all conditions are met, the code returns <code class="docutils literal notranslate"><span class="pre">True</span></code>, indicating that the given edges form a valid tree. Otherwise, it returns <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
</ul>
<p>The code provides examples to demonstrate how to use the <code class="docutils literal notranslate"><span class="pre">validTree</span></code> function to check whether a set of edges forms a valid tree or not.</p>
</section>
<section id="test-cases">
<h4>Test cases:<a class="headerlink" href="#test-cases" title="Permalink to this heading">#</a></h4>
<p>Here’s how you can use this solution:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 1</span>
<span class="n">n1</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">edges1</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">validTree</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">edges1</span><span class="p">))</span>  <span class="c1"># Output: true</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 2</span>
<span class="n">n2</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">edges2</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">validTree</span><span class="p">(</span><span class="n">n2</span><span class="p">,</span> <span class="n">edges2</span><span class="p">))</span>  <span class="c1"># Output: false</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>False
</pre></div>
</div>
</div>
</div>
</section>
<section id="time-and-space-complexity-analysis">
<h4>Time and Space Complexity Analysis<a class="headerlink" href="#time-and-space-complexity-analysis" title="Permalink to this heading">#</a></h4>
<p>Let’s analyze the time and space complexities of the <code class="docutils literal notranslate"><span class="pre">validTree</span></code> function:</p>
<p><strong>Time Complexity:</strong></p>
<ol class="arabic simple">
<li><p>Constructing the adjacency list (<code class="docutils literal notranslate"><span class="pre">adj_list</span></code>) takes O(E) time, where E is the number of edges in the input graph (|edges|).</p></li>
<li><p>The DFS function, when considering all nodes, has a time complexity of O(V + E), where V is the number of nodes in the graph. This is because, in the worst case, the DFS function visits each node and each edge once.</p></li>
<li><p>Checking if the number of visited nodes is equal to <code class="docutils literal notranslate"><span class="pre">n</span></code> takes O(1) time.</p></li>
</ol>
<p>Overall, the time complexity of the <code class="docutils literal notranslate"><span class="pre">validTree</span></code> function is O(E + V) in the worst case.</p>
<p><strong>Space Complexity:</strong></p>
<ol class="arabic simple">
<li><p>The adjacency list (<code class="docutils literal notranslate"><span class="pre">adj_list</span></code>) consumes additional space to store the graph structure, taking O(V + E) space. This is because it stores information about each node and its adjacent nodes.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">visited</span></code> set keeps track of visited nodes, and its space complexity is O(V) in the worst case, as there can be at most V unique nodes in the set.</p></li>
<li><p>The depth of the function call stack during DFS can be at most V, which contributes O(V) space to the space complexity.</p></li>
</ol>
<p>Overall, the space complexity of the <code class="docutils literal notranslate"><span class="pre">validTree</span></code> function is O(V + E) due to the adjacency list and O(V) due to the <code class="docutils literal notranslate"><span class="pre">visited</span></code> set and DFS call stack.</p>
<p>In summary, the time complexity is O(E + V), and the space complexity is O(V + E). These complexities are based on the worst-case scenario, where all nodes and edges are considered. In practical cases, the actual complexities may be smaller, depending on the specific structure of the graph.</p>
</section>
<section id="challenging-exercises">
<h4>Challenging Exercises:<a class="headerlink" href="#challenging-exercises" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p><strong>Minimum Spanning Tree (MST)</strong>: Implement an algorithm to find the minimum spanning tree of a connected graph using either Kruskal’s or Prim’s algorithm. Compare the MST to the original graph to determine if the original graph is a tree. This exercise reinforces the concept of tree properties.</p></li>
<li><p><strong>Detecting Cycles</strong>: Modify the code to not only check if the input forms a tree but also to identify and print out any cycles present in the graph if it’s not a tree. This exercise enhances your ability to detect and visualize cycles in a graph.</p></li>
</ol>
</section>
</section>
<span id="document-11. Graphs/200. Number of Islands"></span><section class="tex2jax_ignore mathjax_ignore" id="number-of-islands">
<h3>200. Number of Islands<a class="headerlink" href="#number-of-islands" title="Permalink to this heading">#</a></h3>
<p><strong>Difficulty:</strong> Medium</p>
<p><strong>Link to Problem:</strong> <a class="reference external" href="https://leetcode.com/problems/number-of-islands/">To see the Number of Islands problem on LeetCode, click here!</a></p>
<hr class="docutils" />
<p>Given an <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">x</span> <span class="pre">n</span></code> 2D binary grid <code class="docutils literal notranslate"><span class="pre">grid</span></code> which represents a map of <code class="docutils literal notranslate"><span class="pre">'1'</span></code>s (land) and <code class="docutils literal notranslate"><span class="pre">'0'</span></code>s (water), return <em>the number of islands</em>.</p>
<p>An <strong>island</strong> is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>
<p><strong>Constraints:</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">==</span> <span class="pre">grid.length</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">==</span> <span class="pre">grid[i].length</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">&lt;=</span> <span class="pre">m,</span> <span class="pre">n</span> <span class="pre">&lt;=</span> <span class="pre">300</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">grid[i][j]</span></code> is <code class="docutils literal notranslate"><span class="pre">'0'</span></code> or <code class="docutils literal notranslate"><span class="pre">'1'</span></code>.</p></li>
</ul>
<section id="probelm-explanation">
<h4>Probelm Explanation:<a class="headerlink" href="#probelm-explanation" title="Permalink to this heading">#</a></h4>
<p>The problem is about counting the number of islands in a 2D binary grid. In this grid, ‘1’ represents land, and ‘0’ represents water. An island is defined as a group of ‘1’ cells that are adjacent to each other either horizontally or vertically. It’s important to note that diagonal connections do not count. Additionally, it’s assumed that all four edges of the grid are surrounded by water, meaning the grid is finite and doesn’t “wrap around.”</p>
<p>The objective is to determine how many distinct islands exist in the grid. To clarify, an island consists of connected ‘1’ cells, and these connections can only occur horizontally or vertically. If there are no ‘1’ cells in the grid, the number of islands would be zero.</p>
<p>The problem often involves using graph traversal techniques like Depth-First Search (DFS) or Breadth-First Search (BFS) to identify and count these islands. You start at one ‘1’ cell and explore its adjacent cells to determine the extent of the island. Once you’ve visited all the ‘1’ cells in an island, you move on to the next unvisited ‘1’ cell and repeat the process until you’ve counted all the islands in the grid.</p>
<p>In essence, the problem asks you to analyze the grid to find groups of connected ‘1’ cells and count them as individual islands. The goal is to return the total count of islands in the given grid.</p>
</section>
<section id="solution">
<h4>Solution:<a class="headerlink" href="#solution" title="Permalink to this heading">#</a></h4>
<p>Here’s a Python function to implement this algorithm:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">numIslands</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">grid</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># Get the dimensions of the grid</span>
        <span class="n">num_islands</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Initialize the count of islands</span>

        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">row</span> <span class="o">&gt;=</span> <span class="n">m</span> <span class="ow">or</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">col</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="ow">or</span> <span class="n">grid</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;0&#39;</span><span class="p">:</span>
                <span class="k">return</span>

            <span class="n">grid</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span>  <span class="c1"># Mark the current cell as visited by changing it to &#39;0&#39;</span>
            <span class="n">directions</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span>  <span class="c1"># Define four possible directions to move</span>

            <span class="k">for</span> <span class="n">dr</span><span class="p">,</span> <span class="n">dc</span> <span class="ow">in</span> <span class="n">directions</span><span class="p">:</span>
                <span class="c1"># Explore adjacent cells</span>
                <span class="n">dfs</span><span class="p">(</span><span class="n">row</span> <span class="o">+</span> <span class="n">dr</span><span class="p">,</span> <span class="n">col</span> <span class="o">+</span> <span class="n">dc</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;1&#39;</span><span class="p">:</span>
                    <span class="n">num_islands</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># Increment the island count</span>
                    <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>  <span class="c1"># Start a DFS from the current &#39;1&#39; cell to explore the entire island</span>

        <span class="k">return</span> <span class="n">num_islands</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="explanation">
<h4>Explanation:<a class="headerlink" href="#explanation" title="Permalink to this heading">#</a></h4>
<p>The provided code defines a Python class called <code class="docutils literal notranslate"><span class="pre">Solution</span></code> with a method called <code class="docutils literal notranslate"><span class="pre">numIslands</span></code>. This class is designed to count the number of islands in a 2D binary grid.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">numIslands</span></code> method takes a 2D grid as input, where ‘1’ represents land, and ‘0’ represents water. It uses a depth-first search (DFS) approach to identify and count islands. The key steps in the code include:</p>
<ol class="arabic simple">
<li><p>Checking if the input grid is empty, and if so, returning 0 (indicating there are no islands).</p></li>
<li><p>Determining the dimensions of the grid (number of rows and columns).</p></li>
<li><p>Initializing a variable <code class="docutils literal notranslate"><span class="pre">num_islands</span></code> to keep track of the count of islands.</p></li>
<li><p>Defining a nested function <code class="docutils literal notranslate"><span class="pre">dfs</span></code> to perform depth-first search. This function recursively explores adjacent land cells connected to the current cell and marks them as visited by changing ‘1’ to ‘0’.</p></li>
<li><p>In the <code class="docutils literal notranslate"><span class="pre">dfs</span></code> function, it checks for boundary conditions and whether the current cell is ‘0’. If these conditions are met, it returns without further exploration.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">dfs</span></code> function explores neighboring cells in all four directions (up, down, left, right) using a loop.</p></li>
<li><p>The main loop iterates through each cell of the grid. When a ‘1’ cell is encountered, it increments the <code class="docutils literal notranslate"><span class="pre">num_islands</span></code> count and starts a DFS from that cell to explore the entire island.</p></li>
<li><p>Finally, the method returns the total count of islands found in the grid.</p></li>
</ol>
<p>This code encapsulates the solution in a class, allowing you to create an instance of the <code class="docutils literal notranslate"><span class="pre">Solution</span></code> class and call the <code class="docutils literal notranslate"><span class="pre">numIslands</span></code> method on it to count the number of islands in a given grid.</p>
</section>
<section id="test-cases">
<h4>Test cases:<a class="headerlink" href="#test-cases" title="Permalink to this heading">#</a></h4>
<p>Here’s how you can use this solution:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">grid1</span> <span class="o">=</span> <span class="p">[</span>
  <span class="p">[</span><span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">],</span>
  <span class="p">[</span><span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">],</span>
  <span class="p">[</span><span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">],</span>
  <span class="p">[</span><span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">]</span>
<span class="p">]</span>

<span class="n">solution</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">()</span>
<span class="n">result1</span> <span class="o">=</span> <span class="n">solution</span><span class="o">.</span><span class="n">numIslands</span><span class="p">(</span><span class="n">grid1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Example 1 Output:&quot;</span><span class="p">,</span> <span class="n">result1</span><span class="p">)</span>  <span class="c1"># Expected output: 1</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Example 1 Output: 1
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">grid2</span> <span class="o">=</span> <span class="p">[</span>
  <span class="p">[</span><span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">],</span>
  <span class="p">[</span><span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">],</span>
  <span class="p">[</span><span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">],</span>
  <span class="p">[</span><span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">]</span>
<span class="p">]</span>

<span class="n">result2</span> <span class="o">=</span> <span class="n">solution</span><span class="o">.</span><span class="n">numIslands</span><span class="p">(</span><span class="n">grid2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Example 2 Output:&quot;</span><span class="p">,</span> <span class="n">result2</span><span class="p">)</span>  <span class="c1"># Expected output: 3</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Example 2 Output: 3
</pre></div>
</div>
</div>
</div>
</section>
<section id="time-and-space-complexity-analysis">
<h4>Time and Space Complexity Analysis<a class="headerlink" href="#time-and-space-complexity-analysis" title="Permalink to this heading">#</a></h4>
<p>Let’s analyze the time and space complexity of the provided code:</p>
<p>Time Complexity:</p>
<ul class="simple">
<li><p>The code uses a depth-first search (DFS) to explore the grid and count the number of islands.</p></li>
<li><p>In the worst case, it visits every cell in the grid exactly once.</p></li>
<li><p>The DFS function explores neighboring cells in four directions (up, down, left, right), so it has a time complexity of <span class="math notranslate nohighlight">\(O(4^{max(m, n)})\)</span>, where m is the number of rows and n is the number of columns.</p></li>
<li><p>Therefore, the overall time complexity of the code is O(m * n), where m is the number of rows, and n is the number of columns.</p></li>
</ul>
<p>Space Complexity:</p>
<ul class="simple">
<li><p>The space complexity is determined by the recursive calls and the depth of the DFS stack.</p></li>
<li><p>In the worst case, when the entire grid consists of ‘1’s, the depth of the DFS recursion can be as deep as max(m, n).</p></li>
<li><p>Therefore, the space complexity of the code is O(max(m, n)), representing the maximum depth of the DFS stack.</p></li>
</ul>
<p>In practical terms, for reasonably sized grids, the time and space complexity is linear, and the code should perform well. However, it’s important to keep in mind that the worst-case time complexity is O(m * n), and the space complexity can be O(max(m, n)).</p>
</section>
<section id="challenging-exercises">
<h4>Challenging Exercises:<a class="headerlink" href="#challenging-exercises" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p><strong>Identify Largest Island:</strong> In addition to counting the number of islands, modify the code to identify the largest island in the grid and return its size.</p></li>
<li><p><strong>Optimize for Space:</strong> Modify the solution to reduce its space complexity to O(1) without modifying the input grid. This is a more memory-efficient version of the problem.</p></li>
</ol>
</section>
</section>
<span id="document-11. Graphs/207. Course Schedule"></span><section class="tex2jax_ignore mathjax_ignore" id="course-schedule">
<h3>207. Course Schedule<a class="headerlink" href="#course-schedule" title="Permalink to this heading">#</a></h3>
<p><strong>Difficulty:</strong> Medium</p>
<p><strong>Link to Problem:</strong> <a class="reference external" href="https://leetcode.com/problems/course-schedule/">To see the Course Schedule problem on LeetCode, click here!</a></p>
<hr class="docutils" />
<p>There are a total of <code class="docutils literal notranslate"><span class="pre">numCourses</span></code> courses to take, labeled from 0 to <code class="docutils literal notranslate"><span class="pre">numCourses</span> <span class="pre">-</span> <span class="pre">1</span></code>. You are given an array <code class="docutils literal notranslate"><span class="pre">prerequisites</span></code> where <code class="docutils literal notranslate"><span class="pre">prerequisites[i]</span> <span class="pre">=</span> <span class="pre">[ai,</span> <span class="pre">bi]</span></code> indicates that you <strong>must</strong> take course <code class="docutils literal notranslate"><span class="pre">bi</span></code> first if you want to take course <code class="docutils literal notranslate"><span class="pre">ai</span></code>.</p>
<ul class="simple">
<li><p>For example, the pair <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">1]</span></code>, indicates that to take course <code class="docutils literal notranslate"><span class="pre">0</span></code> you have to first take course <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p></li>
</ul>
<p>Return <code class="docutils literal notranslate"><span class="pre">true</span></code> if you can finish all courses. Otherwise, return <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
<p><strong>Constraints:</strong></p>
<ul class="simple">
<li><p>1 &lt;= <code class="docutils literal notranslate"><span class="pre">numCourses</span></code> &lt;= 2000</p></li>
<li><p>0 &lt;= <code class="docutils literal notranslate"><span class="pre">prerequisites.length</span></code> &lt;= 5000</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">prerequisites[i].length</span></code> == 2</p></li>
<li><p>0 &lt;= <code class="docutils literal notranslate"><span class="pre">ai</span></code>, <code class="docutils literal notranslate"><span class="pre">bi</span></code> &lt; <code class="docutils literal notranslate"><span class="pre">numCourses</span></code></p></li>
<li><p>All the pairs <code class="docutils literal notranslate"><span class="pre">prerequisites[i]</span></code> are <strong>unique</strong>.</p></li>
</ul>
<section id="probelm-explanation">
<h4>Probelm Explanation:<a class="headerlink" href="#probelm-explanation" title="Permalink to this heading">#</a></h4>
<p>The problem is to determine whether it’s possible to complete a set of courses given a list of prerequisites. You are given the following:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">numCourses</span></code>: The total number of courses to be taken, labeled from 0 to <code class="docutils literal notranslate"><span class="pre">numCourses</span> <span class="pre">-</span> <span class="pre">1</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">prerequisites</span></code>: A list of prerequisite courses, where each element <code class="docutils literal notranslate"><span class="pre">prerequisites[i]</span></code> is a pair <code class="docutils literal notranslate"><span class="pre">[ai,</span> <span class="pre">bi]</span></code>, indicating that you must take course <code class="docutils literal notranslate"><span class="pre">bi</span></code> before you can take course <code class="docutils literal notranslate"><span class="pre">ai</span></code>.</p></li>
</ul>
<p>The goal is to check whether it’s possible to complete all the courses while respecting the prerequisite requirements. In other words, you need to determine if there are any circular dependencies in the course prerequisites that would prevent you from taking all the courses.</p>
<p>For example:</p>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">numCourses</span></code> is 2, and <code class="docutils literal notranslate"><span class="pre">prerequisites</span></code> is <code class="docutils literal notranslate"><span class="pre">[[1,</span> <span class="pre">0]]</span></code>, it means you have two courses, and you must finish course 0 before you can take course 1. In this case, it’s possible to complete all courses, so the function should return <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">numCourses</span></code> is 2, and <code class="docutils literal notranslate"><span class="pre">prerequisites</span></code> is <code class="docutils literal notranslate"><span class="pre">[[1,</span> <span class="pre">0],</span> <span class="pre">[0,</span> <span class="pre">1]]</span></code>, it means you have two courses, but there’s a circular dependency where course 1 requires course 0 and course 0 requires course 1. In this case, it’s impossible to complete all courses, so the function should return <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
</ul>
<p>The problem is essentially about checking for the presence of cycles in a directed graph, where the courses are nodes, and the prerequisites represent directed edges between them. If there are no cycles, it’s possible to complete all courses; otherwise, it’s not possible.</p>
</section>
<section id="solution">
<h4>Solution:<a class="headerlink" href="#solution" title="Permalink to this heading">#</a></h4>
<p>Here’s a Python function to implement this algorithm:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">deque</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">canFinish</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">numCourses</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">prerequisites</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="c1"># Create a graph using an adjacency list to represent the courses and their prerequisites.</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>  <span class="c1"># Initialize an empty adjacency list.</span>
        <span class="n">in_degree</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">numCourses</span>  <span class="c1"># Initialize an array to store in-degrees of courses.</span>

        <span class="c1"># Populate the graph and calculate in-degrees.</span>
        <span class="k">for</span> <span class="n">course</span><span class="p">,</span> <span class="n">prerequisite</span> <span class="ow">in</span> <span class="n">prerequisites</span><span class="p">:</span>
            <span class="n">graph</span><span class="p">[</span><span class="n">prerequisite</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">course</span><span class="p">)</span>  <span class="c1"># Add the course as a neighbor to its prerequisite.</span>
            <span class="n">in_degree</span><span class="p">[</span><span class="n">course</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># Increment the in-degree of the course.</span>

        <span class="c1"># Initialize a queue with courses that have no prerequisites.</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">course</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numCourses</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">in_degree</span><span class="p">[</span><span class="n">course</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">course</span><span class="p">)</span>

        <span class="c1"># Perform topological sorting.</span>
        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">course</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>  <span class="c1"># Take a course with no prerequisites.</span>
            <span class="n">numCourses</span> <span class="o">-=</span> <span class="mi">1</span>  <span class="c1"># Decrement the count of remaining courses.</span>

            <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">course</span><span class="p">]:</span>
                <span class="n">in_degree</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>  <span class="c1"># Remove the prerequisite relationship.</span>
                <span class="k">if</span> <span class="n">in_degree</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>  <span class="c1"># If no more prerequisites, add to the queue.</span>

        <span class="c1"># If all courses were successfully taken (numCourses becomes 0), return True.</span>
        <span class="k">return</span> <span class="n">numCourses</span> <span class="o">==</span> <span class="mi">0</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="explanation">
<h4>Explanation:<a class="headerlink" href="#explanation" title="Permalink to this heading">#</a></h4>
<p>This Python code is designed to determine whether it is possible to complete all the required courses given a set of prerequisites. It uses a topological sorting algorithm to accomplish this. Here’s a brief explanation of the code:</p>
<ol class="arabic simple">
<li><p>The code defines a <code class="docutils literal notranslate"><span class="pre">Solution</span></code> class with a <code class="docutils literal notranslate"><span class="pre">canFinish</span></code> method that takes two parameters: <code class="docutils literal notranslate"><span class="pre">numCourses</span></code> (the total number of courses) and <code class="docutils literal notranslate"><span class="pre">prerequisites</span></code> (a list of pairs indicating which course must be taken before another).</p></li>
<li><p>It initializes an empty graph as an adjacency list using a <code class="docutils literal notranslate"><span class="pre">defaultdict</span></code> to represent the courses and their prerequisites. It also initializes a list called <code class="docutils literal notranslate"><span class="pre">in_degree</span></code> to keep track of the in-degrees of courses, which is used in the topological sorting process.</p></li>
<li><p>The code then populates the graph by iterating through the <code class="docutils literal notranslate"><span class="pre">prerequisites</span></code> list. For each pair <code class="docutils literal notranslate"><span class="pre">(ai,</span> <span class="pre">bi)</span></code>, it adds course <code class="docutils literal notranslate"><span class="pre">ai</span></code> as a neighbor to its prerequisite course <code class="docutils literal notranslate"><span class="pre">bi</span></code> in the graph and increments the in-degree of course <code class="docutils literal notranslate"><span class="pre">ai</span></code>.</p></li>
<li><p>Next, it initializes a queue with courses that have no prerequisites. It does this by iterating through all the courses and adding those with an in-degree of 0 to the queue.</p></li>
<li><p>The code performs a topological sorting of the courses using a while loop. In each iteration of the loop, it dequeues a course from the front of the queue (a course with no prerequisites).</p></li>
<li><p>For each neighbor (course that depends on the dequeued course), it decrements the in-degree of the neighbor. If the neighbor’s in-degree becomes 0, it means all of its prerequisites have been taken, so the neighbor is added to the queue.</p></li>
<li><p>The loop continues until there are no more courses with no prerequisites to dequeue, and the in-degrees are updated accordingly.</p></li>
<li><p>After the loop, if all courses were successfully taken (i.e., <code class="docutils literal notranslate"><span class="pre">numCourses</span></code> becomes 0), it means that there were no circular dependencies, and it’s possible to finish all courses. In this case, the method returns <code class="docutils literal notranslate"><span class="pre">True</span></code>. Otherwise, if there are remaining courses (indicating a circular dependency), it returns <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
</ol>
</section>
<section id="test-cases">
<h4>Test cases:<a class="headerlink" href="#test-cases" title="Permalink to this heading">#</a></h4>
<p>Here’s how you can use this solution:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 1</span>
<span class="n">numCourses1</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">prerequisites1</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="n">sol</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">canFinish</span><span class="p">(</span><span class="n">numCourses1</span><span class="p">,</span> <span class="n">prerequisites1</span><span class="p">))</span>  <span class="c1"># Output: True</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 2</span>
<span class="n">numCourses2</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">prerequisites2</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">canFinish</span><span class="p">(</span><span class="n">numCourses2</span><span class="p">,</span> <span class="n">prerequisites2</span><span class="p">))</span>  <span class="c1"># Output: False</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>False
</pre></div>
</div>
</div>
</div>
</section>
<section id="time-and-space-complexity-analysis">
<h4>Time and Space Complexity Analysis<a class="headerlink" href="#time-and-space-complexity-analysis" title="Permalink to this heading">#</a></h4>
<p>Let’s analyze the time and space complexity of the <code class="docutils literal notranslate"><span class="pre">canFinish</span></code> method:</p>
<p><strong>Time Complexity:</strong></p>
<ol class="arabic simple">
<li><p>Constructing the graph: In the first loop where we iterate through the <code class="docutils literal notranslate"><span class="pre">prerequisites</span></code> list, we populate the graph with prerequisites. This loop has a time complexity of O(E), where E is the number of prerequisites (edges).</p></li>
<li><p>Initializing in-degrees and finding courses with no prerequisites: In the worst case, we iterate through all <code class="docutils literal notranslate"><span class="pre">numCourses</span></code> courses to initialize in-degrees and find the courses with no prerequisites. This has a time complexity of O(V), where V is the number of courses (vertices).</p></li>
<li><p>Topological Sorting: In the while loop, we perform topological sorting, processing each course once and its outgoing edges. In the worst case, each course is processed once. This has a time complexity of O(V + E).</p></li>
</ol>
<p>The overall time complexity is O(V + E), where V is the number of courses, and E is the number of prerequisites.</p>
<p><strong>Space Complexity:</strong></p>
<ol class="arabic simple">
<li><p>Graph Representation: The space complexity for storing the graph as an adjacency list is O(E), where E is the number of prerequisites.</p></li>
<li><p>In-Degree Array: The space complexity for storing the in-degrees of courses is O(V), where V is the number of courses.</p></li>
<li><p>Queue: The space complexity for the queue is O(V), as it may contain all the courses.</p></li>
</ol>
<p>The overall space complexity is O(V + E), where V is the number of courses, and E is the number of prerequisites.</p>
<p>In most practical cases, the number of prerequisites (E) is much smaller than the number of courses (V), so the time and space complexity can often be considered as O(V).</p>
</section>
<section id="challenging-exercises">
<h4>Challenging Exercises:<a class="headerlink" href="#challenging-exercises" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p><strong>Optimizing Course Scheduling</strong>: Given a list of courses with their durations and prerequisites, find the most efficient way to schedule these courses to minimize the time it takes to complete all of them.</p></li>
<li><p><strong>Detecting Cycles in Course Dependencies</strong>: Modify the original problem to not just determine if you can finish all courses but also to identify the specific courses that form a cycle in the prerequisite dependencies.</p></li>
</ol>
</section>
</section>
<span id="document-11. Graphs/3651. Number of Connected Components in an Undirected Graph"></span><section class="tex2jax_ignore mathjax_ignore" id="number-of-connected-components-in-an-undirected-graph">
<h3>3651. Number of Connected Components in an Undirected Graph<a class="headerlink" href="#number-of-connected-components-in-an-undirected-graph" title="Permalink to this heading">#</a></h3>
<p><strong>Difficulty:</strong> Medium</p>
<p><strong>Link to Problem:</strong> <a class="reference external" href="https://www.lintcode.com/problem/3651/">To see the Number of Connected Components in an Undirected Graph problem on LintCode, click here!</a></p>
<hr class="docutils" />
<p>In this problem, there is an undirected graph with <code class="docutils literal notranslate"><span class="pre">n</span></code> nodes. There is also an <code class="docutils literal notranslate"><span class="pre">edges</span></code> array. Where <code class="docutils literal notranslate"><span class="pre">edges[i]</span> <span class="pre">=</span> <span class="pre">[a,</span> <span class="pre">b]</span></code> means that there is an edge between <em>node a</em> and <em>node b</em> in the graph.</p>
<p>You need to return <em>the number of connected components in that graph</em>.</p>
<section id="probelm-explanation">
<h4>Probelm Explanation:<a class="headerlink" href="#probelm-explanation" title="Permalink to this heading">#</a></h4>
<p>The problem at hand is to determine the number of connected components in an undirected graph. Here’s a more detailed explanation of the problem:</p>
<ul class="simple">
<li><p>You are given an undirected graph, which consists of nodes and edges. The graph may have multiple distinct connected components.</p></li>
<li><p>A connected component is a group of nodes within the graph where each node can be reached from every other node in the same component. In other words, there is a path between any two nodes in the same connected component, but there are no paths connecting nodes from different components.</p></li>
<li><p>Your task is to write a function that takes as input the number of nodes <code class="docutils literal notranslate"><span class="pre">n</span></code> and a list of edges <code class="docutils literal notranslate"><span class="pre">edges</span></code>, where each edge is represented as a pair of nodes <code class="docutils literal notranslate"><span class="pre">[a,</span> <span class="pre">b]</span></code> indicating an edge between node <code class="docutils literal notranslate"><span class="pre">a</span></code> and node <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p></li>
<li><p>The goal is to determine the number of distinct connected components in the graph.</p></li>
<li><p>You need to implement an algorithm that can identify these connected components and count how many there are in the given graph.</p></li>
</ul>
</section>
<section id="solution">
<h4>Solution:<a class="headerlink" href="#solution" title="Permalink to this heading">#</a></h4>
<p>Here’s a Python function to implement this algorithm:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">countConnectedComponents</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">edges</span><span class="p">):</span>
    <span class="c1"># Define a helper function for depth-first search (DFS).</span>
    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>  <span class="c1"># If the node has not been visited yet:</span>
            <span class="n">visited</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># Mark it as visited.</span>
            <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>  <span class="c1"># Explore all neighbors of the current node.</span>
                <span class="n">dfs</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>  <span class="c1"># Recursively call DFS on the neighbor.</span>

    <span class="c1"># Create an empty adjacency list to represent the graph.</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>

    <span class="c1"># Initialize a boolean list to keep track of visited nodes.</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>

    <span class="c1"># Populate the adjacency list with edges from the input.</span>
    <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
        <span class="n">graph</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="n">graph</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  <span class="c1"># Since the graph is undirected, we add edges in both directions.</span>

    <span class="c1"># Initialize a counter to keep track of the number of connected components.</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Iterate through all nodes in the graph.</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>  <span class="c1"># If the node has not been visited:</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># Increment the count since we&#39;ve found a new connected component.</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>  <span class="c1"># Start a depth-first search from the unvisited node to explore the component.</span>

    <span class="k">return</span> <span class="n">count</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="explanation">
<h4>Explanation:<a class="headerlink" href="#explanation" title="Permalink to this heading">#</a></h4>
<p>The provided Python code calculates the number of connected components in an undirected graph. Here’s a high-level explanation of how the code works:</p>
<ol class="arabic simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">countConnectedComponents</span></code> function takes two arguments: <code class="docutils literal notranslate"><span class="pre">n</span></code> (the number of nodes in the graph) and <code class="docutils literal notranslate"><span class="pre">edges</span></code> (a list of edge pairs representing connections between nodes).</p></li>
<li><p>Inside the function, there is a helper function called <code class="docutils literal notranslate"><span class="pre">dfs</span></code> (depth-first search), which is used to explore and mark nodes as visited.</p></li>
<li><p>An empty adjacency list called <code class="docutils literal notranslate"><span class="pre">graph</span></code> is created to represent the graph. The <code class="docutils literal notranslate"><span class="pre">graph</span></code> is a list of lists where each element represents a node, and the list associated with each node contains its neighboring nodes.</p></li>
<li><p>Another list called <code class="docutils literal notranslate"><span class="pre">visited</span></code> is created to keep track of visited nodes. Initially, all nodes are marked as not visited (<code class="docutils literal notranslate"><span class="pre">False</span></code>).</p></li>
<li><p>The code populates the <code class="docutils literal notranslate"><span class="pre">graph</span></code> by iterating through the <code class="docutils literal notranslate"><span class="pre">edges</span></code> list and adding each edge to the adjacency list. Since the graph is undirected, both directions of each edge are added.</p></li>
<li><p>A counter variable called <code class="docutils literal notranslate"><span class="pre">count</span></code> is initialized to keep track of the number of connected components.</p></li>
<li><p>The code iterates through all nodes from <code class="docutils literal notranslate"><span class="pre">0</span></code> to <code class="docutils literal notranslate"><span class="pre">n-1</span></code>. For each node, it checks whether it has been visited yet. If it hasn’t been visited, it means a new connected component is found. The counter <code class="docutils literal notranslate"><span class="pre">count</span></code> is incremented, and a depth-first search (DFS) is initiated from this unvisited node to explore the connected component.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">dfs</span></code> function recursively visits all nodes in the connected component, marking them as visited. It does this by checking each neighbor of the current node and recursively calling <code class="docutils literal notranslate"><span class="pre">dfs</span></code> on unvisited neighbors.</p></li>
<li><p>After the loop through all nodes, the <code class="docutils literal notranslate"><span class="pre">count</span></code> variable contains the total number of connected components in the graph.</p></li>
<li><p>The function returns the value of <code class="docutils literal notranslate"><span class="pre">count</span></code>, which represents the number of connected components.</p></li>
<li><p>Two examples are provided at the end to demonstrate how to use the function with different inputs.</p></li>
</ol>
</section>
<section id="test-cases">
<h4>Test cases:<a class="headerlink" href="#test-cases" title="Permalink to this heading">#</a></h4>
<p>Here’s how you can use this solution:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 1</span>
<span class="n">n1</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">edges1</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">countConnectedComponents</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">edges1</span><span class="p">))</span>  <span class="c1"># Output: 1</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 2</span>
<span class="n">n2</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">edges2</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">countConnectedComponents</span><span class="p">(</span><span class="n">n2</span><span class="p">,</span> <span class="n">edges2</span><span class="p">))</span>  <span class="c1"># Output: 2</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2
</pre></div>
</div>
</div>
</div>
</section>
<section id="time-and-space-complexity-analysis">
<h4>Time and Space Complexity Analysis<a class="headerlink" href="#time-and-space-complexity-analysis" title="Permalink to this heading">#</a></h4>
<p>Let’s analyze the time and space complexity of the code for counting the number of connected components in an undirected graph using depth-first search (DFS).</p>
<p><strong>Time Complexity:</strong></p>
<ul class="simple">
<li><p>The code iterates through all nodes in the graph (from 0 to <code class="docutils literal notranslate"><span class="pre">n-1</span></code>).</p></li>
<li><p>For each unvisited node, it initiates a depth-first search (DFS) from that node to explore the connected component.</p></li>
<li><p>In the worst case, every node may belong to a separate connected component, and you perform a DFS for each node.</p></li>
<li><p>The time complexity of the DFS for a single connected component is O(V + E), where V is the number of nodes in the component, and E is the number of edges.</p></li>
<li><p>In the worst case, you perform O(n) DFS calls, each with its own O(V + E) complexity.</p></li>
</ul>
<p>So, the overall time complexity of the code is O(n * (V + E)). In the worst case, if the graph is connected (a single connected component), this simplifies to O(n * (n + m)), where m is the number of edges.</p>
<p><strong>Space Complexity:</strong></p>
<ul class="simple">
<li><p>The main data structures used are the <code class="docutils literal notranslate"><span class="pre">graph</span></code> (adjacency list), <code class="docutils literal notranslate"><span class="pre">visited</span></code> (boolean array), and the recursive call stack for DFS.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">graph</span></code> has a space complexity of O(n + m), where n is the number of nodes, and m is the number of edges.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">visited</span></code> boolean array also has a space complexity of O(n) to keep track of whether nodes have been visited.</p></li>
<li><p>The depth of the recursive call stack for DFS can go up to O(n) in the worst case, when all nodes are part of a single connected component.</p></li>
</ul>
<p>So, the overall space complexity of the code is O(n + m) for data structures and O(n) for the call stack. In the worst case, this simplifies to O(n + m).</p>
<p>In summary, the time complexity is O(n * (V + E)), and the space complexity is O(n + m).</p>
</section>
<section id="challenging-exercises">
<h4>Challenging Exercises:<a class="headerlink" href="#challenging-exercises" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p><strong>Disconnected Components with Multiple Queries:</strong> You are given an undirected graph with <code class="docutils literal notranslate"><span class="pre">n</span></code> nodes and <code class="docutils literal notranslate"><span class="pre">m</span></code> edges. Initially, the graph is disconnected, and you need to process <code class="docutils literal notranslate"><span class="pre">q</span></code> queries. Each query consists of adding an edge to connect two nodes. After each query, you need to output the number of connected components in the updated graph.</p></li>
<li><p><strong>Maximum Size of Connected Components:</strong> Given an undirected graph with <code class="docutils literal notranslate"><span class="pre">n</span></code> nodes and <code class="docutils literal notranslate"><span class="pre">m</span></code> edges, find the size of the largest connected component in the graph. Additionally, identify the nodes that belong to this largest component. You can assume there is at least one connected component in the graph.</p></li>
</ol>
</section>
</section>
<span id="document-11. Graphs/417. Pacific Atlantic Water Flow"></span><section class="tex2jax_ignore mathjax_ignore" id="pacific-atlantic-water-flow">
<h3>417. Pacific Atlantic Water Flow<a class="headerlink" href="#pacific-atlantic-water-flow" title="Permalink to this heading">#</a></h3>
<p><strong>Difficulty:</strong> Medium</p>
<p><strong>Link to Problem:</strong> <a class="reference external" href="https://leetcode.com/problems/pacific-atlantic-water-flow/">To see the Pacific Atlantic Water Flow problem on LeetCode, click here!</a></p>
<hr class="docutils" />
<p>There is an <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">x</span> <span class="pre">n</span></code> rectangular island that borders both the <strong>Pacific Ocean</strong> and <strong>Atlantic Ocean</strong>. The <strong>Pacific Ocea</strong>n touches the island’s left and top edges, and the <strong>Atlantic Ocean</strong> touches the island’s right and bottom edges.</p>
<p>The island is partitioned into a grid of square cells. You are given an <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">x</span> <span class="pre">n</span></code> integer matrix <code class="docutils literal notranslate"><span class="pre">heights</span></code> where <code class="docutils literal notranslate"><span class="pre">heights[r][c]</span></code> represents the <strong>height above sea level</strong> of the cell at coordinate <code class="docutils literal notranslate"><span class="pre">(r,</span> <span class="pre">c)</span></code>.</p>
<p>The island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell’s height is <strong>less than or equal to</strong> the current cell’s height. Water can flow from any cell adjacent to an ocean into the ocean.</p>
<p>Return <em>a <strong>2D list</strong> of grid coordinates <code class="docutils literal notranslate"><span class="pre">result</span></code> where <span class="math notranslate nohighlight">\(result[i] = [r_i, c_i]\)</span> denotes that rain water can flow from cell <span class="math notranslate nohighlight">\((r_i, c_i)\)</span> to <strong>both</strong> the Pacific and Atlantic oceans</em>.</p>
<p><strong>Constraints:</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">==</span> <span class="pre">heights.length</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">==</span> <span class="pre">heights[r].length</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">&lt;=</span> <span class="pre">m,</span> <span class="pre">n</span> <span class="pre">&lt;=</span> <span class="pre">200</span></code></p></li>
<li><p>0 &lt;= <code class="docutils literal notranslate"><span class="pre">heights[r][c]</span></code> &lt;= <span class="math notranslate nohighlight">\(10^5\)</span></p></li>
</ul>
<section id="probelm-explanation">
<h4>Probelm Explanation:<a class="headerlink" href="#probelm-explanation" title="Permalink to this heading">#</a></h4>
<p>The problem at hand involves a scenario with a rectangular island surrounded by both the Pacific Ocean and the Atlantic Ocean. The Pacific Ocean is in contact with the island’s left and top edges, while the Atlantic Ocean is in contact with the island’s right and bottom edges. The goal is to determine which cells on the island can allow rainwater to flow to both the Pacific and Atlantic Oceans.</p>
<p>Here are the key details and constraints of the problem:</p>
<ol class="arabic simple">
<li><p>The island is divided into a grid of square cells.</p></li>
<li><p>Each cell is represented by an integer value in a matrix <code class="docutils literal notranslate"><span class="pre">heights</span></code>. The value at <code class="docutils literal notranslate"><span class="pre">heights[r][c]</span></code> represents the height above sea level of the cell at coordinates <code class="docutils literal notranslate"><span class="pre">(r,</span> <span class="pre">c)</span></code> on the island.</p></li>
<li><p>Rainwater can flow from a cell to neighboring cells directly north, south, east, or west only if the neighboring cell’s height is less than or equal to the current cell’s height.</p></li>
<li><p>Water can flow from any cell adjacent to the ocean into the ocean. This means water can flow from cells on the edge of the island to the Pacific Ocean and the Atlantic Ocean.</p></li>
</ol>
<p>The task is to find and return a 2D list of grid coordinates where rainwater can flow from a cell to both the Pacific and Atlantic Oceans. In other words, you need to identify the cells that can send water to both the left and top edges (Pacific) and the right and bottom edges (Atlantic) of the island.</p>
<p>The problem is solved by performing a depth-first search (DFS) starting from the ocean edges and marking the cells that can flow to each ocean. Then, the algorithm identifies cells that are reachable from both oceans and returns their coordinates as the result.</p>
<p>The problem involves both traversal of the island and backtracking to find the solution, which makes it a classic graph traversal problem.</p>
</section>
<section id="solution">
<h4>Solution:<a class="headerlink" href="#solution" title="Permalink to this heading">#</a></h4>
<p>Here’s a Python function to implement this algorithm:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">pacificAtlantic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">heights</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="c1"># Check if the input matrix is empty</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">heights</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        
        <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">heights</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">heights</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        
        <span class="c1"># Initialize boolean matrices to keep track of cells reachable from each ocean</span>
        <span class="n">pacific_reachable</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">)]</span>
        <span class="n">atlantic_reachable</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">)]</span>
        
        <span class="c1"># Depth-First Search (DFS) function to mark cells that can be reached from an ocean</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">reachable</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">reachable</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]:</span>
                <span class="k">return</span>
            <span class="n">reachable</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span> <span class="ow">in</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]:</span>
                <span class="n">new_x</span><span class="p">,</span> <span class="n">new_y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">dx</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">dy</span>
                <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">new_x</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">new_y</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">heights</span><span class="p">[</span><span class="n">new_x</span><span class="p">][</span><span class="n">new_y</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">heights</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]:</span>
                    <span class="n">dfs</span><span class="p">(</span><span class="n">new_x</span><span class="p">,</span> <span class="n">new_y</span><span class="p">,</span> <span class="n">reachable</span><span class="p">)</span>
        
        <span class="c1"># Start DFS from the Pacific Ocean (left and top edges)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pacific_reachable</span><span class="p">)</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">atlantic_reachable</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">pacific_reachable</span><span class="p">)</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">atlantic_reachable</span><span class="p">)</span>
        
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="c1"># Find cells that can flow to both the Pacific and Atlantic oceans</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">pacific_reachable</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="ow">and</span> <span class="n">atlantic_reachable</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]:</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
        
        <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="explanation">
<h4>Explanation:<a class="headerlink" href="#explanation" title="Permalink to this heading">#</a></h4>
<p>The code defines a class called <code class="docutils literal notranslate"><span class="pre">Solution</span></code> with a method named <code class="docutils literal notranslate"><span class="pre">pacificAtlantic</span></code>. This method takes a 2D matrix <code class="docutils literal notranslate"><span class="pre">heights</span></code>, where each element represents the height above sea level of a cell on a rectangular island. The goal of the method is to find and return a list of grid coordinates (cells) from which rainwater can flow into both the Pacific and Atlantic Oceans.</p>
<p>The code uses a Depth-First Search (DFS) algorithm to traverse the island, starting from the ocean edges, and marks cells that are reachable from either the Pacific or Atlantic Ocean. It does this by creating two boolean matrices, <code class="docutils literal notranslate"><span class="pre">pacific_reachable</span></code> and <code class="docutils literal notranslate"><span class="pre">atlantic_reachable</span></code>, to keep track of cells that can be reached from each ocean.</p>
<p>The code iterates through the entire island, initiating DFS searches from the edges of the island. If a cell is reachable from an ocean (either Pacific or Atlantic), it is marked as reachable in the corresponding boolean matrix. The DFS function ensures that the traversal follows the rule that water can flow to a neighboring cell if the neighboring cell’s height is less than or equal to the current cell’s height.</p>
<p>After marking all reachable cells from both oceans, the code then looks for cells that are reachable from both the Pacific and Atlantic Oceans. If a cell satisfies this condition, it is added to the <code class="docutils literal notranslate"><span class="pre">result</span></code> list.</p>
<p>Finally, the code returns the <code class="docutils literal notranslate"><span class="pre">result</span></code> list, which contains the grid coordinates of cells from which rainwater can flow into both the Pacific and Atlantic Oceans.</p>
<p>The code provides a solution to the problem of finding cells on the island where water can reach both oceans, demonstrating a traversal algorithm that explores the connectivity of cells on the island.</p>
</section>
<section id="test-cases">
<h4>Test cases:<a class="headerlink" href="#test-cases" title="Permalink to this heading">#</a></h4>
<p>Here’s how you can use this solution:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 1</span>
<span class="n">heights1</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="p">]</span>

<span class="n">solution</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">solution</span><span class="o">.</span><span class="n">pacificAtlantic</span><span class="p">(</span><span class="n">heights1</span><span class="p">))</span> <span class="c1"># Expected Output: [[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 2</span>
<span class="n">heights2</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">]]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">solution</span><span class="o">.</span><span class="n">pacificAtlantic</span><span class="p">(</span><span class="n">heights2</span><span class="p">))</span> <span class="c1"># Expected Output: [[0, 0]]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[0, 0]]
</pre></div>
</div>
</div>
</div>
</section>
<section id="time-and-space-complexity-analysis">
<h4>Time and Space Complexity Analysis<a class="headerlink" href="#time-and-space-complexity-analysis" title="Permalink to this heading">#</a></h4>
<p>Time Complexity:
The time complexity of this solution is O(m * n), where ‘m’ is the number of rows in the input matrix and ‘n’ is the number of columns. Here’s a breakdown of the time complexity:</p>
<ol class="arabic simple">
<li><p>Creating the <code class="docutils literal notranslate"><span class="pre">pacific_reachable</span></code> and <code class="docutils literal notranslate"><span class="pre">atlantic_reachable</span></code> matrices with dimensions m x n takes O(m * n) time.</p></li>
<li><p>Initiating Depth-First Search (DFS) from the edges of the island takes O(m * n) time because it processes each cell once.</p></li>
<li><p>The DFS function visits each cell at most once, and its time complexity is O(1) for each cell. The number of cells visited by the DFS in the worst case is m * n.</p></li>
<li><p>The final step of identifying and appending cells to the result list takes O(m * n) time in the worst case.</p></li>
</ol>
<p>Overall, the time complexity is dominated by the DFS and is O(m * n).</p>
<p>Space Complexity:
The space complexity of this solution is also O(m * n). Here’s how the space is used:</p>
<ol class="arabic simple">
<li><p>Two boolean matrices, <code class="docutils literal notranslate"><span class="pre">pacific_reachable</span></code> and <code class="docutils literal notranslate"><span class="pre">atlantic_reachable</span></code>, are created with dimensions m x n. Each matrix takes O(m * n) space, resulting in O(2 * m * n) space usage.</p></li>
<li><p>The depth-first search (DFS) stack space during the recursive calls can go as deep as the diagonal of the grid, which is at most min(m, n). This additional space for the call stack is relatively small compared to the boolean matrices and can be considered O(min(m, n)).</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">result</span></code> list stores the grid coordinates, and its size is determined by the number of cells that can flow to both oceans. In the worst case, this list can contain all m * n cells, so it takes O(m * n) space.</p></li>
</ol>
<p>The overall space complexity is the sum of these components, which is O(m * n) + O(min(m, n)) + O(m * n). In big O notation, we can simplify this to O(m * n).</p>
</section>
<section id="challenging-exercises">
<h4>Challenging Exercises:<a class="headerlink" href="#challenging-exercises" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p><strong>Optimization Challenge:</strong> Modify the algorithm to find the maximum flow of water from any cell to both the Pacific and Atlantic Oceans. In other words, find the cell(s) that can send the most water to both oceans.</p></li>
<li><p><strong>Efficiency Challenge:</strong> Optimize the time and space complexity of the algorithm while maintaining correctness. Aim to reduce both time and space complexity as much as possible.</p></li>
</ol>
</section>
</section>
</div>
</section>
<span id="document-12. Advanced Graphs/README"></span><section class="tex2jax_ignore mathjax_ignore" id="advanced-graphs-problems-blind-75-leetcode">
<h2>Advanced Graphs Problems - Blind 75 LeetCode<a class="headerlink" href="#advanced-graphs-problems-blind-75-leetcode" title="Permalink to this heading">#</a></h2>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Problem Name</p></th>
<th class="head"><p>Difficulty</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/alien-dictionary/">269. Alien Dictionary</a></p></td>
<td><p>Hard</p></td>
</tr>
</tbody>
</table>
<section id="contribute">
<h3>Contribute<a class="headerlink" href="#contribute" title="Permalink to this heading">#</a></h3>
<p>If you have a better solution or want to add more problems to the collection, feel free to contribute. You can create a pull request or open an issue to discuss additions or improvements.</p>
</section>
<section id="resources">
<h3>Resources<a class="headerlink" href="#resources" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p><a class="reference external" href="https://leetcode.com/">LeetCode</a>: The official LeetCode website.</p></li>
<li><p><a class="reference external" href="https://leetcode.com/discuss/">LeetCode Discuss</a>: LeetCode’s discussion forum for each problem. You can find helpful hints and discussions here.</p></li>
</ul>
<p>Happy coding!</p>
</section>
<div class="toctree-wrapper compound">
<span id="document-12. Advanced Graphs/892. Alien Dictionary"></span><section class="tex2jax_ignore mathjax_ignore" id="alien-dictionary">
<h3>892. Alien Dictionary<a class="headerlink" href="#alien-dictionary" title="Permalink to this heading">#</a></h3>
<p><strong>Difficulty:</strong> Hard</p>
<p><strong>Link to Problem:</strong> <a class="reference external" href="https://www.lintcode.com/problem/892/">To see the Alien Dictionary problem on LintCode, click here!</a></p>
<hr class="docutils" />
<p>There is a new alien language which uses the latin alphabet. However, the order among letters are unknown to you. You receive a list of <strong>non-empty</strong> words from the dictionary, where words are <strong>sorted lexicographically by the rules of this new language</strong>. Derive the order of letters in this language.</p>
<p><strong>Constraints:</strong></p>
<ul class="simple">
<li><p>You may assume all letters are in lowercase.</p></li>
<li><p>The dictionary is invalid, if string a is prefix of string b and b is appear before a.</p></li>
<li><p>If the order is invalid, return an empty string.</p></li>
<li><p>There may be multiple valid order of letters, return the smallest in normal lexicographical order.</p></li>
<li><p>The letters in <strong>one</strong> string are of the same rank by default and are sorted in Human dictionary order.</p></li>
</ul>
<section id="probelm-explanation">
<h4>Probelm Explanation:<a class="headerlink" href="#probelm-explanation" title="Permalink to this heading">#</a></h4>
<p>The problem at hand involves determining the order of letters in a new alien language that uses the Latin alphabet. However, the order of letters in this alien language is unknown. To solve this problem, we are given a list of non-empty words from the dictionary, where the words are sorted lexicographically based on the rules of the alien language. The goal is to derive the correct order of letters in this new language.</p>
<p>Here’s a more detailed explanation of the problem:</p>
<ol class="arabic simple">
<li><p>The alphabet: The new alien language uses the Latin alphabet, which consists of lowercase letters.</p></li>
<li><p>Dictionary: We are provided with a list of non-empty words. These words are sorted in lexicographical order based on the rules of the alien language. The order of letters in the words reflects the correct order in the new language.</p></li>
<li><p>Invalid order: The problem specifies that the dictionary is considered invalid if there exists a situation where one string ‘a’ is a prefix of another string ‘b,’ and ‘b’ appears before ‘a’ in the dictionary. This condition ensures that there are no inconsistencies in the order of letters.</p></li>
<li><p>Multiple valid orders: It’s possible that there are multiple valid orders of letters that satisfy the provided dictionary. However, we are instructed to return the smallest valid order in normal lexicographical order.</p></li>
</ol>
<p>To solve this problem, you need to analyze the given list of words and determine the correct order of letters in the alien language while adhering to the specified constraints. You should return the order as a string in lexicographical order if it’s valid, and an empty string if the order is invalid.</p>
<p>The key to solving this problem is to construct a directed graph of letter relationships based on the order information provided by the words in the dictionary. Then, perform a topological sort on this graph to derive the order of letters, ensuring that the order is consistent and valid according to the given constraints.</p>
</section>
<section id="solution">
<h4>Solution:<a class="headerlink" href="#solution" title="Permalink to this heading">#</a></h4>
<p>Here’s a Python function to implement this algorithm:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">deque</span>

<span class="k">def</span> <span class="nf">alienOrder</span><span class="p">(</span><span class="n">words</span><span class="p">):</span>
    <span class="c1"># Create an adjacency list to represent the graph</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    
    <span class="c1"># Create a dictionary to store the in-degrees of each letter</span>
    <span class="n">in_degree</span> <span class="o">=</span> <span class="p">{}</span>
    
    <span class="c1"># Initialize in-degrees to 0 for all letters</span>
    <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">words</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">word</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">char</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">in_degree</span><span class="p">:</span>
                <span class="n">in_degree</span><span class="p">[</span><span class="n">char</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="c1"># Build the graph and update in-degrees</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">)):</span>
        <span class="n">word1</span><span class="p">,</span> <span class="n">word2</span> <span class="o">=</span> <span class="n">words</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">words</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">min_length</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">word1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">word2</span><span class="p">))</span>
        
        <span class="c1"># Compare characters in the two words</span>
        <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">min_length</span> <span class="ow">and</span> <span class="n">word1</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">word2</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">min_length</span><span class="p">:</span>
            <span class="c1"># If word1[j] is lexicographically before word2[j], add an edge</span>
            <span class="n">graph</span><span class="p">[</span><span class="n">word1</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">word2</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="n">in_degree</span><span class="p">[</span><span class="n">word2</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">+=</span> <span class="mi">1</span>
            
            <span class="c1"># Break the loop to avoid further comparisons</span>
            <span class="k">break</span>
    
    <span class="c1"># Perform topological sorting using Kahn&#39;s algorithm</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="n">char</span> <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">in_degree</span> <span class="k">if</span> <span class="n">in_degree</span><span class="p">[</span><span class="n">char</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">])</span>
    
    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="n">char</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">char</span><span class="p">]:</span>
            <span class="n">in_degree</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">in_degree</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>
    
    <span class="c1"># Check if there is a valid order</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">in_degree</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span>
    
    <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="explanation">
<h4>Explanation:<a class="headerlink" href="#explanation" title="Permalink to this heading">#</a></h4>
<p>The code is designed to determine the order of letters in an unknown alien language that uses the Latin alphabet. It takes a list of non-empty words from a dictionary as input, where the words are sorted lexicographically based on the rules of this alien language.</p>
<p>The code follows these main steps:</p>
<ol class="arabic simple">
<li><p>Create a data structure to represent the graph of letters and their relationships in the alien language. It uses a defaultdict to store a list of letters that come after each letter. Additionally, it uses a dictionary called <code class="docutils literal notranslate"><span class="pre">in_degree</span></code> to keep track of the in-degrees (the number of letters that precede a letter) for each letter.</p></li>
<li><p>Initialize the in-degrees of all letters to 0. This is done by iterating through all the words and characters in the words, adding each character to the <code class="docutils literal notranslate"><span class="pre">in_degree</span></code> dictionary with an initial in-degree of 0.</p></li>
<li><p>Build the graph by comparing adjacent words in the dictionary. For each pair of adjacent words, the code finds the first differing character between the two words. If such a character exists, it means there’s an order relationship between the letters represented by these characters. The code updates the graph and in-degrees accordingly.</p></li>
<li><p>After constructing the graph, the code performs a topological sorting of the letters using Kahn’s algorithm. It starts by initializing an empty result list and a queue containing letters with in-degrees of 0. The algorithm repeatedly removes a letter with an in-degree of 0 from the queue, adds it to the result list, and updates the in-degrees of its neighbors. This process continues until the queue is empty.</p></li>
<li><p>Finally, the code checks if the topological sorting was successful by comparing the length of the result list with the number of unique letters in the input. If the lengths differ, it means there’s a cycle in the graph, and the order is invalid. In such a case, an empty string is returned. Otherwise, the result list is joined together to form the smallest order of letters in normal lexicographical order, and it is returned as the output.</p></li>
</ol>
<p>The code provides a way to determine the order of letters in the alien language while handling various edge cases, including checking for invalid order conditions.</p>
</section>
<section id="test-cases">
<h4>Test cases:<a class="headerlink" href="#test-cases" title="Permalink to this heading">#</a></h4>
<p>Here’s how you can use this solution:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 1</span>
<span class="n">words1</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;wrt&quot;</span><span class="p">,</span> <span class="s2">&quot;wrf&quot;</span><span class="p">,</span> <span class="s2">&quot;er&quot;</span><span class="p">,</span> <span class="s2">&quot;ett&quot;</span><span class="p">,</span> <span class="s2">&quot;rftt&quot;</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">alienOrder</span><span class="p">(</span><span class="n">words1</span><span class="p">))</span>  <span class="c1"># Output: &quot;wertf&quot;</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>wrtef
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 2</span>
<span class="n">words2</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;z&quot;</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">alienOrder</span><span class="p">(</span><span class="n">words2</span><span class="p">))</span>  <span class="c1"># Output: &quot;zx&quot;</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>zx
</pre></div>
</div>
</div>
</div>
</section>
<section id="time-and-space-complexity-analysis">
<h4>Time and Space Complexity Analysis<a class="headerlink" href="#time-and-space-complexity-analysis" title="Permalink to this heading">#</a></h4>
<p>Let’s analyze the time and space complexity of the provided code for determining the order of letters in an alien language.</p>
<p>Time Complexity:</p>
<ol class="arabic simple">
<li><p>Building the graph: The code iterates through the list of words and compares adjacent words. In the worst case, where all words have the same prefix, it takes O(N) time to build the graph, where N is the total number of characters in all the words.</p></li>
<li><p>Topological sorting: Performing a topological sort on the graph takes O(V + E) time, where V is the number of unique letters (vertices) and E is the number of relationships between letters (edges) in the graph.</p></li>
</ol>
<p>Overall, the time complexity is O(N + V + E), where N is the total number of characters in the words, V is the number of unique letters, and E is the number of order relationships between letters.</p>
<p>Space Complexity:</p>
<ol class="arabic simple">
<li><p>Graph and In-degrees: The code uses data structures to represent the graph and in-degrees. The space complexity for these data structures is O(V + E), where V is the number of unique letters, and E is the number of order relationships between letters in the words.</p></li>
<li><p>Result List: The result list stores the order of letters, which can have a maximum size of V, where V is the number of unique letters.</p></li>
<li><p>Queue: The space used by the queue during topological sorting is also O(V).</p></li>
</ol>
<p>Overall, the space complexity is O(V + E) due to the data structures used for graph representation and the space needed for storing the result and the queue.</p>
<p>In the worst case, where there are many unique letters and many order relationships, the space complexity is dominated by the number of unique letters and their relationships.</p>
<p>In summary, the time complexity of the code is O(N + V + E), and the space complexity is O(V + E). The actual performance will depend on the specific input data, such as the number of unique letters and the relationships between them in the alien language.</p>
</section>
<section id="challenging-exercises">
<h4>Challenging Exercises:<a class="headerlink" href="#challenging-exercises" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p><strong>Multiple Valid Orders</strong>: Extend the problem to handle cases where there are multiple valid orders of letters in the alien language. Modify the code to return all valid orders instead of just one. Be mindful of performance.</p></li>
<li><p><strong>Detect Invalid Dictionary</strong>: Given a dictionary of words, write a function to detect whether the dictionary is valid or not based on the constraints mentioned in the problem statement.</p></li>
</ol>
</section>
</section>
</div>
</section>
<span id="document-13. One-D Dynamic Programming/README"></span><section class="tex2jax_ignore mathjax_ignore" id="d-dynamic-programming-problems-blind-75-leetcode">
<h2>1-D Dynamic Programming Problems - Blind 75 LeetCode<a class="headerlink" href="#d-dynamic-programming-problems-blind-75-leetcode" title="Permalink to this heading">#</a></h2>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Problem Name</p></th>
<th class="head"><p>Difficulty</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/climbing-stairs/">70. Climbing Stairs</a></p></td>
<td><p>Easy</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/house-robber/">198. House Robber</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/house-robber-ii/">213. House Robber II</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/longest-palindromic-substring/">5. Longest Palindromic Substring</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/palindromic-substrings/">647. Palindromic Substrings</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/decode-ways/">91. Decode Ways</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/coin-change/">322. Coin Change</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/maximum-product-subarray/">152. Maximum Product Subarray</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/word-break/">139. Word Break</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/longest-increasing-subsequence/">300. Longest Increasing Subsequence</a></p></td>
<td><p>Medium</p></td>
</tr>
</tbody>
</table>
<section id="contribute">
<h3>Contribute<a class="headerlink" href="#contribute" title="Permalink to this heading">#</a></h3>
<p>If you have a better solution or want to add more problems to the collection, feel free to contribute. You can create a pull request or open an issue to discuss additions or improvements.</p>
</section>
<section id="resources">
<h3>Resources<a class="headerlink" href="#resources" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p><a class="reference external" href="https://leetcode.com/">LeetCode</a>: The official LeetCode website.</p></li>
<li><p><a class="reference external" href="https://leetcode.com/discuss/">LeetCode Discuss</a>: LeetCode’s discussion forum for each problem. You can find helpful hints and discussions here.</p></li>
</ul>
<p>Happy coding!</p>
</section>
<div class="toctree-wrapper compound">
<span id="document-13. One-D Dynamic Programming/70. Climbing Stairs"></span><section class="tex2jax_ignore mathjax_ignore" id="climbing-stairs">
<h3>70. Climbing Stairs<a class="headerlink" href="#climbing-stairs" title="Permalink to this heading">#</a></h3>
<p><strong>Difficulty:</strong> Easy</p>
<p><strong>Link to Problem:</strong> <a class="reference external" href="https://leetcode.com/problems/climbing-stairs/">To see the Climbing Stairs problem on LeetCode, click here!</a></p>
<hr class="docutils" />
<p>You are climbing a staircase. It takes <code class="docutils literal notranslate"><span class="pre">n</span></code> steps to reach the top.</p>
<p>Each time you can either climb <code class="docutils literal notranslate"><span class="pre">1</span></code> or <code class="docutils literal notranslate"><span class="pre">2</span></code> steps. In how many distinct ways can you climb to the top?</p>
<p><strong>Constraints:</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">&lt;=</span> <span class="pre">n</span> <span class="pre">&lt;=</span> <span class="pre">45</span></code></p></li>
</ul>
<section id="probelm-explanation">
<h4>Probelm Explanation:<a class="headerlink" href="#probelm-explanation" title="Permalink to this heading">#</a></h4>
<p>The “Climbing Stairs” problem is a classic algorithmic problem that asks you to find the number of distinct ways to climb a staircase with a given number of steps. Here’s the problem statement:</p>
<p>You are given a staircase with ‘n’ steps. Each time you can either climb 1 step or 2 steps. You need to find out how many distinct ways there are to reach the top of the staircase.</p>
<p>For example, if ‘n’ is 2, there are two ways to climb to the top:</p>
<ol class="arabic simple">
<li><p>Climbing two steps at once.</p></li>
<li><p>Climbing one step, and then another step.</p></li>
</ol>
<p>If ‘n’ is 3, there are three ways:</p>
<ol class="arabic simple">
<li><p>Climbing one step, then one step, and finally one step.</p></li>
<li><p>Climbing one step, then two steps.</p></li>
<li><p>Climbing two steps, then one step.</p></li>
</ol>
<p>The problem essentially asks you to find a solution that counts the possible combinations of 1-step and 2-step climbs that can be taken to reach the top of the staircase. It’s a classic example of a dynamic programming problem where you can break it down into smaller subproblems and build a solution incrementally, as shown in the code I provided earlier.</p>
</section>
<section id="solution">
<h4>Solution:<a class="headerlink" href="#solution" title="Permalink to this heading">#</a></h4>
<p>Here’s a Python function to implement this algorithm:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">climbStairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="c1"># If there are 1 or 2 steps, there are exactly n ways to reach the top.</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">n</span>

        <span class="c1"># Create an array to store the number of ways to reach each step.</span>
        <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># There is one way to reach the first step (base case).</span>
        <span class="n">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># There are two ways to reach the second step (base case).</span>
        <span class="n">dp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>

        <span class="c1"># Calculate the number of ways to reach each step from the previous steps.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># The number of ways to reach step &#39;i&#39; is the sum of the ways to reach</span>
            <span class="c1"># the previous two steps, as you can take 1 or 2 steps at a time.</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span>

        <span class="c1"># The result is the number of ways to reach the top, which is stored in dp[n].</span>
        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="explanation">
<h4>Explanation:<a class="headerlink" href="#explanation" title="Permalink to this heading">#</a></h4>
<p>The code defines a class <code class="docutils literal notranslate"><span class="pre">Solution</span></code> with a method <code class="docutils literal notranslate"><span class="pre">climbStairs</span></code> that takes an integer <code class="docutils literal notranslate"><span class="pre">n</span></code> as input and returns the number of distinct ways to climb a staircase with <code class="docutils literal notranslate"><span class="pre">n</span></code> steps.</p>
<ol class="arabic simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">n</span></code> is 1 or 2, the function returns <code class="docutils literal notranslate"><span class="pre">n</span></code> directly because there are only 1 or 2 distinct ways to reach the top in those cases.</p></li>
<li><p>For <code class="docutils literal notranslate"><span class="pre">n</span></code> greater than 2, the code uses dynamic programming to calculate the number of ways to reach each step. It creates an array <code class="docutils literal notranslate"><span class="pre">dp</span></code> of length <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">+</span> <span class="pre">1</span></code> to store these values.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">dp[1]</span></code> and <code class="docutils literal notranslate"><span class="pre">dp[2]</span></code> are initialized to 1 and 2, respectively. This is because there is only one way to reach the first step (by taking 1 step), and there are two ways to reach the second step (by taking 2 steps or two 1-step climbs).</p></li>
<li><p>The code then uses a loop to fill in the <code class="docutils literal notranslate"><span class="pre">dp</span></code> array for steps 3 and above. For each step <code class="docutils literal notranslate"><span class="pre">i</span></code> from 3 to <code class="docutils literal notranslate"><span class="pre">n</span></code>, it calculates the number of ways to reach that step by adding the number of ways to reach the previous two steps, as you can either take 1 step or 2 steps at a time.</p></li>
<li><p>Finally, the function returns the value stored in <code class="docutils literal notranslate"><span class="pre">dp[n]</span></code>, which represents the total number of distinct ways to climb the staircase with <code class="docutils literal notranslate"><span class="pre">n</span></code> steps.</p></li>
</ol>
</section>
<section id="test-cases">
<h4>Test cases:<a class="headerlink" href="#test-cases" title="Permalink to this heading">#</a></h4>
<p>Here’s how you can use this solution:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 1:</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">solution</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Example 1 - Input: n = </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">, Output: </span><span class="si">{</span><span class="n">solution</span><span class="o">.</span><span class="n">climbStairs</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>  <span class="c1"># Output should be 2</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Example 1 - Input: n = 2, Output: 2
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 2:</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">3</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Example 2 - Input: n = </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">, Output: </span><span class="si">{</span><span class="n">solution</span><span class="o">.</span><span class="n">climbStairs</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>  <span class="c1"># Output should be 3</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Example 2 - Input: n = 3, Output: 3
</pre></div>
</div>
</div>
</div>
</section>
<section id="time-and-space-complexity-analysis">
<h4>Time and Space Complexity Analysis<a class="headerlink" href="#time-and-space-complexity-analysis" title="Permalink to this heading">#</a></h4>
<p>Time Complexity:
The time complexity of the solution is O(n) because we use a single for loop that iterates from 3 to n to fill the <code class="docutils literal notranslate"><span class="pre">dp</span></code> array. In each iteration, we perform constant time operations (addition and assignment). Therefore, the time complexity is linear with respect to the input value <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p>
<p>Space Complexity:
The space complexity of the solution is O(n) as well. We use an array <code class="docutils literal notranslate"><span class="pre">dp</span></code> of length <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">+</span> <span class="pre">1</span></code> to store the number of ways to reach each step. The size of this array is directly proportional to the input value <code class="docutils literal notranslate"><span class="pre">n</span></code>, which makes the space complexity linear in terms of <code class="docutils literal notranslate"><span class="pre">n</span></code>. The rest of the variables used in the function (e.g., <code class="docutils literal notranslate"><span class="pre">i</span></code>) occupy constant space and do not contribute significantly to the overall space complexity.</p>
<p>In summary, the time complexity is O(n), and the space complexity is O(n) for this dynamic programming solution to the “Climbing Stairs” problem.</p>
</section>
<section id="challenging-exercises">
<h4>Challenging Exercises:<a class="headerlink" href="#challenging-exercises" title="Permalink to this heading">#</a></h4>
<ol class="arabic simple">
<li><p><strong>Generalized Step Sizes</strong>: Instead of being limited to 1 step or 2 steps, consider a scenario where you can take steps of sizes <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3]</span></code>. Implement a function that calculates the number of ways to climb the staircase with these different step sizes.</p></li>
<li><p><strong>Minimize Steps</strong>: Given an integer <code class="docutils literal notranslate"><span class="pre">n</span></code>, find the minimum number of steps required to reach the top of the staircase. Return both the minimum number of steps and the specific sequence of steps taken.</p></li>
</ol>
</section>
</section>
</div>
</section>
<span id="document-14. Two-D Dynamic Programming/README"></span><section class="tex2jax_ignore mathjax_ignore" id="blind-75-leetcode-problems">
<h2>Blind 75 LeetCode Problems<a class="headerlink" href="#blind-75-leetcode-problems" title="Permalink to this heading">#</a></h2>
<p>This repository contains a curated list of 75 LeetCode problems that are commonly known as the “Blind 75.” These problems cover a wide range of data structures and algorithms and are frequently asked in technical interviews. Solving these problems can help you build a strong foundation in algorithmic problem-solving.</p>
<section id="problem-list">
<h3>Problem List<a class="headerlink" href="#problem-list" title="Permalink to this heading">#</a></h3>
<section id="d-dynamic-programming">
<h4>2-D Dynamic Programming<a class="headerlink" href="#d-dynamic-programming" title="Permalink to this heading">#</a></h4>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Problem Name</p></th>
<th class="head"><p>Difficulty</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/unique-paths/">62. Unique Paths</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/longest-common-subsequence/">1143. Longest Common Subsequence</a></p></td>
<td><p>Medium</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="how-to-use">
<h3>How to Use<a class="headerlink" href="#how-to-use" title="Permalink to this heading">#</a></h3>
<ol class="arabic simple">
<li><p>Clone or download this repository to your local machine.</p></li>
</ol>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>git<span class="w"> </span>clone<span class="w"> </span>https://github.com/mohsentabibian/LeetCode-Solutions/Blind-75-LeetCode.git
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li><p>Navigate to the directory of the specific problem you want to solve.</p></li>
</ol>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span><span class="w"> </span>Blind-75-LeetCode/Problem-Directory
</pre></div>
</div>
<ol class="arabic simple" start="3">
<li><p>Open the problem’s directory to find its description, code template, and solution(s).</p></li>
<li><p>Solve the problem using your preferred programming language.</p></li>
<li><p>Check the solution(s) provided in the directory for reference and to compare your solution.</p></li>
</ol>
</section>
<section id="contribute">
<h3>Contribute<a class="headerlink" href="#contribute" title="Permalink to this heading">#</a></h3>
<p>If you have a better solution or want to add more problems to the collection, feel free to contribute. You can create a pull request or open an issue to discuss additions or improvements.</p>
</section>
<section id="resources">
<h3>Resources<a class="headerlink" href="#resources" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p><a class="reference external" href="https://leetcode.com/">LeetCode</a>: The official LeetCode website.</p></li>
<li><p><a class="reference external" href="https://leetcode.com/discuss/">LeetCode Discuss</a>: LeetCode’s discussion forum for each problem. You can find helpful hints and discussions here.</p></li>
</ul>
</section>
<section id="disclaimer">
<h3>Disclaimer<a class="headerlink" href="#disclaimer" title="Permalink to this heading">#</a></h3>
<p>This repository is meant for educational purposes and to help individuals prepare for technical interviews. Please respect LeetCode’s terms of use and guidelines when using this repository.</p>
<p>Happy coding!</p>
</section>
</section>
<span id="document-15. Greedy/README"></span><section class="tex2jax_ignore mathjax_ignore" id="blind-75-leetcode-problems">
<h2>Blind 75 LeetCode Problems<a class="headerlink" href="#blind-75-leetcode-problems" title="Permalink to this heading">#</a></h2>
<p>This repository contains a curated list of 75 LeetCode problems that are commonly known as the “Blind 75.” These problems cover a wide range of data structures and algorithms and are frequently asked in technical interviews. Solving these problems can help you build a strong foundation in algorithmic problem-solving.</p>
<section id="problem-list">
<h3>Problem List<a class="headerlink" href="#problem-list" title="Permalink to this heading">#</a></h3>
<section id="greedy">
<h4>Greedy<a class="headerlink" href="#greedy" title="Permalink to this heading">#</a></h4>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Problem Name</p></th>
<th class="head"><p>Difficulty</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/maximum-subarray/">53. Maximum Subarray</a></p></td>
<td><p>Easy</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/jump-game/">55. Jump Game</a></p></td>
<td><p>Medium</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="how-to-use">
<h3>How to Use<a class="headerlink" href="#how-to-use" title="Permalink to this heading">#</a></h3>
<ol class="arabic simple">
<li><p>Clone or download this repository to your local machine.</p></li>
</ol>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>git<span class="w"> </span>clone<span class="w"> </span>https://github.com/mohsentabibian/LeetCode-Solutions/Blind-75-LeetCode.git
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li><p>Navigate to the directory of the specific problem you want to solve.</p></li>
</ol>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span><span class="w"> </span>Blind-75-LeetCode/Problem-Directory
</pre></div>
</div>
<ol class="arabic simple" start="3">
<li><p>Open the problem’s directory to find its description, code template, and solution(s).</p></li>
<li><p>Solve the problem using your preferred programming language.</p></li>
<li><p>Check the solution(s) provided in the directory for reference and to compare your solution.</p></li>
</ol>
</section>
<section id="contribute">
<h3>Contribute<a class="headerlink" href="#contribute" title="Permalink to this heading">#</a></h3>
<p>If you have a better solution or want to add more problems to the collection, feel free to contribute. You can create a pull request or open an issue to discuss additions or improvements.</p>
</section>
<section id="resources">
<h3>Resources<a class="headerlink" href="#resources" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p><a class="reference external" href="https://leetcode.com/">LeetCode</a>: The official LeetCode website.</p></li>
<li><p><a class="reference external" href="https://leetcode.com/discuss/">LeetCode Discuss</a>: LeetCode’s discussion forum for each problem. You can find helpful hints and discussions here.</p></li>
</ul>
</section>
<section id="disclaimer">
<h3>Disclaimer<a class="headerlink" href="#disclaimer" title="Permalink to this heading">#</a></h3>
<p>This repository is meant for educational purposes and to help individuals prepare for technical interviews. Please respect LeetCode’s terms of use and guidelines when using this repository.</p>
<p>Happy coding!</p>
</section>
</section>
<span id="document-16. Intervals/README"></span><section class="tex2jax_ignore mathjax_ignore" id="blind-75-leetcode-problems">
<h2>Blind 75 LeetCode Problems<a class="headerlink" href="#blind-75-leetcode-problems" title="Permalink to this heading">#</a></h2>
<p>This repository contains a curated list of 75 LeetCode problems that are commonly known as the “Blind 75.” These problems cover a wide range of data structures and algorithms and are frequently asked in technical interviews. Solving these problems can help you build a strong foundation in algorithmic problem-solving.</p>
<section id="problem-list">
<h3>Problem List<a class="headerlink" href="#problem-list" title="Permalink to this heading">#</a></h3>
<section id="intervals">
<h4>Intervals<a class="headerlink" href="#intervals" title="Permalink to this heading">#</a></h4>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Problem Name</p></th>
<th class="head"><p>Difficulty</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/insert-interval/">57. Insert Interval</a></p></td>
<td><p>Hard</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/merge-intervals/">56. Merge Intervals</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/non-overlapping-intervals/">435. Non Overlapping Intervals</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/meeting-rooms/">252. Meeting Rooms</a></p></td>
<td><p>Easy</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/meeting-rooms-ii/">253. Meeting Rooms II</a></p></td>
<td><p>Medium</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="how-to-use">
<h3>How to Use<a class="headerlink" href="#how-to-use" title="Permalink to this heading">#</a></h3>
<ol class="arabic simple">
<li><p>Clone or download this repository to your local machine.</p></li>
</ol>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>git<span class="w"> </span>clone<span class="w"> </span>https://github.com/mohsentabibian/LeetCode-Solutions/Blind-75-LeetCode.git
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li><p>Navigate to the directory of the specific problem you want to solve.</p></li>
</ol>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span><span class="w"> </span>Blind-75-LeetCode/Problem-Directory
</pre></div>
</div>
<ol class="arabic simple" start="3">
<li><p>Open the problem’s directory to find its description, code template, and solution(s).</p></li>
<li><p>Solve the problem using your preferred programming language.</p></li>
<li><p>Check the solution(s) provided in the directory for reference and to compare your solution.</p></li>
</ol>
</section>
<section id="contribute">
<h3>Contribute<a class="headerlink" href="#contribute" title="Permalink to this heading">#</a></h3>
<p>If you have a better solution or want to add more problems to the collection, feel free to contribute. You can create a pull request or open an issue to discuss additions or improvements.</p>
</section>
<section id="resources">
<h3>Resources<a class="headerlink" href="#resources" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p><a class="reference external" href="https://leetcode.com/">LeetCode</a>: The official LeetCode website.</p></li>
<li><p><a class="reference external" href="https://leetcode.com/discuss/">LeetCode Discuss</a>: LeetCode’s discussion forum for each problem. You can find helpful hints and discussions here.</p></li>
</ul>
</section>
<section id="disclaimer">
<h3>Disclaimer<a class="headerlink" href="#disclaimer" title="Permalink to this heading">#</a></h3>
<p>This repository is meant for educational purposes and to help individuals prepare for technical interviews. Please respect LeetCode’s terms of use and guidelines when using this repository.</p>
<p>Happy coding!</p>
</section>
</section>
<span id="document-17. Math Geometry/README"></span><section class="tex2jax_ignore mathjax_ignore" id="blind-75-leetcode-problems">
<h2>Blind 75 LeetCode Problems<a class="headerlink" href="#blind-75-leetcode-problems" title="Permalink to this heading">#</a></h2>
<p>This repository contains a curated list of 75 LeetCode problems that are commonly known as the “Blind 75.” These problems cover a wide range of data structures and algorithms and are frequently asked in technical interviews. Solving these problems can help you build a strong foundation in algorithmic problem-solving.</p>
<section id="problem-list">
<h3>Problem List<a class="headerlink" href="#problem-list" title="Permalink to this heading">#</a></h3>
<section id="math-geometry">
<h4>Math &amp; Geometry<a class="headerlink" href="#math-geometry" title="Permalink to this heading">#</a></h4>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Problem Name</p></th>
<th class="head"><p>Difficulty</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/rotate-image/">48. Rotate Image</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/spiral-matrix/">54. Spiral Matrix</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/set-matrix-zeroes/">73. Set Matrix Zeroes</a></p></td>
<td><p>Medium</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="how-to-use">
<h3>How to Use<a class="headerlink" href="#how-to-use" title="Permalink to this heading">#</a></h3>
<ol class="arabic simple">
<li><p>Clone or download this repository to your local machine.</p></li>
</ol>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>git<span class="w"> </span>clone<span class="w"> </span>https://github.com/mohsentabibian/LeetCode-Solutions/Blind-75-LeetCode.git
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li><p>Navigate to the directory of the specific problem you want to solve.</p></li>
</ol>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span><span class="w"> </span>Blind-75-LeetCode/Problem-Directory
</pre></div>
</div>
<ol class="arabic simple" start="3">
<li><p>Open the problem’s directory to find its description, code template, and solution(s).</p></li>
<li><p>Solve the problem using your preferred programming language.</p></li>
<li><p>Check the solution(s) provided in the directory for reference and to compare your solution.</p></li>
</ol>
</section>
<section id="contribute">
<h3>Contribute<a class="headerlink" href="#contribute" title="Permalink to this heading">#</a></h3>
<p>If you have a better solution or want to add more problems to the collection, feel free to contribute. You can create a pull request or open an issue to discuss additions or improvements.</p>
</section>
<section id="resources">
<h3>Resources<a class="headerlink" href="#resources" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p><a class="reference external" href="https://leetcode.com/">LeetCode</a>: The official LeetCode website.</p></li>
<li><p><a class="reference external" href="https://leetcode.com/discuss/">LeetCode Discuss</a>: LeetCode’s discussion forum for each problem. You can find helpful hints and discussions here.</p></li>
</ul>
</section>
<section id="disclaimer">
<h3>Disclaimer<a class="headerlink" href="#disclaimer" title="Permalink to this heading">#</a></h3>
<p>This repository is meant for educational purposes and to help individuals prepare for technical interviews. Please respect LeetCode’s terms of use and guidelines when using this repository.</p>
<p>Happy coding!</p>
</section>
</section>
<span id="document-18. Bit Manipulation/README"></span><section class="tex2jax_ignore mathjax_ignore" id="blind-75-leetcode-problems">
<h2>Blind 75 LeetCode Problems<a class="headerlink" href="#blind-75-leetcode-problems" title="Permalink to this heading">#</a></h2>
<p>This repository contains a curated list of 75 LeetCode problems that are commonly known as the “Blind 75.” These problems cover a wide range of data structures and algorithms and are frequently asked in technical interviews. Solving these problems can help you build a strong foundation in algorithmic problem-solving.</p>
<section id="problem-list">
<h3>Problem List<a class="headerlink" href="#problem-list" title="Permalink to this heading">#</a></h3>
<section id="bit-manupulation">
<h4>Bit Manupulation<a class="headerlink" href="#bit-manupulation" title="Permalink to this heading">#</a></h4>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Problem Name</p></th>
<th class="head"><p>Difficulty</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/number-of-1-bits/">191. Number of 1 Bits</a></p></td>
<td><p>Easy</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/counting-bits/">338. Counting Bits</a></p></td>
<td><p>Medium</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/reverse-bits/">190. Reverse Bits</a></p></td>
<td><p>Easy</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://leetcode.com/problems/missing-number/">268. Missing Number</a></p></td>
<td><p>Easy</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://leetcode.com/problems/sum-of-two-integers/">371. Sum of Two Integers</a></p></td>
<td><p>Medium</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="how-to-use">
<h3>How to Use<a class="headerlink" href="#how-to-use" title="Permalink to this heading">#</a></h3>
<ol class="arabic simple">
<li><p>Clone or download this repository to your local machine.</p></li>
</ol>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>git<span class="w"> </span>clone<span class="w"> </span>https://github.com/mohsentabibian/LeetCode-Solutions/Blind-75-LeetCode.git
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li><p>Navigate to the directory of the specific problem you want to solve.</p></li>
</ol>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span><span class="w"> </span>Blind-75-LeetCode/Problem-Directory
</pre></div>
</div>
<ol class="arabic simple" start="3">
<li><p>Open the problem’s directory to find its description, code template, and solution(s).</p></li>
<li><p>Solve the problem using your preferred programming language.</p></li>
<li><p>Check the solution(s) provided in the directory for reference and to compare your solution.</p></li>
</ol>
</section>
<section id="contribute">
<h3>Contribute<a class="headerlink" href="#contribute" title="Permalink to this heading">#</a></h3>
<p>If you have a better solution or want to add more problems to the collection, feel free to contribute. You can create a pull request or open an issue to discuss additions or improvements.</p>
</section>
<section id="resources">
<h3>Resources<a class="headerlink" href="#resources" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p><a class="reference external" href="https://leetcode.com/">LeetCode</a>: The official LeetCode website.</p></li>
<li><p><a class="reference external" href="https://leetcode.com/discuss/">LeetCode Discuss</a>: LeetCode’s discussion forum for each problem. You can find helpful hints and discussions here.</p></li>
</ul>
</section>
<section id="disclaimer">
<h3>Disclaimer<a class="headerlink" href="#disclaimer" title="Permalink to this heading">#</a></h3>
<p>This repository is meant for educational purposes and to help individuals prepare for technical interviews. Please respect LeetCode’s terms of use and guidelines when using this repository.</p>
<p>Happy coding!</p>
</section>
</section>
</div>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer">
                  <!-- Previous / next buttons -->
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toctree-l1 toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-01. Array Hashing/README">Array &amp; Hashing Solutions - Blind 75 LeetCode Problems</a><ul class="visible nav section-nav flex-column">
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-01. Array Hashing/1. Two Sum">100: Same Tree</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-01. Array Hashing/128. Longest Consecutive Sequence">128. Longest Consecutive Sequence</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-01. Array Hashing/217. Contains Duplicate">217. Contains Duplicate</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-01. Array Hashing/238. Product of Array Except Self">238. Product of Array Except Self</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-01. Array Hashing/242. Valid Anagram">242. Valid Anagram</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-01. Array Hashing/347. Top K Frequent Elements">347. Top K Frequent Elements</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-01. Array Hashing/49. Group Anagrams">49. Group Anagrams</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-01. Array Hashing/659. Encode and Decode Strings">659· Encode and Decode Strings</a></li>
</ul>
</li>
<li class="toctree-l1 toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-02. Two Pointers/README">Two Pointers Problems - Blind 75 LeetCode</a><ul class="visible nav section-nav flex-column">
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-02. Two Pointers/11. Container With Most Water">11. Container With Most Water</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-02. Two Pointers/125. Valid Palindrome">125. Valid Palindrome</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-02. Two Pointers/15. 3Sum">15. 3Sum</a></li>
</ul>
</li>
<li class="toctree-l1 toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-03. Sliding Window/README">Sliding Window Problems - Blind 75 LeetCode</a><ul class="visible nav section-nav flex-column">
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-03. Sliding Window/121. Best Time to Buy and Sell Stock">121. Best Time to Buy and Sell Stock</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-03. Sliding Window/3. Longest Substring Without Repeating Characters">3. Longest Substring Without Repeating Characters</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-03. Sliding Window/424. Longest Repeating Character Replacement">424. Longest Repeating Character Replacement</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-03. Sliding Window/76. Minimum Window Substring">76. Minimum Window Substring</a></li>
</ul>
</li>
<li class="toctree-l1 toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-04. Stack/README">Stack Problems - Blind 75 LeetCode</a><ul class="visible nav section-nav flex-column">
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-04. Stack/20. Valid Parentheses">20. Valid Parentheses</a></li>
</ul>
</li>
<li class="toctree-l1 toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-05. Binary Search/README">Binary search Problems - Blind 75 LeetCode</a><ul class="visible nav section-nav flex-column">
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-05. Binary Search/153. Find Minimum in Rotated Sorted Array">153. Find Minimum in Rotated Sorted Array</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-05. Binary Search/33. Search in Rotated Sorted Array">33. Search in Rotated Sorted Array</a></li>
</ul>
</li>
<li class="toctree-l1 toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-06. Linked List/README">Linked List Problems - Blind 75 LeetCode</a><ul class="visible nav section-nav flex-column">
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-06. Linked List/141. Linked List Cycle">141. Linked List Cycle</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-06. Linked List/143. Reorder List">143. Reorder List</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-06. Linked List/19. Remove Nth Node From End of List">19. Remove Nth Node From End of List</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-06. Linked List/206. Reverse Linked List">206. Reverse Linked List</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-06. Linked List/21. Merge Two Sorted Lists">21. Merge Two Sorted Lists</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-06. Linked List/23. Merge k Sorted Lists">23. Merge k Sorted Lists</a></li>
</ul>
</li>
<li class="toctree-l1 toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-07. Trees/README">Trees Problems - Blind 75 LeetCode</a><ul class="visible nav section-nav flex-column">
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-07. Trees/100. Same Tree">100: Same Tree</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-07. Trees/102. Binary Tree Level Order Traversal">102. Binary Tree Level Order Traversal</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-07. Trees/104. Maximum Depth of Binary Tree">104. Maximum Depth of Binary Tree</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-07. Trees/105. Construct Binary Tree from Preorder and Inorder Traversal">105. Construct Binary Tree from Preorder and Inorder Traversal</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-07. Trees/124. Binary Tree Maximum Path Sum">124. Binary Tree Maximum Path Sum</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-07. Trees/199. Binary Tree Right Side View">199. Binary Tree Right Side View</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-07. Trees/226. Invert Binary Tree">226: Invert Binary Tree</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-07. Trees/230. Kth Smallest Element in a BST">230. Kth Smallest Element in a BST</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-07. Trees/235. Lowest Common Ancestor of a Binary Search Tree">235. Lowest Common Ancestor of a Binary Search Tree</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-07. Trees/297. Serialize and Deserialize Binary Tree">297. Serialize and Deserialize Binary Tree</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-07. Trees/572. Subtree of Another Tree">572: Subtree of Another Tree</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-07. Trees/98. Validate Binary Search Tree">98. Validate Binary Search Tree</a></li>
</ul>
</li>
<li class="toctree-l1 toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-08. Tries/README">Trie Problems - Blind 75 LeetCode</a><ul class="visible nav section-nav flex-column">
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-08. Tries/208. Implement Trie (Prefix Tree)">208. Implement Trie (Prefix Tree)</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-08. Tries/211. Design Add and Search Words Data Structure">211. Design Add and Search Words Data Structure</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-08. Tries/212. Word Search II">212. Word Search II</a></li>
</ul>
</li>
<li class="toctree-l1 toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-09. Heap - Priority Queue/README">Heap / Priority Queue Problems - Blind 75 LeetCode</a><ul class="visible nav section-nav flex-column">
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-09. Heap - Priority Queue/1046. Last Stone Weight">1046. Last Stone Weight</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-09. Heap - Priority Queue/295. Find Median from Data Stream">295. Find Median from Data Stream</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-09. Heap - Priority Queue/703. Kth Largest Element in a Stream">703. Kth Largest Element in a Stream</a></li>
</ul>
</li>
<li class="toctree-l1 toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-10. Backtracking/README">Backtracking Problems - Blind 75 LeetCode</a><ul class="visible nav section-nav flex-column">
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-10. Backtracking/39. Combination Sum">39. Combination Sum</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-10. Backtracking/79. Word Search">79. Word Search</a></li>
</ul>
</li>
<li class="toctree-l1 toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-11. Graphs/README">Graphs Problems - Blind 75 LeetCode</a><ul class="visible nav section-nav flex-column">
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-11. Graphs/133. Clone Graph">133. Clone Graph</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-11. Graphs/178. Graph Valid Tree">178. Graph Valid Tree</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-11. Graphs/200. Number of Islands">200. Number of Islands</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-11. Graphs/207. Course Schedule">207. Course Schedule</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-11. Graphs/3651. Number of Connected Components in an Undirected Graph">3651. Number of Connected Components in an Undirected Graph</a></li>
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-11. Graphs/417. Pacific Atlantic Water Flow">417. Pacific Atlantic Water Flow</a></li>
</ul>
</li>
<li class="toctree-l1 toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-12. Advanced Graphs/README">Advanced Graphs Problems - Blind 75 LeetCode</a><ul class="visible nav section-nav flex-column">
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-12. Advanced Graphs/892. Alien Dictionary">892. Alien Dictionary</a></li>
</ul>
</li>
<li class="toctree-l1 toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-13. One-D Dynamic Programming/README">1-D Dynamic Programming Problems - Blind 75 LeetCode</a><ul class="visible nav section-nav flex-column">
<li class="toctree-l2 toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-13. One-D Dynamic Programming/70. Climbing Stairs">70. Climbing Stairs</a></li>
</ul>
</li>
<li class="toctree-l1 toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-14. Two-D Dynamic Programming/README">Blind 75 LeetCode Problems</a></li>
<li class="toctree-l1 toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-15. Greedy/README">Blind 75 LeetCode Problems</a></li>
<li class="toctree-l1 toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-16. Intervals/README">Blind 75 LeetCode Problems</a></li>
<li class="toctree-l1 toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-17. Math Geometry/README">Blind 75 LeetCode Problems</a></li>
<li class="toctree-l1 toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="README.html#document-18. Bit Manipulation/README">Blind 75 LeetCode Problems</a></li>
</ul>

  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Mohsen Tabibian and Saeed Samadidana
</p>

  </div>
  
  <div class="footer-item">
    
  <p class="copyright">
    
      © Copyright 2022.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/bootstrap.js?digest=365ca57ee442770a23c6"></script>
<script src="_static/scripts/pydata-sphinx-theme.js?digest=365ca57ee442770a23c6"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>